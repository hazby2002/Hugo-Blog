<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/</link>
    <description>Recent content on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 05 Aug 2022 23:16:50 +0800</lastBuildDate>
    
        <atom:link href="https://blog.asukakyle.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>[AGC036D] Negative Cycle</title>
        <link>https://blog.asukakyle.top/post/agc036d-negative-cycle/</link>
        <pubDate>Thu, 13 Jan 2022 20:31:35 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/agc036d-negative-cycle/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/agc036d-negative-cycle/ -
&gt; 题意：$n$ 个点的有向图，初始有边 $i \to i + 1$，边权为 0，不可删除。有边 $i \to j(i \neq j)$，边权为 $\begin{cases}1, &amp;i &gt; j\\-1, &amp;i&lt;j\end{cases}$，可删除，删除代价为 $a_{i, j}$，你需要删除一些边，使得这张图上没有负环，求最小代价。
&gt; 
&gt; $1 \leq n \leq 500$

有向图上没有负环，则存在最短路，则差分约束有解。

每个点设变量 $x_i$，那么一条 $i \to j$ 边权为 $w$ 的边就代表 $x_j - x_i \leq w$。

所以初始 $i \to i + 1$ 的边表示 $x_i \geq x_{i+1}$。

设 $d_i = x_{i-1} - x_i \geq 0$。

对于边 $i \to j$，$i &lt; j$ 时为第一类边，表示 $\sum\limits_{k = i + 1}^jd_k \geq 1$，则对于一串 $d_k = 0$上的此类边都需要删除；

$i &gt; j$ 时为第二类边，表示 $\sum\limits_{k=i+1}^jd_k \leq 1$，跨过多于一个1的边需要删除。

设 $dp(i, j)$ 表示考虑了前 $i$ 个变量，最后两个 1 分别在 $i, j$ 的最小代价，用二维前缀和计算区间删边的代价，时间复杂度 $O(n^3)$。

```cpp
void solve() {
  int n;
  std::cin &gt;&gt; n;
  std::vector a(n + 1, std::vector&lt;LL&gt;(n + 1)), b = a;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      if (i &lt; j) {
        std::cin &gt;&gt; a[i][j];
      } else if (i &gt; j) {
        std::cin &gt;&gt; b[i][j];
      }
      a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];
      b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];
    }
  }

  std::vector dp(n + 1, std::vector&lt;LL&gt;(n + 1, 1e18));
  for (int i = 0; i &lt;= n; i++) {
    dp[i][0] = a[i][i];
    for (int j = 1; j &lt; i; j++) {
      for (int k = 0; k &lt; j; k++) {
        smin(dp[i][j], dp[j][k] + b[i][k] - b[j][k]);
      }
      dp[i][j] += a[i][i] - a[i][j] - a[j][i] + a[j][j];
    }
  }
  
  LL ans = 1e18;
  for (int i = 0; i &lt; n; i++) {
    smin(ans, dp[n][i]);
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```- https://blog.asukakyle.top/post/agc036d-negative-cycle/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021CCPC网络赛</title>
        <link>https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/</link>
        <pubDate>Tue, 31 Aug 2021 09:15:07 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/ -| Pro. ID | Problem Title                                                | Solved                                                       |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 7100    | [ Cut The Wire](https://acm.hdu.edu.cn/showproblem.php?pid=7100) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7101    | [ Time-division Multiplexing](https://acm.hdu.edu.cn/showproblem.php?pid=7101) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7102    | [ Pattern Recognition](https://acm.hdu.edu.cn/showproblem.php?pid=7102) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛后） |
| 7103    | [ Depth First Search](https://acm.hdu.edu.cn/showproblem.php?pid=7103) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛后） |
| 7104    | [ Easy Math Problem](https://acm.hdu.edu.cn/showproblem.php?pid=7104) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛后） |
| 7105    | [ Power Sum](https://acm.hdu.edu.cn/showproblem.php?pid=7105) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7106    | [ Function](https://acm.hdu.edu.cn/showproblem.php?pid=7106) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7107    | [ GCD on Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=7107) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7108    | [ Command Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=7108) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7109    | [ Random Walk](https://acm.hdu.edu.cn/showproblem.php?pid=7109) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛后） |
| 7110    | [ Shooting Bricks](https://acm.hdu.edu.cn/showproblem.php?pid=7110) | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7111    | [ Remove](https://acm.hdu.edu.cn/showproblem.php?pid=7111)   | ![ 	You has solved this problem :-)	 ](https://acm.hdu.edu.cn/images/ac.gif)（赛时） |
| 7112    | [ Start Dash ! !](https://acm.hdu.edu.cn/showproblem.php?pid=7112) |                                                              |




## [ Cut The Wire](https://acm.hdu.edu.cn/showproblem.php?pid=7100)


## [ Time-division Multiplexing](https://acm.hdu.edu.cn/showproblem.php?pid=7101)
数据较水，1.1 倍过了。

```cpp
// Author:  HolyK
// Created: Sat Aug 28 13:37:05 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int N(105);
char s[N * 12], *p[N], *e[N], t[10000005];
int v[26];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int _;
  std::cin &gt;&gt; _;
  while (_--) {
    int n;
    std::cin &gt;&gt; n;   
    int len = 1;
    p[0] = e[0] = s;
    for (int i = 1; i &lt;= n; i++) {
      p[i] = e[i - 1];
      std::cin &gt;&gt; p[i];
      e[i] = p[i] + strlen(p[i]);
      int l = e[i] - p[i];
      len = len * l / std::__gcd(len, l);
    }
    len *= 1.1;
    char *o;
    memset(v, 0, sizeof v);
    for (o = s; o &lt; e[n]; o++) v[*o - &#39;a&#39;] = 1;
    int tot = std::accumulate(v, v + 26, 0);
    o = t;
    for (int i = 0; i &lt; len; i++) {
      for (int j = 1; j &lt;= n; j++) {
        *o++ = *p[j]++;
        if (p[j] == e[j]) p[j] = e[j - 1];
      }
    } 
    int ans = o - t, cnt = 0;
    memset(v, 0, sizeof v);
    for (char *i = t, *j = t; i &lt; o; i++) {
      if (1 == ++v[*i - &#39;a&#39;]) cnt++;
      while (cnt == tot) {
        smin(ans, i - j + 1);
        if (0 == --v[*j++ - &#39;a&#39;]) cnt--;
      }
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [ Pattern Recognition](https://acm.hdu.edu.cn/showproblem.php?pid=7102)
和多校题差不多，只不过换成了矩阵，只要建出广义 sam 即可。

数据太水，sam 点数太少，爆踩 std。

```cpp
// Author:  HolyK
// Created: Sun Aug 29 20:49:05 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int N(4e5 + 5);
struct Sam {
  std::array&lt;int, 26&gt; ch[N];
  int len[N], fa[N], cnt;
  void init() {
    fa[0] = -1;
    len[0] = 0;
    for (int i = 0; i &lt;= cnt; i++) {
      ch[i].fill(0);
    }
    cnt = 0;
  }
  int ins(int last, int x) {
    if (ch[last][x] &amp;&amp; len[last] + 1 == len[ch[last][x]]) return ch[last][x];
    int p = last, np = ++cnt, q;
    len[np] = len[p] + 1;
    for (; ~p &amp;&amp; !ch[p][x]; p = fa[p]) ch[p][x] = np;
    if (p == -1) {
      fa[np] = 0;
    } else if (len[q = ch[p][x]] == len[p] + 1) {
      fa[np] = q;
    } else {
      int nq = p == last ? np : ++cnt;
      len[nq] = len[p] + 1;
      ch[nq] = ch[q];
      for (; ~p &amp;&amp; ch[p][x] == q; p = fa[p]) ch[p][x] = nq;
      fa[np] = nq;
      fa[nq] = fa[q];
      fa[q] = nq;    
    }
    return np;
  }
} a, b;
int n, m, q;
struct Node {
  Node *ls, *rs;
  int w;
} t[N * 50], *cur;
void ins(Node *&amp;o, int l, int r, int x) {
  if (!o) o = cur++, *o = {nullptr, nullptr, 0};
  o-&gt;w++;
  if (l == r) return;
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? ins(o-&gt;ls, l, m, x) : ins(o-&gt;rs, m + 1, r, x);
}
int ask(Node *o, int l, int r, int x, int y) {
  if (!o || r &lt; x || y &lt; l) return 0;
  if (x &lt;= l &amp;&amp; r &lt;= y) return o-&gt;w;
  int m = l + r &gt;&gt; 1;
  return ask(o-&gt;ls, l, m, x, y) + ask(o-&gt;rs, m + 1, r, x, y);
}
Node *merge(Node *x, Node *y) {
  if (!x) return y;
  if (!y) return x;
  Node *o = cur++;
  o-&gt;w = x-&gt;w + y-&gt;w;
  o-&gt;ls = merge(x-&gt;ls, y-&gt;ls);
  o-&gt;rs = merge(x-&gt;rs, y-&gt;rs);
  return o;
}
Node *root[N];
std::vector&lt;int&gt; g[N];
int in[N], out[N], cnt;
void dfs1(int x) {
  in[x] = ++cnt;
  for (int y : g[x]) {
    dfs1(y);
  }
  out[x] = cnt;
}
void dfs2(int x) {
  for (int y : g[x]) {
    dfs2(y);
    root[x] = merge(root[x], root[y]);
  }
}
void solve() {
  cur = t;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  std::vector&lt;std::string&gt; s(n);
  std::vector&lt;int&gt; pos1(n * m), pos2(n * m), pos3(n * m), pos4(n * m);
  a.init(), b.init();
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; s[i];
    for (int j = 0, p = 0; j &lt; m; j++) {
      pos1[i * m + j] = p = a.ins(p, s[i][j] - &#39;a&#39;);
    }
    for (int j = m - 1, p = 0; j &gt;= 0; j--) {
      pos2[i * m + j] = p = a.ins(p, s[i][j] - &#39;a&#39;);
    }
  }
  for (int j = 0; j &lt; m; j++) {
    for (int i = 0, p = 0; i &lt; n; i++) {
      pos3[i * m + j] = p = b.ins(p, s[i][j] - &#39;a&#39;);
    }
    for (int i = n - 1, p = 0; i &gt;= 0; i--) {
      pos4[i * m + j] = p = b.ins(p, s[i][j] - &#39;a&#39;);
    }
  }
  for (int i = 0; i &lt;= a.cnt; i++) {
    g[i].clear();
  }
  for (int i = 1; i &lt;= a.cnt; i++) {
    g[a.fa[i]].push_back(i);
  }
  cnt = -1, dfs1(0);
  for (int i = 0; i &lt;= b.cnt; i++) {
    g[i].clear();
    root[i] = 0;
  }
  for (int i = 0; i &lt; n * m; i++) {
    int x = in[pos1[i]], y = in[pos2[i]];
    assert(x &amp;&amp; y);
    ins(root[pos3[i]], 1, cnt, x);
    ins(root[pos3[i]], 1, cnt, y);
    ins(root[pos4[i]], 1, cnt, x);
    ins(root[pos4[i]], 1, cnt, y);
  }
  for (int i = 1; i &lt;= b.cnt; i++) {
    g[b.fa[i]].push_back(i);
  }
  dfs2(0);
  while (q--) {
    std::string s;
    std::cin &gt;&gt; s;
    n = s.size();
    pos1.assign(n, 0);
    for (int i = 0, o = 0; i &lt; n; i++) {
      pos1[i] = o = a.ch[o][s[i] - &#39;a&#39;];
      if (!o) break;
    }
    pos2.assign(n, 0);
    for (int i = n - 1, o = 0; i &gt;= 0; i--) {
      pos2[i] = o = a.ch[o][s[i] - &#39;a&#39;];
      if (!o) break;
    }
    pos3.assign(n, 0);
    for (int i = 0, o = 0; i &lt; n; i++) {
      pos3[i] = o = b.ch[o][s[i] - &#39;a&#39;];
      if (!o) break;
    }
    pos4.assign(n, 0);
    for (int i = n - 1, o = 0; i &gt;= 0; i--) {
      pos4[i] = o = b.ch[o][s[i] - &#39;a&#39;];
      if (!o) break;
    }
    int ans = 0, ans1 = 0;
    if (n == 1 &amp;&amp; pos1[0] &amp;&amp; pos4[0]) {
      ans1 = ask(root[pos4[0]], 1, cnt, in[pos1[0]], out[pos1[0]]);
    }
    for (int i = 0; i + 1 &lt; n; i++) {
      if (pos1[i] &amp;&amp; pos4[i]) {
        (i ? ans : ans1) += ask(root[pos4[i]], 1, cnt, in[pos1[i]], out[pos1[i]]);
      }
      if (pos2[i] &amp;&amp; pos3[i]) {
        (i ? ans : ans1) += ask(root[pos3[i]], 1, cnt, in[pos2[i]], out[pos2[i]]);
      }
    }
    ans += ans1 / 2;
    auto t = s;
    std::reverse(t.begin(), t.end());
    if (t == s) ans /= 2;
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
}
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

## [ Depth First Search](https://acm.hdu.edu.cn/showproblem.php?pid=7103)
拆点，LCT。

```cpp
// Author:  HolyK
// Created: Sun Aug 29 16:57:07 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(4e5 + 5);
struct Node {
  Node *ch[2], *fa;
#define ls ch[0]
#define rs ch[1]
  
  int dir() const { return this == fa-&gt;rs; }
  bool nrt() const { return fa &amp;&amp; (this == fa-&gt;ls || this == fa-&gt;rs); }
  void sch(int d, Node *x) {
    ch[d] = x;
    if (x) x-&gt;fa = this;
  }
  void rotate() {
    Node *p = fa;
    int k = dir();
    fa = p-&gt;fa;
    if (p-&gt;nrt()) fa-&gt;ch[p-&gt;dir()] = this;
    p-&gt;sch(k, ch[!k]), sch(!k, p);
    p-&gt;pushup();
    // pushup();
  }
  void splay() {
    for (; nrt(); rotate()) {
      if (fa-&gt;nrt()) {
        (dir() == fa-&gt;dir() ? fa : this)-&gt;rotate();
      }
    }
    pushup();
  }
  void access() {
    for (splay(), rs = nullptr; fa; rotate()) {
      fa-&gt;splay(), fa-&gt;rs = this;
    }
    pushup();
  }
  void link(Node *p) {
    p-&gt;access();
    fa = p;
  }
  void cut() {
    access();
    if (ls) ls-&gt;fa = nullptr, ls = nullptr, pushup();
  }
  LL sum;
  int max, val, id;
  void pushup() {
    sum = max = val;
    if (ls) sum += ls-&gt;sum, smax(max, ls-&gt;max);
    if (rs) sum += rs-&gt;sum, smax(max, rs-&gt;max);
  }
} t[N * 2], *cur;
Node *newNode(int id, int val) {
  cur-&gt;ls = cur-&gt;rs = cur-&gt;fa = 0;
  cur-&gt;sum = cur-&gt;max = cur-&gt;val = val;
  cur-&gt;id = id;
  return cur++;
}
std::list&lt;int&gt; bfs;
std::list&lt;int&gt;::iterator iter[N];

Node *r[N * 2][2];
int dep[N];
int expose(int x, int d) {
  Node *o = r[x][0], *p = o;
  o-&gt;access();
  int res = 0;
  while (o) {
    p = o;
    if (dep[o-&gt;id] - dep[x] == d) {
      res = o-&gt;id;
    }
    if (dep[o-&gt;id] - dep[x] &lt; d) {
      o = o-&gt;ls;
    } else {
      o = o-&gt;rs;
    }
  }
  assert(dep[res] - dep[x] == d);
  p-&gt;splay();
  return res;
}
int son[N], fa[N];
void solve() {
  cur = t;
  bfs.clear();
  iter[1] = bfs.insert(bfs.end(), 1);
  r[1][0] = newNode(1, 1);
  r[1][1] = newNode(1, 0);
  int q;
  cin &gt;&gt; q;
  for (int i = q + 2, p = 1; i &lt;= q + q + 1; i++) {
    son[p] = 1, fa[i] = p;
    dep[i] = dep[p] + 1;
    r[i][0] = newNode(i, i);
    r[i][1] = newNode(i, 0);
    r[p][0]-&gt;link(r[i][0]);
    r[p][1]-&gt;link(r[i][0]);
    iter[i] = bfs.insert(bfs.end(), i);
    p = i;
  }
  son[q + q + 1] = 0;
  int key = 0;
  for (int t = 1; t &lt;= q; t++) {
    auto addLeaf = [&amp;](int x) {
      assert(!son[x]);
      int y;
      if (dep[y = *std::prev(iter[x])] == dep[x] &amp;&amp; !son[y]) {
        r[y][0]-&gt;cut();
        r[y][1]-&gt;cut();
        r[y][0]-&gt;link(r[x][1]);
        r[y][1]-&gt;link(r[x][1]);
      }
      if (dep[y = *std::next(iter[x])] == dep[x]) {
        r[x][0]-&gt;link(r[y][1]);
        r[x][1]-&gt;link(r[y][1]);
      }
    };
    int opt, x, y, z;
    cin &gt;&gt; opt &gt;&gt; x;
    x ^= key;
    if (opt == 1) {
      cin &gt;&gt; y &gt;&gt; z;
      y ^= key;
      z ^= key;
      dep[x] = dep[y] + 1;
      fa[x] = y;
      son[x] = 0, son[y]++;
      r[x][0] = newNode(x, x);
      r[x][1] = newNode(x, 0);
      if (!z) {
        z = expose(y, 1);
        r[y][0]-&gt;cut();
        r[y][1]-&gt;cut();
        r[y][0]-&gt;link(r[x][0]);
        r[y][1]-&gt;link(r[x][0]);
      } else {
        z = *std::next(iter[z]);
      }
      iter[x] = bfs.insert(iter[z], x);
      addLeaf(x);
    } else if (opt == 2) {

      r[x][0]-&gt;cut();
      r[x][1]-&gt;cut();
      y = *std::prev(iter[x]);
      z = *std::next(iter[x]);
      bfs.erase(iter[x]);
      if (dep[x] == dep[y] &amp;&amp; !son[y]) {
        r[y][0]-&gt;cut();
        r[y][1]-&gt;cut();
        if (dep[y] == dep[z]) {
          r[y][0]-&gt;link(r[z][1]);
          r[y][1]-&gt;link(r[z][1]);
        }
      }
      son[fa[x]]--;
      if (fa[x] != fa[y]) {
        y = fa[x];
        r[y][0]-&gt;cut();
        r[y][1]-&gt;cut();
        if (y == fa[z]) {
          r[y][0]-&gt;link(r[z][0]);
          r[y][1]-&gt;link(r[z][0]);
        } else {
          addLeaf(y);
        }
      }
    } else {
      cin &gt;&gt; z;
      z ^= key;
      LL a;
      int b;
      if (!z) {
        a = b = x;
      } else {
        y = expose(x, z);
        Node *o = r[y][0];
        o-&gt;splay();
        assert(o-&gt;rs);
        a = o-&gt;rs-&gt;sum + y;
        b = std::max(o-&gt;rs-&gt;max, y);
      }
      key = a % b;
      std::cout &lt;&lt; a &lt;&lt; &#34; &#34; &lt;&lt; b &lt;&lt; &#34;\n&#34;;
    }
  }
}
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

## [ Easy Math Problem](https://acm.hdu.edu.cn/showproblem.php?pid=7104)
```cpp
// Author:  HolyK
// Created: Sat Aug 28 21:36:36 2021
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;array&gt;
#include &lt;utility&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) { return x % P; }
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z(LL v) : x((v %= P) &lt; 0 ? v + P : v) {}
  explicit operator bool() { return !!x; }
  Z inv() const { return Z(fpow(x)); }
  Z pow(int k) const { return Z(fpow(x, k)); }
  Z operator-() const { return Z(P - x); }
  Z &amp;operator+=(const Z &amp;r) { return inc(x, r.x), *this; }
  Z &amp;operator-=(const Z &amp;r) { return dec(x, r.x), *this; }
  Z &amp;operator*=(const Z &amp;r) { return x = LL(x) * r.x % P, *this; }
  Z &amp;operator/=(const Z &amp;r) { return x = LL(x) * fpow(r.x) % P, *this; }
  inline friend Z operator+(const Z &amp;a, const Z &amp;b) { return Z(a) += b; }
  inline friend Z operator-(const Z &amp;a, const Z &amp;b) { return Z(a) -= b; }
  inline friend Z operator*(const Z &amp;a, const Z &amp;b) { return Z(a) *= b; }
  inline friend Z operator/(const Z &amp;a, const Z &amp;b) { return Z(a) /= b; }
  inline friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;r) {
    return os &lt;&lt; r.x;
  }
};

using Matrix = std::array&lt;Z, 4&gt;;
Matrix operator*(const Matrix &amp;a, const Z &amp;b) {
  return {a[0] * b, a[1] * b, a[2] * b, a[3] * b};
}
Matrix operator+(const Matrix &amp;a, const Matrix &amp;b) {
  return {a[0] + b[0], a[1] + b[1], a[2] + b[2], a[3] + b[3]};
}
Matrix operator-(const Matrix &amp;a, const Matrix &amp;b) {
  return {a[0] - b[0], a[1] - b[1], a[2] - b[2], a[3] - b[3]};
}
Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) {
  return {a[0] * b[0] + a[1] * b[2], a[0] * b[1] + a[1] * b[3],
          a[2] * b[0] + a[3] * b[2], a[2] * b[1] + a[3] * b[3]};
}
constexpr int N(2e5 + 5);
Z fac[N], ifac[N], inv[N];
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i;
  ifac[n] = fac[n].inv();
  for (int i = n; i; i--) ifac[i - 1] = ifac[i] * i;
  inv[1] = 1;
  for (int i = 2; i &lt;= n; i++) inv[i] = inv[P % i] * (P - P / i);
}
Matrix f[N], g[N], h[N];
int main() {
  freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  init(2e5);
  int t;
  std::cin &gt;&gt; t;
  g[0] = h[0] = {1, 0, 0, 1};
  while (t--) {
    int n;
    Z a, b, c, d, e, ans;
    std::cin &gt;&gt; n &gt;&gt; a.x &gt;&gt; b.x &gt;&gt; c.x &gt;&gt; d.x &gt;&gt; e.x;
    Matrix aa = {b, 1, c, 0}, bb = {d, 1, e, 0};
    
    for (int i = 1; i &lt;= 2 * n; i++) {
      if (i &lt;= n) {
        g[i] = g[i - 1] * aa;
        h[i] = h[i - 1] * bb;
      } else {
        g[i] = h[i] = {0, 0, 0, 0};
      }
    }
    auto pa = g[n] * aa, pb = h[n] * bb;
    for (int i = 1; i &lt;= n; i++) {
      g[i] = g[i] * ifac[i];
      h[i] = h[i] * ifac[i];
    }
    f[2] = g[1] * h[1];
    for (int i = 2; i &lt; 2 * n; i++) {
      f[i + 1] = aa * f[i] + f[i] * bb ;
      if (i &gt; n) {
        f[i + 1] = f[i + 1] - (pa * h[i - n] + g[i - n] * pb) * ifac[n];
      } else {
        f[i + 1] = f[i + 1] + aa * h[i] + g[i] * bb;
      }
      f[i + 1] = f[i + 1] * inv[i + 1];
    }
    a /= c;
    for (int i = 2; i &lt;= 2 * n; i++) {
      f[i] = f[i] * fac[i];
      ans += f[i][2] * a;
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [ Power Sum](https://acm.hdu.edu.cn/showproblem.php?pid=7105)
```cpp
// Author:  HolyK
// Created: Sat Aug 28 12:20:19 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  auto out = [&amp;](int n) {
    for (int i = 1; i &lt;= n; i += 4) {
      std::cout &lt;&lt; &#34;1001&#34;;
    }
    std::cout &lt;&lt; &#34;\n&#34;;
  };
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int n;
    std::cin &gt;&gt; n;
    
    if (n % 4 == 0) {
      std::cout &lt;&lt; n &lt;&lt; &#34;\n&#34;;
      out(n);
    } else if (n % 4 == 1) {
      std::cout &lt;&lt; n &lt;&lt; &#34;\n&#34;;
      std::cout &lt;&lt; &#34;1&#34;;
      out(n - 1);
    } else if (n % 4 == 2) {
      std::cout &lt;&lt; n + 2 &lt;&lt; &#34;\n&#34;;
      std::cout &lt;&lt; &#34;0001&#34;; // 2
      out(n - 2);
    } else if (n % 4 == 3) {
      std::cout &lt;&lt; n + 2 &lt;&lt; &#34;\n&#34;;
      std::cout &lt;&lt; &#34;0&#34;;
      out(n + 1);
    }
             
  }
  return 0;
}
```

## [ Function](https://acm.hdu.edu.cn/showproblem.php?pid=7106)
```cpp
// Author:  HolyK
// Created: Sat Aug 28 13:08:51 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int cal(int x) {
  int r = 0;
  for (; x; x /= 10) r += x % 10;
  return r;
}
std::vector&lt;int&gt; s[60];
LL cal(LL a, LL b, LL x) {
  return (a * x + b) * x;
}
LL n;
LL getMin(std::vector&lt;int&gt; &amp;s, LL a, LL b) {
  LL r = LLONG_MAX;
  if (s.empty()) return r;
  if (s[0] &gt; n) return r;
  smin(r, cal(a, b, s[0]));
  auto end = std::upper_bound(s.begin(), s.end(), n);
  smin(r, cal(a, b, *std::prev(end)));
  if (a &gt; 0) {
    LL u = -b / (2 * a);
    auto it = std::lower_bound(s.begin(), end, u);
    if (it &lt; end) smin(r, cal(a, b, *it));
    if (it != s.begin() &amp;&amp; *--it &lt;= n) smin(r, cal(a, b, *it));
  }
  return r;
}
// std::mt19937_64 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());
// LL rnd(LL l, LL r) {
//   if (l &gt; r) std::swap(l, r);
//   return l + rng() % (r - l + 1);
// }
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (int i = 1; i &lt;= 1e6; i++) {
    s[cal(i)].push_back(i);
  }
  int t;
  std::cin &gt;&gt; t;
  // t = 100000;
  while (t--) {
    LL a, b, c, d;
    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; n;
    // a = rnd(-1000, 1000);
    // b = rnd(-1e6, 1e6);
    // c = rnd(-1e6, 1e6);
    // d = rnd(-1e6, 1e6);
    // n = rnd(1, 1e3);
    LL r = LLONG_MAX;
    for (int i = 1; i &lt;= 54; i++) {
      smin(r, getMin(s[i], a * i + b, i * (c * i + d)));
    }
    std::cout &lt;&lt; r &lt;&lt; &#34;\n&#34;;

    // LL rr = LLONG_MAX;
    // for (int i = 1; i &lt;= n; i++) {
    //   int j = cal(i);
    //   smin(rr, cal(a * j + b, j * (c * j + d), i));
    // }
    // if (rr != r) {
    //   std::cerr &lt;&lt; a &lt;&lt; &#34; &#34; &lt;&lt; b &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; &#34; &#34; &lt;&lt; d &lt;&lt; &#34; &#34; &lt;&lt; n &lt;&lt; &#34;\n&#34;;
    //   break;
    // }
    // std::cerr &lt;&lt; &#34;ac\n&#34;;
  }
  return 0;
}
```

## [ GCD on Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=7107)
```cpp
// Author:  HolyK
// Created: Sat Aug 28 15:57:56 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int N(1e5 + 6);
std::vector&lt;int&gt; fac[N];
void init(int n) {
  for (int i = n; i &gt;= 1; i--) {
    for (int j = i; j &lt;= n; j += i) {
      fac[j].push_back(i);
    }
  }
}
int n, a[N], pos[N];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
LL sum[N &lt;&lt; 2], ans[N];
int min[N &lt;&lt; 2], max[N &lt;&lt; 2];
PII tag[N &lt;&lt; 2];
void modify(int o, int l, int r, PII x) {
  tag[o] = x;
  sum[o] = (r - l + 1LL) * x.second;
  max[o] = min[o] = x.first;
}
void pushup(int o) {
  min[o] = std::min(min[ls], min[rs]);
  max[o] = std::max(max[ls], max[rs]);
  sum[o] = sum[ls] + sum[rs];
}
void pushdown(int o, int l, int r) {
  if (tag[o].first) {
    int m = l + r &gt;&gt; 1;
    modify(ls, l, m, tag[o]);
    modify(rs, m + 1, r, tag[o]);
    tag[o].first = 0;
  }
}
void update(int o, int l, int r, int x, int y, int z, int i) {
  if (min[o] &gt;= z) return;
  if (x &lt;= l &amp;&amp; r &lt;= y &amp;&amp; max[o] == min[o]) {
    ans[max[o]] += i * (r - l + 1LL) - sum[o];
    modify(o, l, r, {z, i});
    return;
  }
  pushdown(o, l, r);
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) update(ls, l, m, x, y, z, i);
  if (y &gt; m) update(rs, m + 1, r, x, y, z, i); 
  pushup(o);
}
void solve() {
  cin &gt;&gt; n;
  memset(pos, 0, (n + 1) * sizeof(int));
  memset(ans, 0, (n + 1) * sizeof(LL));
  memset(sum, 0, (n + 1) * 4 * sizeof(LL));
  memset(min, 0, (n + 1) * 4 * sizeof(int));
  memset(max, 0, (n + 1) * 4 * sizeof(int));
  memset(tag, 0, (n + 1) * 4 * sizeof(PII));
  for (int i = 1; i &lt;= n; i++) {
    cin &gt;&gt; a[i];
    std::vector&lt;int&gt; s;
    for (int j : fac[a[i]]) {
      if (pos[j]) {
        if (s.empty() || pos[s.back()] &lt; pos[j]) s.push_back(j);
      }
    }
    int last = 0;
    for (int x : s) {
      int j = pos[x];
      update(1, 1, n, last + 1, j, x, i);
      last = j;
    }
    for (int j : fac[a[i]]) {
      pos[j] = i;
    }
  }
  update(1, 1, n, 1, n, n + 1, n + 1);
  for (int i = 1; i &lt;= n; i++) {
    std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  }
}
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  init(1e5);
  int t;
  cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

## [ Command Sequence](https://acm.hdu.edu.cn/showproblem.php?pid=7108)
```cpp
// Author:  HolyK
// Created: Sat Aug 28 12:08:46 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int n;
    std::string s;
    std::cin &gt;&gt; n &gt;&gt; s;
    std::map&lt;PII, int&gt; mp;
    mp[{0, 0}] = 1;
    int x = 0, y = 0;
    LL ans = 0;
    for (char c : s) {
      if (c == &#39;U&#39;) {
        x++;
      } else if (c == &#39;D&#39;) {
        x--;
      } else if (c == &#39;L&#39;) {
        y++;
      } else {
        y--;
      }
      auto &amp;v = mp[{x, y}];
      ans += v;
      v++;
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [ Random Walk](https://acm.hdu.edu.cn/showproblem.php?pid=7109)
```cpp
// Author:  HolyK
// Created: Mon Aug 30 17:52:12 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) { return x % P; }
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z() : x(0) {}
  Z(int v) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z(LL v) : x((v %= P) &lt; 0 ? v + P : v) {}
  explicit operator bool() { return !!x; }
  Z inv() const { return Z(fpow(x)); }
  Z pow(int k) const { return Z(fpow(x, k)); }
  Z operator-() const { return Z(P - x); }
  Z &amp;operator+=(const Z &amp;r) { return inc(x, r.x), *this; }
  Z &amp;operator-=(const Z &amp;r) { return dec(x, r.x), *this; }
  Z &amp;operator*=(const Z &amp;r) { return x = LL(x) * r.x % P, *this; }
  Z &amp;operator/=(const Z &amp;r) { return x = LL(x) * fpow(r.x) % P, *this; }
  inline friend Z operator+(const Z &amp;a, const Z &amp;b) { return Z(a) += b; }
  inline friend Z operator-(const Z &amp;a, const Z &amp;b) { return Z(a) -= b; }
  inline friend Z operator*(const Z &amp;a, const Z &amp;b) { return Z(a) *= b; }
  inline friend Z operator/(const Z &amp;a, const Z &amp;b) { return Z(a) /= b; }
  inline friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;r) {
    return os &lt;&lt; r.x;
  }
};

inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(505);
Z p[N][N], ip[N][N * 2], w[N], ideg[N], a[9][N];

int deg[N], id[N][N];
struct Edge {
  int x, y, a, b;
} e[10005];
Z s[10005];
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, q;
  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt; n; i++) cin &gt;&gt; w[i].x;
  for (int i = 1; i &lt;= m; i++) {
    cin &gt;&gt; e[i].x &gt;&gt; e[i].y &gt;&gt; e[i].a &gt;&gt; e[i].b;
    deg[e[i].x]++, deg[e[i].y]++;
    id[e[i].x][e[i].y] = id[e[i].y][e[i].x] = i;
  }
  for (int i = 1; i &lt; n; i++) {
    ideg[i] = Z(deg[i]).inv();
  }
  for (int i = 1; i &lt;= m; i++) {
    int x = e[i].x, y = e[i].y;
    p[x][y] = ideg[x];
    p[y][x] = ideg[y];
  }
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt;= n; j++) {
      ip[i][j] = -p[i][j];
      if (i == j) {
        ip[i][j] += 1;
        ip[i][j + n + 1] = 1;
      }
    }
  }
  for (int i = 1, j; i &lt;= n; i++) {
    for (j = i; j &lt;= n &amp;&amp; !ip[j][i]; j++) ;
    assert(j &lt;= n);
    if (i != j) std::swap(ip[i], ip[j]);
    Z c = ip[i][i].inv();
    for (int k = n * 2 + 1; k &gt;= i; k--) ip[i][k] *= c;
    for (j = 1; j &lt;= n; j++) {
      if (i == j || !ip[j][i]) continue;
      c = ip[j][i];
      for (int k = n * 2 + 1; k &gt;= i; k--) {
        ip[j][k] -= ip[i][k] * c;
      }
    }
  }
  auto getp = [&amp;] {
    Z sum;
    for (int i = 1; i &lt; n; i++) sum += w[i];
    Z inv = sum.inv();
    for (int i = 1; i &lt; n; i++) {
      p[0][i] = w[i] * inv;
    }
    ip[0][0] = ip[0][n + 1] = 1;
    for (int i = 1; i &lt;= n; i++) {
      ip[0][i + n + 1] = 0;
      if (!p[0][i]) continue;
      for (int j = n + 1; j &lt;= n * 2 + 1; j++) {
        ip[0][j] += p[0][i] * ip[i][j];
      }
    }
    memset(a, 0, sizeof a);
    a[0][0] = 1;
    for (int i = 1; i &lt;= 7; i++) {
      for (int j = 0; j &lt;= n; j++) {
        for (int k = 0; k &lt;= n; k++) {
          a[i][k] += a[i - 1][j] * p[j][k];
        }
      }
    }
    for (int j = 0; j &lt;= n; j++) {
      for (int k = 0; k &lt;= n; k++) {
        a[8][k] += a[7][j] * ip[j][k + n + 1];
      }
    }
  };
  auto cal = [&amp;](int x, int y, int max, int min) {
    Z res;
    for (int i = 1; i &lt;= 6; i++) {
      res += (a[i][x] * ideg[x] + a[i][y] * ideg[y]) * std::max(max, min);
      max &gt;&gt;= 1;
    }
    res += (a[8][x] * ideg[x] + a[8][y] * ideg[y]) * min;
    return res;
  };
  Z ans;
  getp();
  for (int i = 1; i &lt;= m; i++) {
    ans += s[i] = cal(e[i].x, e[i].y, e[i].a, e[i].b);
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  while (q--) {
    int opt, x, y, a, b;
    cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    if (opt == 1) {
      int i = id[x][y];
      ans -= s[i];
      cin &gt;&gt; e[i].a &gt;&gt; e[i].b;
      ans += s[i] = cal(x, y, e[i].a, e[i].b);
    } else {
      w[x] = y;
      getp();
      ans = 0;
      for (int i = 1; i &lt;= m; i++) {
        ans += s[i] = cal(e[i].x, e[i].y, e[i].a, e[i].b);
      }
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [ Shooting Bricks](https://acm.hdu.edu.cn/showproblem.php?pid=7110)


## [ Remove](https://acm.hdu.edu.cn/showproblem.php?pid=7111)  
```cpp
// Author:  HolyK
// Created: Sat Aug 28 14:21:04 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int N(2e6 + 5);
int primes[N], g[N], val[N], vis[N], now, cnt;
std::bitset&lt;N&gt; np;
void init(int n) {
  cnt = 0;
  memset(g, 0, (n + 1) * sizeof(int));
  np.reset();
  for (int i = 2; i &lt;= n; i++) {
    if (!np[i]) {
      primes[++cnt] = i;
      g[i] = vis[i] == now ? i : 0;
    }
    for (int j = 1; j &lt;= cnt; j++){
      if (1LL * i * primes[j] &gt; n) break;
      g[i * primes[j]] = std::max(g[i], g[primes[j]]);
      np[i * primes[j]] = 1;
      if (i % primes[j] == 0) break;
    }
  }
}
int f[N], p[N];
int main() {
  freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  cin &gt;&gt; t;
  for (now = 1; now &lt;= t; now++) {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    int max = 0;
    for (int i = 1; i &lt;= m; i++) {
      cin &gt;&gt; p[i];
      vis[p[i]] = now;
      smax(max, p[i]);
    }
    init(n);
    for (int i = 1; i &lt; max; i++) f[i] = 1;
    for (int i = max, j = 2; i &lt;= n; i++) {
      while (j &lt; i &amp;&amp; j + g[j] &lt;= i) j++;
      // debug
      // int max = 0;
      // for (int k = 1; k &lt;= m; k++) {
      //   smax(max, i % p[k]);
      // }
      // if (i - max != j) {
      //   // std::cerr &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; j &lt;&lt; &#34; &#34; &lt;&lt; i - max &lt;&lt; &#34;\n&#34;;
      //   // std::cerr &lt;&lt; g[3589] &lt;&lt; &#34;\n&#34;;
      //   for (int k = 1; k &lt;= m; k++) {
      //     if (max == i % p[k]) std::cerr &lt;&lt; p[k] &lt;&lt; &#34;\n&#34;;
      //   }
      //   assert(false);
      // }
      //------
      f[i] = j &lt; i ? f[j] + 1 : 1e9;
    }
    uint64_t ans = 0;
    for (int i = 1; i &lt;= n; i++) {
      if (f[i] &gt;= 1e9) f[i] = 0;
      // std::cout &lt;&lt; f[i] &lt;&lt; &#34; \n&#34;[i == n];
      ans = (ans * 23333 + f[i]);
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  // std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## [ Start Dash ! !](https://acm.hdu.edu.cn/showproblem.php?pid=7112)

- https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021牛客多校10</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder10/</link>
        <pubDate>Wed, 18 Aug 2021 22:13:07 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder10/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder10/ -| 题号 |                             标题                             | 团队的状态 |
| :--: | :----------------------------------------------------------: | :--------: |
|  A   | [Browser Games](https://ac.nowcoder.com/acm/contest/11261/A) |    通过    |
|  B   | [Child&#39;s play](https://ac.nowcoder.com/acm/contest/11261/B)  |   未通过   |
|  C   |  [Dance Party](https://ac.nowcoder.com/acm/contest/11261/C)  |   未通过   |
|  D   | [Diameter Counting](https://ac.nowcoder.com/acm/contest/11261/D) |   未通过   |
|  E   | [More Fantastic Chess Problem](https://ac.nowcoder.com/acm/contest/11261/E) |   通过   |
|  F   |  [Train Wreck](https://ac.nowcoder.com/acm/contest/11261/F)  |    通过    |
|  G   | [Game of Death](https://ac.nowcoder.com/acm/contest/11261/G) |    通过    |
|  H   | [War of Inazuma (Easy Version)](https://ac.nowcoder.com/acm/contest/11261/H) |    通过    |
|  I   | [War of Inazuma (Hard Version)](https://ac.nowcoder.com/acm/contest/11261/I) |   未通过   |
|  J   | [Illuminations](https://ac.nowcoder.com/acm/contest/11261/J) |    通过    |
|  K   |    [Walking](https://ac.nowcoder.com/acm/contest/11261/K)    |    通过    |


## [Browser Games](https://ac.nowcoder.com/acm/contest/11261/A) 

## [Child&#39;s play](https://ac.nowcoder.com/acm/contest/11261/B) 

## [Dance Party](https://ac.nowcoder.com/acm/contest/11261/C) 

## [Diameter Counting](https://ac.nowcoder.com/acm/contest/11261/D)

## [More Fantastic Chess Problem](https://ac.nowcoder.com/acm/contest/11261/E)
```cpp
// Author:  HolyK
// Created: Tue Aug 31 10:32:26 2021
#include &lt;algorithm&gt;
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) { return x % P; }
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z(LL v) : x((v %= P) &lt; 0 ? v + P : v) {}
  explicit operator bool() { return !!x; }
  Z inv() const { return Z(fpow(x)); }
  Z pow(int k) const { return Z(fpow(x, k)); }
  Z operator-() const { return Z(P - x); }
  Z &amp;operator+=(const Z &amp;r) { return inc(x, r.x), *this; }
  Z &amp;operator-=(const Z &amp;r) { return dec(x, r.x), *this; }
  Z &amp;operator*=(const Z &amp;r) { return x = LL(x) * r.x % P, *this; }
  Z &amp;operator/=(const Z &amp;r) { return x = LL(x) * fpow(r.x) % P, *this; }
  inline friend Z operator+(const Z &amp;a, const Z &amp;b) { return Z(a) += b; }
  inline friend Z operator-(const Z &amp;a, const Z &amp;b) { return Z(a) -= b; }
  inline friend Z operator*(const Z &amp;a, const Z &amp;b) { return Z(a) *= b; }
  inline friend Z operator/(const Z &amp;a, const Z &amp;b) { return Z(a) /= b; }
  inline friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;r) {
    return os &lt;&lt; r.x;
  }
};
constexpr int N(3e5 + 5);
Z sum[N &lt;&lt; 2], tag[N &lt;&lt; 2];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
void mul(int o, Z x) {
  sum[o] *= x;
  tag[o] *= x;
}
void pushdown(int o) {
  if (tag[o].x != 1) {
    mul(ls, tag[o]), mul(rs, tag[o]), tag[o] = 1;
  }
}
void update(int o, int l, int r, int x, int y, Z z) {
  if (x &lt;= l &amp;&amp; r &lt;= y) return mul(o, z);
  pushdown(o);
  int m = l + r &gt;&gt; 1;
  if (x &lt; m) update(ls, l, m, x, y, z);
  if (y &gt; m) update(rs, m, r, x, y, z);
  sum[o] = sum[ls] + sum[rs];
}
void build(int o, int l, int r) {
  tag[o] = 1;
  sum[o] = r - l;
  if (r - l == 1) return;
  int m = l + r &gt;&gt; 1;
  build(ls, l, m), build(rs, m, r);
}

Z c[N][2];
int m;
void add(int p, int x) {
  Z v[2] = {(1LL - p) * x, x};
  for (; p &lt; m; p += p &amp; -p) c[p][0] += v[0], c[p][1] += v[1];
}
void add(int l, int r, int x) {
  add(l, x), add(r + 1, -x);
}
Z ask(int n) {
  Z r[2];
  for (int p = n; p; p -= p &amp; -p) r[0] += c[p][0], r[1] += c[p][1];
  return r[0] + r[1] * n;
}
Z ask(int l, int r) {
  return ask(r) - ask(l - 1);
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, q;
  std::string s;
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;
  std::vector&lt;int&gt; a(n), b(n);
  for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; a[i], smax(m, a[i]);
  for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; b[i];
  if (s == &#34;King&#34;) {
    std::vector&lt;Z&gt; c(n);
    Z ans = 1;
    for (int i = 0; i &lt; n; i++) {
      c[i] = 1 + (a[i] - b[i] &gt; 0) + (b[i] &gt; 1);
      ans *= c[i];
    }
    std::cout &lt;&lt; ans - 1 &lt;&lt; &#34;\n&#34;;
    while (q-- ) {
      int d;
      std::cin &gt;&gt; d;
      while (d--) {
        int i, x;
        std::cin &gt;&gt; i &gt;&gt; x;
        i--;
        ans /= c[i];
        b[i] += x;
        c[i] = 1 + (a[i] - b[i] &gt; 0) + (b[i] &gt; 1);
        ans *= c[i];
      }
      std::cout &lt;&lt; ans - 1 &lt;&lt; &#34;\n&#34;;
    }
  } else if (s == &#34;Queen&#34;) {
    Z ans;
    build(1, 1, m);
    Z i3 = Z(3).inv(), i2 = Z(2).inv();
    for (int i = 0; i &lt; n; i++) {
      int u = b[i], v = a[i] - b[i] + 1;
      if (u &gt; v) std::swap(u, v);
      if (1 &lt; u) update(1, 1, m, 1, u, 3);
      if (u &lt; v) update(1, 1, m, u, v, 2);
    }
    std::cout &lt;&lt; sum[1] - m + 1 &lt;&lt; &#34;\n&#34;;
    while (q--) {
      int d;
      std::cin &gt;&gt; d;
      while (d--) {
        int i, x;
        std::cin &gt;&gt; i &gt;&gt; x;
        i--;
        int u = b[i], v = a[i] - b[i] + 1;
        if (u &gt; v) std::swap(u, v);
        if (1 &lt; u) update(1, 1, m, 1, u, i3);
        if (u &lt; v) update(1, 1, m, u, v, i2);
        u = b[i] += x, v = a[i] - b[i] + 1;
        if (u &gt; v) std::swap(u, v);
        if (1 &lt; u) update(1, 1, m, 1, u, 3);
        if (u &lt; v) update(1, 1, m, u, v, 2);
      }
      std::cout &lt;&lt; sum[1] - m + 1 &lt;&lt; &#34;\n&#34;;
    }
  } else if (s == &#34;Rook&#34;) {
    q++;
    Z ans;
    for (int i = 0; i &lt; n; i++) ans += a[i] - 1;
    while (q--) {
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    }
  } else if (s == &#34;Bishop&#34;) {
    Z ans;
    for (int i = 0; i &lt; n; i++) {
      int u = b[i], v = a[i] - b[i] + 1;
      if (u &gt; v) std::swap(u, v);
      if (1 &lt; u) ans += ask(1, u - 1) * 2, add(1, u - 1, 2);
      if (u &lt; v) ans += ask(u, v - 1), add(u, v - 1, 1);
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    while (q--) {
      int d;
      std::cin &gt;&gt; d;
      while (d--) {
        int i, x;
        std::cin &gt;&gt; i &gt;&gt; x;
        i--;
        int u = b[i], v = a[i] - b[i] + 1;
        if (u &gt; v) std::swap(u, v);
        if (1 &lt; u) add(1, u - 1, -2), ans -= ask(1, u - 1) * 2;
        if (u &lt; v) add(u, v - 1, -1), ans -= ask(u, v - 1);
        u = b[i] += x, v = a[i] - b[i] + 1;
        if (u &gt; v) std::swap(u, v);
        if (1 &lt; u) ans += ask(1, u - 1) * 2, add(1, u - 1, 2);
        if (u &lt; v) ans += ask(u, v - 1), add(u, v - 1, 1);
      }
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    }
  } else if (s == &#34;Knight&#34;) {
    Z c, d, ans;
    for (int i = 0; i &lt; n; i++) {
      int x = (b[i] &gt; 1) + (a[i] - b[i] &gt; 0);
      int y = (b[i] &gt; 2) + (a[i] - b[i] &gt; 1);
      ans += c * y + d * x;
      c += x, d += y;
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    while (q--) {
      int k;
      std::cin &gt;&gt; k;
      while (k--) {
        int i, u;
        std::cin &gt;&gt; i &gt;&gt; u;
        i--;
        int x = (b[i] &gt; 1) + (a[i] - b[i] &gt; 0);
        int y = (b[i] &gt; 2) + (a[i] - b[i] &gt; 1);
        c -= x, d -= y;
        ans -= c * y + d * x;
        b[i] += u;
        x = (b[i] &gt; 1) + (a[i] - b[i] &gt; 0);
        y = (b[i] &gt; 2) + (a[i] - b[i] &gt; 1);
        ans += c * y + d * x;
        c += x, d += y;
      }
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    }
  } else {
    assert(false);
  }
  return 0;
}
```

## [Train Wreck](https://ac.nowcoder.com/acm/contest/11261/F)  

## [Game of Death](https://ac.nowcoder.com/acm/contest/11261/G) 
&gt; $n$ 个人，每个人等概率的选择其余的人开枪，有 $p$ 的概率击中，所有人同时开枪，分别求存活人数为 $0, 1, \dots, n$ 的概率。
&gt; 
&gt; $2 \leq n \leq 3 \times 10^5$

设 $f_i$ 表示恰好有 $i$ 个人存活的概率，$g_i$ 表示钦定 $i$ 个人存活的概率。
容易计算
$$
g_i = \binom{n}{i}\left(1-p + \frac{p(n-i)}{n-1}\right)^i\left(1-p+\frac{p(n-i-1)}{n-1}\right)^{n-i}
$$
又
$$
g_k = \sum_{i \geq k}f_i\binom{i}{k}
$$
二项式反演得
$$
\begin{aligned}
f_k &amp;= \sum_{i \geq k}g_i\binom{i}{k}(-1)^{i - k}\\
&amp;= \sum_{i \geq k}i!g_i\frac{1}{(i-k)!}\frac{1}{k!}
\end{aligned}
$$
这是卷积的形式。
```cpp
using namespace Polynomial;
constexpr int N(1e6 + 5);
int fac[N], ifac[N];
int bin(int n, int m) {
  if (m &lt; 0 || m &gt; n) return 0;
  return 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; i++) fac[i] = 1LL * fac[i - 1] * i % P;
  ifac[n] = fpow(fac[n]);
  for (int i = n - 1; i &gt; 0; i--) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % P;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, a, b;
  std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
  init(n);
  int p = 1LL * a * fpow(b) % P;
  Poly f(n + 1), g(n + 1);
  int invn = fpow(n - 1);
  for (int i = 0; i &lt;= n; i++) {
    f[i] = i &amp; 1 ? P - ifac[i] : ifac[i];
    g[i] = 1LL * fpow((P + 1 - p + 1LL * p * (i - 1) % P * invn) % P, i) * fpow((P + 1 - p + 1LL * p * i % P * invn) % P, n - i) % P * ifac[i] % P;
  }
  f = f * g;
  for (int i = 0; i &lt;= n; i++) {
    f[i] = 1LL * f[i] * fac[n] % P * ifac[n - i] % P;
  }
  for (int i = 0; i &lt;= n; i++) {
    std::cout &lt;&lt; f[n - i] &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [War of Inazuma (Easy Version)](https://ac.nowcoder.com/acm/contest/11261/H) 

## [War of Inazuma (Hard Version)](https://ac.nowcoder.com/acm/contest/11261/I)

## [Illuminations](https://ac.nowcoder.com/acm/contest/11261/J) 

## [Walking](https://ac.nowcoder.com/acm/contest/11261/K)    
&gt; 在一个 $n \times m$ 的网格图上，你在 $(a, b)$，每次移动可以向上下左右移动一格，不能移动出边界，求走 $t$ 步的方案数。
&gt; 
&gt; $1 \leq n, m, t \leq 5\times10^5$

把两维拆开分别计算走 $0 \dots t$ 步的方案数。

正难则反，考虑计算不合法方案数，记 $f_i$ 表示走 $i$ 步的不合法方案数。

发现不合法方案一定是先走到一个边界（$0$ 或 $n + 1$），接下来随便走。

所以设 $f&#39;_i$ 表示前 $i - 1$ 步都合法，恰好在第 $i$ 步走到边界的方案数。

有
$$
f_n = \sum_{k = 0}^nf&#39;_k2^{n-k}
$$
写成生成函数的形式，是
$$
F = \frac{F&#39;}{1 - 2x}
$$
下面考虑如何计算 $F&#39;$。

设 $f&#39;&#39;_i$ 表示走 $i$ 步，最终停在边界（$0$ 或 $1$）的方案数，这个可以轻易地用组合数计算。

$f&#39;&#39;_i$ 的方案一定是包含 $f&#39;_i$ 的方案的，可以发现， $f&#39;&#39;_k$ 表示的方案可以拆解成两个部分：先合法地走到边界，然后花费剩下的步数原地打转，或者从一个边界走到另一个边界。

设 $g_i$ 表示走 $i$ 步原地打转或者从一个边界移动到另一个边界的方案数，这个也可以用组合数计算。

写成生成函数的形式，是
$$
F&#39;&#39; = F&#39;G
$$
所以
$$
\begin{aligned}
F &amp;= \frac{F&#39;}{1 - 2x}\\
&amp;= \frac{F&#39;&#39;}{G(1-2x)}
\end{aligned}
$$
多项式求逆即可。

```cpp
using namespace Polynomial;
constexpr int N(1e6 + 5);
int fac[N], ifac[N];
int bin(int n, int m) {
  if (m &lt; 0 || m &gt; n) return 0;
  return 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; i++) fac[i] = 1LL * fac[i - 1] * i % P;
  ifac[n] = fpow(fac[n]);
  for (int i = n - 1; i &gt; 0; i--) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % P;
}
int cal(int n, int m) {
  if (n - m &amp; 1) return 0;
  return bin(n, (n + m) / 2);
}
Poly cal(int a, int n, int t) {
  Poly f(t + 1), g(t + 1);
  for (int i = 0; i &lt;= t; i++) {
    g[i] = cal(i, 0);
    inc(g[i], cal(i, n + 1));
  }
  for (int i = t; i &gt; 0; i--) {
    g[i] = (g[i] + (P - 2LL) * g[i - 1]) % P;
  }
  
  for (int i = 0; i &lt;= t; i++) {
    f[i] = cal(i, a);
    inc(f[i], cal(i, n + 1 - a));
  }
  g = inverse(g);
  f = f * g;
  f.resize(t + 1);
  for (int i = 0, p = 1; i &lt;= t; i++, p = 2LL * p % P) {
    f[i] = (p - f[i] + P) % P;
  }
  return f;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  init(1e6);
  int t, n, m, a, b;
  std::cin &gt;&gt; t &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;
  auto f = cal(a, n, t), g = cal(b, m, t);
  int ans = 0;
  for (int i = 0; i &lt;= t; i++) {
    ans = (ans + 1LL * bin(t, i) * f[i] % P * g[t - i]) % P;
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}
```- https://blog.asukakyle.top/post/2021nowcoder10/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>「万能」Euclidean 算法小记</title>
        <link>https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</link>
        <pubDate>Sun, 15 Aug 2021 21:24:32 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/ -## 「万能」Euclidean 算法
$$
F(P, R, Q, N, X, Y) = \prod_{i = 0}^N \left(Y^{f(i) - f(i-1)}X\right)
$$

其中 $f(i) = \lfloor \dfrac{Pi+R}{Q}\rfloor, f(-1) = 0$​。$X, Y$ ~~为操作序列，有乘法结合律，类比矩阵~~ $\in$ **半群** $(S, \times)$。

若 $R \geq Q$​，则 $f(i)= \lfloor \dfrac{Pi+(R \bmod Q)}{Q}\rfloor + \lfloor\dfrac{R}{Q}\rfloor$​，所以
$$
F(P, R, Q, N, X, Y) = Y^{\lfloor\dfrac{R}{Q}\rfloor}F(P, R \bmod Q, Q, N, X, Y)
$$

若 $P \geq Q$​，则 $f(i)= \lfloor \dfrac{(P \bmod Q)i+R}{Q}\rfloor + \lfloor\dfrac{P}{Q}\rfloor i$​，记 $f&#39;(i)= \lfloor \dfrac{(P \bmod Q)i+R}{Q}\rfloor$​
$$
\begin{aligned}
F(P, R, Q, N, X, Y) 
&amp;= X\prod_{i = 1}^N Y^{f&#39;(i) - f&#39;(i-1)}Y^{\lfloor\dfrac{P}{Q}\rfloor}X\\
&amp;= X\prod_{i = 0}^{N - 1} Y^{f&#39;(i+1) - f&#39;(i)}Y^{\lfloor\dfrac{P}{Q}\rfloor}X\\
&amp;= XF(P \bmod Q, (P \bmod Q) + R, Q, N - 1, Y^{\lfloor\dfrac{P}{Q}\rfloor}X, Y)
\end{aligned}
$$
若 $P &lt; Q$，考虑交换 $X, Y$。

第 $i$ 个 $X$ 前有 $f(i)$ 个 $Y$，设第 $i$ 个 $Y$ 前有 $g(i)$ 个 $X$，
$$
\begin{aligned}
g(i)
&amp;= \sum_{j \geq 0} [f(j) &lt; i+1]\\
&amp;= \sum_{j \geq 0} \left[\lfloor \frac{Pj+R}{Q}\rfloor &lt; i+1\right]\\
&amp;= \sum_{j \geq 0} \left[ Pj+R\ &lt; Qi+Q\right]\\
&amp;= \sum_{j \geq 0} \left[j &lt; \lfloor \frac{Qi + Q-R + P - 1}{P} \rfloor\right]\\
&amp;= \lfloor \frac{Qi + Q-R + P - 1}{P} \rfloor
\end{aligned}
$$
但是末尾还有一些 $X$​ 后面没有 $Y$​，需要单独拿出来 $X^{N+1 - \max g(i)}$。​​

于是
$$
F(P, R, Q, N, X, Y) = F(Q, Q - R + P - 1, P, \lfloor \frac{PN + R}{Q} \rfloor-1, Y, X)X^{N+1 - \max g(i)}
$$

复杂度为 $O(T(S) \log N\log \min\{p, q\})$，$T(S)$ 为 $S$ 上的乘法复杂度。

## 模板
`S` 即半群 $(S, \times)$ 的结构体，这里假定它是幺半群（否则可以加一个幺元进去），则 `S()` 代表幺元。

```cpp
LL div(LL p, LL i, LL r, LL q) {
  return (p * i + r) / q; 
}
S cal(LL p, LL r, LL q, LL n, const S &amp;x, const S &amp;y) {
  if (n &lt; 0) return S();
  if (r &gt;= q) {
    return fpow(y, r / q) * cal(p, r % q, q, n, x, y);
  }
  if (p &gt;= q) {
    return x * cal(p % q, p % q + r, q, n - 1, fpow(y, p / q) * x, y);
  }
  if (p == 0) {
    return fpow(x, n + 1);
  }
  LL m = div(p, n, r, q);
  return cal(q, q - r + p - 1, p, m - 1, y, x) * fpow(x, n + 1 - (!m ? 0 : div(q, m, p - r - 1, p)));
}
```

&lt;!-- ## 模板题
### [LOJ138](https://loj.ac/p/138)
给定 $n, a, b, c, k_1, k_2$，求
$$
\sum_{x=0}^nx^{k_1}\lfloor \frac{ax+b}{c} \rfloor^{k_2}
$$

简要解：$X$ 为把$x^{k_1}y^{k_2}$加到答案上，并且 `x++`，$Y$ 为把 `y++`。
因为有指数，所以要维护 $x^iy^j$。

```cpp
// Author:  HolyK
// Created: Sun Aug 15 21:59:21 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(1e9 + 7);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
int bin[11][11], n, m;
struct Info {
  int i, x, f[11][11];
  Info() : i(0), x(0) {
    memset(f, 0, sizeof f);
  }
};
Info operator*(Info a, Info b) {
  Info c;
  c.i = (a.i + b.i) % P;
  c.x = (a.x + b.x) % P;
  for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) c.f[i][j] = a.f[i][j];
  for (int j = 0, u = 1; j &lt;= n; j++, u = 1LL * u * a.i % P) {
    for (int p = j; p &lt;= n; p++) {
      int bu = 1LL * bin[p][j] * u % P;
      for (int k = 0, v = 1; k &lt;= m; k++, v = 1LL * v * a.x % P) {
        for (int q = k; q &lt;= m; q++) {
          c.f[p][q] = mod(c.f[p][q] + 1LL * bu * bin[q][k] % P * v % P * b.f[p - j][q - k]);
        }
      }
    }
  }
  return c;
}
Info fpow(Info x, LL k) {
  Info r;
  for (; k; k &gt;&gt;= 1, x = x * x) {
    if (k &amp; 1) r = r * x;
  }
  return r;
}
LL div(LL p, LL i, LL r, LL q) {
  return (p * i + r) / q; 
}
Info cal(LL p, LL r, LL q, LL n, const Info &amp;x, const Info &amp;y) {
  if (n &lt; 0) return Info();
  if (r &gt;= q) {
    return fpow(y, r / q) * cal(p, r % q, q, n, x, y);
  }
  if (p &gt;= q) {
    return x * cal(p % q, p % q + r, q, n - 1, fpow(y, p / q) * x, y);
  }
  if (p == 0) {
    return fpow(x, n + 1);
  }
  LL m = div(p, n, r, q);
  return cal(q, q - r + p - 1, p, m - 1, y, x) * fpow(x, n + 1 - (!m ? 0 : div(q, m, p - r - 1, p)));
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (int i = 0; i &lt;= 10; i++) {
    bin[i][0] = 1;
    for (int j = 1; j &lt;= i; j++) {
      bin[i][j] = (bin[i - 1][j] + bin[i - 1][j - 1]) % P;
    }
  }
  int t;
  std::cin &gt;&gt; t;
  Info x, y;
  x.i = 1;
  x.f[0][0] = 1;
  y.x = 1;
  while (t--) {
    int n, a, b, c, p, q;
    std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; p &gt;&gt; q;
    ::n = p, ::m = q;
    Info ans = cal(a, b, c, n, x, y);
    std::cout &lt;&lt; ans.f[p][q] &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

### [LOJ6440](https://loj.ac/p/6440)
```cpp
// Author:  HolyK
// Created: Sun Aug 15 15:52:19 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z pow(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};

using Matrix = std::vector&lt;std::vector&lt;int&gt;&gt;;
Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) {
  int n = a.size();
  Matrix c(n, std::vector&lt;int&gt;(n));
  for (int k = 0; k &lt; n; k++) {
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; n; j++) {
        c[i][j] = (c[i][j] + 1LL * a[i][k] * b[k][j]) % P;
      }
    }
  }
  return c;
}
Matrix &amp;operator+=(Matrix &amp;a, const Matrix &amp;b) {
  int n = a.size();
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      inc(a[i][j], b[i][j]);
    }
  }
  return a;
}
Matrix operator+(Matrix a, const Matrix &amp;b) {
  return a += b;
}
Matrix fpow(Matrix x, LL k) {
  Matrix r(x.size());
  for (int i = 0; i &lt; r.size(); i++) {
    r[i].resize(r.size());
    r[i][i] = 1;
  }
  for (; k; k &gt;&gt;= 1, x = x * x) {
    if (k &amp; 1) r = r * x;
  }
  return r;
}
struct Info {
  Matrix a, b, ans;
} one;
Info operator*(Info a, Info b) {
  return {
    a.a * b.a,
    a.b * b.b,
    a.ans + a.a * b.ans * a.b
  };
}
Info fpow(Info x, LL k) {
  assert(k &gt;= 0);
  Info r = one;
  for (; k; k &gt;&gt;= 1, x = x * x) {
    if (k &amp; 1) r = r * x;
  }
  return r;
}
LL div(LL p, LL i, LL r, LL q) {
  return ((__int128_t)p * i + r) / q; 
}
Info cal(LL p, LL r, LL q, LL n, const Info &amp;x, const Info &amp;y) {
  if (n &lt; 0) return one;
  if (r &gt;= q) {
    return fpow(y, r / q) * cal(p, r % q, q, n, x, y);
  }
  if (p &gt;= q) {
    return x * cal(p % q, p % q + r, q, n - 1, fpow(y, p / q) * x, y);
  }
  if (p == 0) {
    return fpow(x, n + 1);
  }
  LL m = div(p, n, r, q);
  return cal(q, q - r + p - 1, p, m - 1, y, x) * fpow(x, n + 1 - (!m ? 0 : div(q, m, p - r - 1, p)));
}


int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  LL p, q, r, l, n;
  std::cin &gt;&gt; p &gt;&gt; q &gt;&gt; r &gt;&gt; l &gt;&gt; n;
  Matrix zero(n, std::vector&lt;int&gt;(n)), o = zero;
  for (int i = 0; i &lt; n; i++) {
    o[i][i] = 1;
  }
  one.a = one.b = o, one.ans = zero;
  Matrix a = zero, b = zero;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      std::cin &gt;&gt; a[i][j];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      std::cin &gt;&gt; b[i][j];
    }
  }
  auto c = fpow(b, r / q);
  Info x = {a, o, o}, y = {o, b, zero};
  auto ans = cal(p, r, q, l, x, y).ans;
  
  // std::cerr &lt;&lt; b[0][0] &lt;&lt; &#34;\n&#34;;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      inc(ans[i][j], P - c[i][j]);
      std::cout &lt;&lt; ans[i][j] &lt;&lt; &#34; \n&#34;[j + 1 == n];
    }
  }
  return 0;
}
```
 --&gt;
- https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021牛客多校9</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder9/</link>
        <pubDate>Sat, 14 Aug 2021 18:36:09 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder9/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder9/ -| 题号 |                             标题                             | 团队的状态 |
| :--: | :----------------------------------------------------------: | :--------: |
|  A   | [A Math Challenge](https://ac.nowcoder.com/acm/contest/11260/A) |   通过   |
|  B   | [Best Subgraph](https://ac.nowcoder.com/acm/contest/11260/B) |   未通过   |
|  C   |     [Cells](https://ac.nowcoder.com/acm/contest/11260/C)     |    通过    |
|  D   | [Divide-and-conquer on Tree](https://ac.nowcoder.com/acm/contest/11260/D) |   未通过   |
|  E   |  [Eyjafjalla](https://ac.nowcoder.com/acm/contest/11260/E)   |    通过    |
|  F   | [Financial Order Execution](https://ac.nowcoder.com/acm/contest/11260/F) |   未通过   |
|  G   |  [Glass Balls](https://ac.nowcoder.com/acm/contest/11260/G)  |   通过   |
|  H   | [Happy Number](https://ac.nowcoder.com/acm/contest/11260/H)  |    通过    |
|  I   | [Incentive Model](https://ac.nowcoder.com/acm/contest/11260/I) |    通过    |
|  J   |      [Jam](https://ac.nowcoder.com/acm/contest/11260/J)      |   通过   |


## [A Math Challenge](https://ac.nowcoder.com/acm/contest/11260/A)
LOJ138 + 自然数幂和。

```cpp
// Author:  HolyK
// Created: Sun Aug 15 21:59:21 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z pow(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};
Z bin[52][52], inv[52];
struct Info {
  Z i, x, f[52][52];
  Info() : i(0), x(0) {
    memset(f, 0, sizeof f);
  }
};
int n, m;
Info operator*(Info a, Info b) {
  Info c;
  c.i = a.i + b.i;
  c.x = a.x + b.x;
  for (int i = 0; i &lt;= n; i++) {
    for (int j = 0; j &lt;= m; j++) {
      c.f[i][j] = a.f[i][j];
    }
  }
  Z u = 1, v, bu;
  for (int j = 0; j &lt;= n; j++, u *= a.i) {
    for (int p = j; p &lt;= n; p++) {
      bu = bin[p][j] * u, v = 1;
      for (int k = 0; k &lt;= m; k++, v *= a.x) {
        for (int q = k; q &lt;= m; q++) {
          c.f[p][q] += bu * bin[q][k] * v * b.f[p - j][q - k];
        }
      }
    }
  }
  return c;
}
Info fpow(Info x, LL k) {
  Info r;
  for (; k; k &gt;&gt;= 1, x = x * x) {
    if (k &amp; 1) r = r * x;
  }
  return r;
}
LL div(LL p, LL i, LL r, LL q) {
  return (p * i + r) / q; 
}
Info cal(LL p, LL r, LL q, LL n, const Info &amp;x, const Info &amp;y) {
  if (n &lt; 0) return Info();
  if (r &gt;= q) {
    return fpow(y, r / q) * cal(p, r % q, q, n, x, y);
  }
  if (p &gt;= q) {
    return x * cal(p % q, p % q + r, q, n - 1, fpow(y, p / q) * x, y);
  }
  if (p == 0) {
    return fpow(x, n + 1);
  }
  LL m = div(p, n, r, q);
  return cal(q, q - r + p - 1, p, m - 1, y, x) * fpow(x, n + 1 - (!m ? 0 : div(q, m, p - r - 1, p)));
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  for (int i = 0; i &lt;= 51; i++) {
    bin[i][0] = 1;
    for (int j = 1; j &lt;= i; j++) {
      bin[i][j] = bin[i - 1][j] + bin[i - 1][j - 1];
    }
  }
  int a, b, c, p, q, n;
  std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; p &gt;&gt; q &gt;&gt; n;
  q++;
  ::n = p, ::m = q;
  Info x, y;
  x.i = x.f[0][0] = y.x = 1;
  auto pw = cal(a, b, c, n, x, y);
  {
    std::vector&lt;std::vector&lt;Z&gt;&gt; a(q, std::vector&lt;Z&gt;(q + 1));
    Z sum = 0;
    for (int i = 0; i &lt; q; i++) {
      for (int j = 0; j &lt; q; j++) {
        a[i][j] = fpow(i + 1, j + 1);
      }
      a[i].back() = sum += fpow(i + 1, q - 1);
    }
    for (int i = 0, j; i &lt; q; i++) {
      for (j = i; j &lt; q; j++) {
        if (!a[j][i]) continue;
        std::swap(a[i], a[j]);
        break;
      }
      assert(a[i][i]);
      Z inv = a[i][i].inv();
      for (int k = 0; k &lt;= q; k++) a[i][k] *= inv;
      for (j = 0; j &lt; q; j++) {
        if (j == i || !a[j][i]) continue;
        for (int k = q; k &gt;= i; k--) {
          a[j][k] -= a[j][i] * a[i][k];
        }
      }
    }
    Z ans;
    for (int i = 0; i &lt; q; i++) {
      ans += pw.f[p][i + 1] * a[i].back();
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [Best Subgraph](https://ac.nowcoder.com/acm/contest/11260/B)

## [Cells](https://ac.nowcoder.com/acm/contest/11260/C)     

## [Divide-and-conquer on Tree](https://ac.nowcoder.com/acm/contest/11260/D)

## [Eyjafjalla](https://ac.nowcoder.com/acm/contest/11260/E)   

## [Financial Order Execution](https://ac.nowcoder.com/acm/contest/11260/F)

## [Glass Balls](https://ac.nowcoder.com/acm/contest/11260/G) 
### Solution 1
很难直接计算 $f(i)$​ 。

考虑条件期望，设事件 $C_i$ 表示点 $i$ 合法，即最多有一个儿子可以放行，事件 $N_i$ 表示 $i$ 到根这条路上的点合法，事件 $N$ 表示整棵树合法。

设 $X_{i, s}$​​ 表示球 $i$​​ 从 $s$​​ 开始，不考虑碰撞答案清零，会经过多少条边，特别地，记 $X_i = X_{i, i}$​​。

可以发现，$X_{i,s}$ 只和 $i$ 到根的路径上的情况有关，和其他事件是独立的，所以有
$$
\begin{aligned}
E(X|N)
&amp;= \sum_{}E(X_i|N)\\
&amp;= \sum\sum x\frac{P(X_i = x,N)}{P(N)}\\
&amp;= \sum\sum x\frac{P(X_i = x,N_{f_i}, N-N_{f_i})}{P(N_{f_i}, N-N_{f_i})}\\
&amp;= \sum\sum x\frac{P(X_i = x,N_{f_i})}{P(N_{f_i})}\\
&amp;= \sum E(X_i|N_{f_i})
\end{aligned}
$$
设 $Y_i$ 表示 $i$ 的儿子中可以通过的是哪个（可以都没有，此时 $Y=0$ ）。

根据期望的线性性，有
$$
\begin{aligned}
E(X_i | N_{f_i})
&amp;= E((X_{i, f_i} + 1) | N_{f_i})\\
&amp;= E(X_{i, f_i}|N_{f_i}) + P(Y_{f_i} = i | N_{f_i})\\
&amp;= [E(X_{f_i}|N_{f_{f_i}}) + 1]P(Y_{f_i} = i | C_{f_i})\\
\end{aligned}
$$
答案是 $E(X, N) = E(X|N)P(N)$​。
```cpp
// Author:  HolyK
// Created: Sat Aug 14 21:08:18 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z pow(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  Z p, np;
  std::cin &gt;&gt; n &gt;&gt; p.x;
  np = Z(1) - p;
  std::vector&lt;std::vector&lt;int&gt;&gt; g(n);
  for (int i = 1; i &lt; n; i++) {
    int x;
    std::cin &gt;&gt; x;
    x--;
    g[x].push_back(i);
  }
  Z ans, prod = 1;
  std::function&lt;void(int, Z)&gt; dfs = [&amp;](int x, Z d) {
    ans += d;
    if (!g[x].size()) {
      return;
    }
    Z k = p.pow(g[x].size() - 1) * np;
    Z v = k * Z(g[x].size()) + p.pow(g[x].size());
    prod *= v;
    k /= v;
    for (int y : g[x]) {
      dfs(y, (d + Z(1)) * k);
    }
  };
  dfs(0, 0);
  std::cout &lt;&lt; ans * prod &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

### Solution 2
将起点和终点交换，考虑计算每个点向下能走多少距离。

设 $f(i)$ 表示在 $i$ 的子树合法的情况下，$i$ 向下走的距离，$s(i)$ 表示在 $i$ 的子树合法的情况下，$i$ 子树的答案和，$v(i)$ 表示 $i$ 的子树合法的概率。

详细推导略。

```cpp
// Author:  HolyK
// Created: Sun Aug 15 10:11:38 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z pow(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  std::cin &gt;&gt; n;
  Z p;
  std::cin &gt;&gt; p.x;
  Z np = Z(1) - p;
  std::vector&lt;std::vector&lt;int&gt;&gt; g(n);
  for (int i = 1, x; i &lt; n; i++) {
    std::cin &gt;&gt; x;
    g[x - 1].push_back(i);
  }
  std::vector&lt;Z&gt; f(n), s(n), v(n);
  std::function&lt;void(int)&gt; dfs = [&amp;](int x) {
    v[x] = 1;
    if (!g[x].size()) {
      return;
    }
    for (int y : g[x]) {
      dfs(y);
      v[x] *= v[y];
    }
    Z k = p.pow(g[x].size() - 1) * np;
    Z c = k * Z(g[x].size()) + p.pow(g[x].size());
    for (int y : g[x]) {
      Z py = v[x] / v[y];
      s[x] += s[y] * py * c;
      f[x] += (f[y] + v[y]) * py * k;
    }
    v[x] *= c;
    s[x] += f[x];
  };
  dfs(0);
  std::cout &lt;&lt; s[0] &lt;&lt; &#34;\n&#34;;
  return 0;
}
```
## [Happy Number](https://ac.nowcoder.com/acm/contest/11260/H)  

## [Incentive Model](https://ac.nowcoder.com/acm/contest/11260/I) 

## [Jam](https://ac.nowcoder.com/acm/contest/11260/J)     

- https://blog.asukakyle.top/post/2021nowcoder9/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>特征多项式小记</title>
        <link>https://blog.asukakyle.top/post/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B0%8F%E8%AE%B0/</link>
        <pubDate>Thu, 12 Aug 2021 21:56:55 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B0%8F%E8%AE%B0/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B0%8F%E8%AE%B0/ -## Upper-Hessenberg 矩阵

$$
H_n = 
\begin{bmatrix}
a_{0, 0} &amp; a_{0, 1} &amp; a_{0, 2} &amp; a_{0, 3} &amp; \cdots &amp; a_{0, n - 1} &amp; a_{0, n}\\
a_{1, 0} &amp; a_{1, 1} &amp; a_{1, 2} &amp; a_{1, 3} &amp; \cdots &amp; a_{1, n - 1} &amp; a_{1, n}\\
0        &amp; a_{2, 1} &amp; a_{2, 2} &amp; a_{2, 3} &amp; \cdots &amp; a_{2, n - 1} &amp; a_{2, n}\\
0        &amp; 0        &amp; a_{3, 2} &amp; a_{3, 3} &amp; \cdots &amp; a_{3, n - 1} &amp; a_{3, n}\\
\vdots   &amp; \vdots   &amp; \ddots        &amp; \ddots   &amp; \ddots &amp; \vdots &amp;  \vdots\\
0  &amp; 0 &amp; 0 &amp; 0 &amp; a_{n - 1, n-2} &amp; a_{n - 1, n - 1} &amp; a_{n - 1, n}\\
0  &amp; 0 &amp; 0 &amp; 0 &amp; 0              &amp; a_{n, n - 1} &amp; a_{n, n}
\end{bmatrix}
$$

设 $h_n = \det H_n$​，则
$$
\begin{aligned}
h_n &amp;= a_{n, n}h_{n-1} - a_{n, n-1}
\begin{vmatrix}
a_{0, 0} &amp; a_{0, 1} &amp; a_{0, 2} &amp; a_{0, 3} &amp; \cdots &amp; a_{0, n}\\
a_{1, 0} &amp; a_{1, 1} &amp; a_{1, 2} &amp; a_{1, 3} &amp; \cdots &amp; a_{1, n}\\
0        &amp; a_{2, 1} &amp; a_{2, 2} &amp; a_{2, 3} &amp; \cdots &amp; a_{2, n}\\
0        &amp; 0        &amp; a_{3, 2} &amp; a_{3, 3} &amp; \cdots &amp; a_{3, n}\\
\vdots   &amp; \vdots   &amp; \ddots        &amp; \ddots   &amp; \ddots &amp;  \vdots\\
0  &amp; 0 &amp; 0 &amp; 0 &amp; a_{n - 1, n-2} &amp; a_{n - 1, n}\\
\end{vmatrix}\\
&amp;= a_{n, n}h_{n-1} -  a_{n, n-1}\left(
a_{n-1, n}h_{n-2} - a_{n-1, n-2}
\begin{vmatrix}
a_{0, 0} &amp; a_{0, 1} &amp; a_{0, 2} &amp; \cdots &amp; a_{0, n}\\
a_{1, 0} &amp; a_{1, 1} &amp; a_{1, 2} &amp; \cdots &amp; a_{1, n}\\
0        &amp; a_{2, 1} &amp; a_{2, 2} &amp; \cdots &amp; a_{2, n}\\
0        &amp; 0        &amp; a_{3, 2} &amp; \cdots &amp; a_{3, n}\\
\vdots   &amp; \vdots   &amp; \ddots   &amp; \ddots &amp;  \vdots\\
0  &amp; 0 &amp; 0 &amp; a_{n - 2, n-3} &amp; a_{n - 2, n}\\
\end{vmatrix}\\
\right)\\
&amp;= \cdots\cdots\cdots\cdots\\
&amp;= \sum_{i = 0}^{n-1}h_{n-1-i}\cdot(-1)^ia_{n-i, n}\prod_{j=0}^{i-1}a_{n-j, n-j-1}
\end{aligned}
$$

复杂度 $O(n^3)$。

```cpp
std::vector&lt;Z&gt; charPoly(std::vector&lt;std::vector&lt;Z&gt;&gt; a) {
  int n = a.size();
  for (int j = 0; j &lt; n - 2; j++) {
    for (int i = j + 1; i &lt; n; i++) {
      if (!a[i][j]) continue;
      std::swap(a[i], a[j + 1]);
      for (int k = 0; k &lt; n; k++) {
        std::swap(a[k][i], a[k][j + 1]);
      }
      break;
    }
    if (a[j + 1][j]) {
      auto inv = a[j + 1][j].inv();
      for (int i = j + 2; i &lt; n; i++) {
        auto c = a[i][j] * inv;
        for (int k = 0; k &lt; n; k++) a[i][k] -= a[j + 1][k] * c;
        for (int k = 0; k &lt; n; k++) a[k][j + 1] += a[k][i] * c;
      }
    }
  }
  std::vector&lt;std::vector&lt;Z&gt;&gt; h(n + 1);
  h[0] = {1};
  for (int i = 0; i &lt; n; i++) {
    Z prod = 1;
    h[i + 1].resize(h[i].size() + 1);
    for (int j = 0; j &lt; h[i].size(); j++) {
      h[i + 1][j + 1] = h[i][j];
      h[i + 1][j] -= h[i][j] * a[i][i];
    }
    for (int j = 0; j &lt; i; j++) {
      prod *= a[i - j][i - j - 1];
      auto c = a[i - j - 1][i] * prod;
      for (int k = 0; k &lt; h[i - j - 1].size(); k++) {
        h[i + 1][k] -= h[i - j - 1][k] * c;
      }
    }
  }
  return h[n];
}
```

- https://blog.asukakyle.top/post/%E7%89%B9%E5%BE%81%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%B0%8F%E8%AE%B0/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Fast Walsh–Hadamard Transform</title>
        <link>https://blog.asukakyle.top/post/fwt/</link>
        <pubDate>Sun, 08 Aug 2021 12:55:13 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/fwt/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/fwt/ -## 卷积
运算 $\odot$，序列 $a, b, c$，方阵 $P, Q, R$ 满足 $R$ 可逆，且
$$
\begin{cases}
c_n &amp;= \sum_{p \odot q = n}a_pb_q\\
\sum_j R_{i, j}c_j &amp;= \sum_pP_{i,p}a_p\sum_q Q_{i, q}b_q
\end{cases}
$$
所以
$$
\begin{aligned}
\sum_{j}R_{i, j}\sum_{p, q}[p\odot q = j]a_pb_q
&amp;= \sum_{p, q}P_{i, p}Q_{i, q}a_pb_q\\
\sum_{p, q}R_{i, p \odot q}a_pb_q &amp;= \sum_{p, q}P_{i, p}Q_{i, q}a_pb_q\\
R_{i, p\odot q} &amp;= P_{i, p}Q_{i, q}
\end{aligned}
$$

对序列 $a$ 施加线性变换 $P$，序列 $b$ 施加线性变换 $Q$，点乘之后再施加逆变换 $R^{-1}$，就可以实现 $\odot$ 卷积。

对于满足交换律的运算 $\odot$，$P = Q$。

## [Kronecker product](https://en.wikipedia.org/wiki/Kronecker_product)
设 $\mathbf {A}$ 是 $m \times n$ 矩阵，$\mathbf {B}$ 是 $p \times q$，定义 $\mathbf {A}$ 和 $\mathbf {B}$ 的 `Kronecker product` 为
$$
{\displaystyle \mathbf {A} \otimes \mathbf {B} ={\begin{bmatrix}a_{11}\mathbf {B} &amp;\cdots &amp;a_{1n}\mathbf {B} \\\vdots &amp;\ddots &amp;\vdots \\a_{m1}\mathbf {B} &amp;\cdots &amp;a_{mn}\mathbf {B} \end{bmatrix}}}
$$
更明确地
$$
{\mathbf{A}\otimes\mathbf{B}} = \begin{bmatrix}    a_{11} b_{11} &amp; a_{11} b_{12} &amp; \cdots &amp; a_{11} b_{1q} &amp;                    \cdots &amp; \cdots &amp; a_{1n} b_{11} &amp; a_{1n} b_{12} &amp; \cdots &amp; a_{1n} b_{1q} \\    a_{11} b_{21} &amp; a_{11} b_{22} &amp; \cdots &amp; a_{11} b_{2q} &amp;                    \cdots &amp; \cdots &amp; a_{1n} b_{21} &amp; a_{1n} b_{22} &amp; \cdots &amp; a_{1n} b_{2q} \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{11} b_{p1} &amp; a_{11} b_{p2} &amp; \cdots &amp; a_{11} b_{pq} &amp;                    \cdots &amp; \cdots &amp; a_{1n} b_{p1} &amp; a_{1n} b_{p2} &amp; \cdots &amp; a_{1n} b_{pq} \\    \vdots &amp; \vdots &amp; &amp; \vdots &amp; \ddots &amp; &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\    \vdots &amp; \vdots &amp; &amp; \vdots &amp; &amp; \ddots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\    a_{m1} b_{11} &amp; a_{m1} b_{12} &amp; \cdots &amp; a_{m1} b_{1q} &amp;                    \cdots &amp; \cdots &amp; a_{mn} b_{11} &amp; a_{mn} b_{12} &amp; \cdots &amp; a_{mn} b_{1q} \\    a_{m1} b_{21} &amp; a_{m1} b_{22} &amp; \cdots &amp; a_{m1} b_{2q} &amp;                    \cdots &amp; \cdots &amp; a_{mn} b_{21} &amp; a_{mn} b_{22} &amp; \cdots &amp; a_{mn} b_{2q} \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; &amp; &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    a_{m1} b_{p1} &amp; a_{m1} b_{p2} &amp; \cdots &amp; a_{m1} b_{pq} &amp;                    \cdots &amp; \cdots &amp; a_{mn} b_{p1} &amp; a_{mn} b_{p2} &amp; \cdots &amp; a_{mn} b_{pq} \end{bmatrix}
$$


### 性质
1. $(\mathbf{A} \otimes \mathbf{B})(\mathbf{C} \otimes \mathbf{D}) = (\mathbf{AC}) \otimes (\mathbf{BD})$

2. $(\mathbf{A} \otimes \mathbf{B})^{-1} = \mathbf{A}^{-1} \otimes \mathbf{B}^{-1}$

## 位运算卷积
位运算的每一位都是独立的，考虑按位构造变换矩阵。

假设存在 2 阶方阵 $P_2, Q_2, R_2$，其中 $R_2$ 可逆，满足 $R_{i, p\odot q} = P_{i, p}Q_{i, q}$。

令 $2^k$ 阶方阵
$$
\begin{aligned}
P_{2^k} &amp;= P_2 \otimes P_2 \otimes \dots \otimes P_2 = P_2^{\otimes k}\\
Q_{2^k} &amp;= Q_2 \otimes Q_2 \otimes \dots \otimes Q_2 = Q_2^{\otimes k}\\
R_{2^k} &amp;= R_2 \otimes R_2 \otimes \dots \otimes R_2 = R_2^{\otimes k}
\end{aligned}
$$

设 $i, j$​ 的二进制表示为 $i_{k-1}\dots i_1i_0$ 和 $j_{k-1}\dots j_1j_0$。

上面式子的含义为
$$
P_{i, j} = \prod_{l=0}^{k-1}P_{i_l, j_l}\quad
Q_{i, j} = \prod_{l=0}^{k-1}Q_{i_l, j_l}\quad
R_{i, j} = \prod_{l=0}^{k-1}R_{i_l, j_l}
$$
容易验证此时 $P_{2^k}, Q_{2^k}, R_{2^k}$ 仍然满足$R_{2^k}$ 可逆且 $R_{i, p\odot q} = P_{i, p}Q_{i, q}$。

### 快速计算 $H_{2^k}\mathbf \alpha$​ 

根据分块矩阵相乘
$$
H_{2n}\mathbf{\alpha}_{2n} =
(H_{2}\otimes H_n)\mathbf{\alpha}_{2n}
=
\begin{bmatrix}
H_{0, 0}H_{n} &amp; H_{0, 1}H_{n}\\
H_{1, 0}H_{n} &amp; H_{1, 1}H_{n}
\end{bmatrix}
\begin{bmatrix}
\mathbf{\alpha}_n\\
\mathbf{\alpha}&#39;_{n}
\end{bmatrix}
=
\begin{bmatrix}
H_{0, 0}H_{n}\mathbf{\alpha}_n + H_{0, 1}H_{n}\mathbf{\alpha}&#39;_n\\
H_{1, 0}H_{n}\mathbf{\alpha}_n + H_{1, 1}H_{n}\mathbf{\alpha}&#39;_n
\end{bmatrix}
$$

分治计算 $H_n\mathbf{\alpha}_n$ 和 $H_n\mathbf{\alpha}&#39;_n$ ，复杂度 $O(k2^k)$。

### Or
容易构造出 $P = Q = R = \begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}$​ 或 $\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}$​。

其中 $\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}$​​​ 有特殊含义 $R_{i, j} = [i \operatorname{and} j = j]$​​​​，使用该矩阵，$R^{-1} = \begin{bmatrix}1 &amp; 0\\-1 &amp; 1\end{bmatrix}$。​

### And
容易构造出 $P = Q = R = \begin{bmatrix}0&amp;1\\1&amp;1\end{bmatrix}$​​ 或 $\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}$​​。

其中 $\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}$​ 有特殊含义 $R_{i, j} = [i \operatorname{and} j = i]$​，使用该矩阵，$R^{-1} = \begin{bmatrix}1 &amp; -1\\0 &amp; 1\end{bmatrix}$​。

### Xor
容易构造出 $P = Q = R = \begin{bmatrix}1&amp;-1\\1&amp;1\end{bmatrix}$​​ 或 $\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}$​​。

其中 $\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}$ 有特殊含义 $R_{i, j} = (-1)^{\operatorname{popcnt}(i \operatorname{and} j)}$，使用该矩阵，$R^{-1} = \begin{bmatrix}\frac12 &amp; \frac12\\\frac12 &amp; -\frac12\end{bmatrix}$​。

三个变换矩阵相同，因此记为 $H$。

注意到对于异或卷积 $H^{-1} = \frac12 H$，那么 $H_{2^k}^{-1} = \dfrac{1}{2^k}H_{2^k}$，所以逆变换相当于正变换后每一项除以 $n$，与离散傅里叶变换类似。

## 子集卷积

$$
c_n = \sum\limits_{p, q}[p \operatorname{or} q = n][p \operatorname{and} q = 0] a_pb_q
$$

将限制条件转化为 $[p \operatorname{or} q = n][\operatorname{popcnt}(p) + \operatorname{popcnt}(q) = \operatorname{popcnt}(n)]$​​​。

利用占位多项式
$$
\begin{aligned}
A_n(x) &amp;= a_nx^{\operatorname{popcnt}(n)}\\
B_n(x) &amp;= b_nx^{\operatorname{popcnt}(n)}\\
C_n(x) &amp;= \sum\limits_{p \operatorname{or} q = n}A_p(x)B_q(x)\\
c_n &amp;= [x^{\operatorname{popcnt}(n)}]C_n(x)
\end{aligned}
$$
也可以交换两个维度，定义两个向量的或卷积为
$$
(\mathbf A \operatorname {or} \mathbf B)_n = \sum\limits_{p \operatorname{or} q = n} a_pb_q
$$
则
$$
\begin{aligned}
\mathbf{A}_n &amp;= ([\operatorname{popcnt}(0) = n]a_0, [\operatorname{popcnt}(1) = n]a_1, \dots)\\
\mathbf{B}_n &amp;= ([\operatorname{popcnt}(0) = n]b_0, [\operatorname{popcnt}(1) = n]b_1, \dots)\\
\mathbf{C}_n &amp;= \mathbf A_n \operatorname {or} \mathbf B_n
\end{aligned}
$$


## 广义位运算卷积

将位运算从二进制推广到 $m$ 进制。

类似二进制的情形，假设存在 m 阶方阵 $P_m, Q_m, R_m$，其中 $R_m$ 可逆，满足 $R_{i, p\odot q} = P_{i, p}Q_{i, q}$。

令 $m^k$ 阶方阵，
$$
\begin{aligned}
P_{m^k} &amp;= P_m \otimes P_m \otimes \dots \otimes P_m = P_m^{\otimes k}\\
Q_{m^k} &amp;= Q_m \otimes Q_m \otimes \dots \otimes Q_m = Q_m^{\otimes k}\\
R_{m^k} &amp;= R_m \otimes R_m \otimes \dots \otimes R_m = R_m^{\otimes k}
\end{aligned}
$$

设 $i, j$​ 的 $m$​ 进制表示为 $i_{k-1}\dots i_1i_0$ 和 $j_{k-1}\dots j_1j_0$。

上面式子的含义为
$$
P_{i, j} = \prod_{l=0}^{k-1}P_{i_l, j_l}\quad
Q_{i, j} = \prod_{l=0}^{k-1}Q_{i_l, j_l}\quad
R_{i, j} = \prod_{l=0}^{k-1}R_{i_l, j_l}
$$

### Or

设 $i = i_{k-1}\dots i_1i_0, j = j_{k-1}\dots j_1j_0$​​ 其中 $i_l, j_l \in [0, m)$​​，定义 $m$​​ 进制下 $\mathrm{or}$​​​​ 运算为
$$
(i \operatorname{or} j)_l = \max(i_l, j_l)
$$

一种构造是形如 $\begin{bmatrix}1&amp;0&amp;0&amp;0\\1&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\1&amp;1&amp;1&amp;1\end{bmatrix}$​ 的下三角矩阵，含义是 $H_{i, j} = [i \geq j]$​，$H^{-1} = \begin{bmatrix}1&amp;0&amp;0&amp;0\\-1&amp;1&amp;0&amp;0\\0&amp;-1&amp;1&amp;0\\0&amp;0&amp;-1&amp;1\end{bmatrix}$​。



### And

设 $i = i_{k-1}\dots i_1i_0, j = j_{k-1}\dots j_1j_0$​​​ 其中 $i_l, j_l \in [0, m)$​​​，定义 $m$​​​ 进制下 $\mathrm{and}$​​​​​ 运算为
$$
(i \operatorname{and} j)_l = \min(i_l, j_l)
$$

一种构造是形如 $\begin{bmatrix}1&amp;1&amp;1&amp;1\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;1\end{bmatrix}$​​ 的上三角矩阵，含义是 $H_{i, j} = [i \leq j]$​​，$H^{-1}=\begin{bmatrix}1&amp;-1&amp;0&amp;0\\0&amp;1&amp;-1&amp;0\\0&amp;0&amp;1&amp;-1\\0&amp;0&amp;0&amp;1\end{bmatrix}$​​。

### Xor

设 $i = i_{k-1}\dots i_1i_0, j = j_{k-1}\dots j_1j_0$​​ 其中 $i_l, j_l \in [0, m)$​​，定义 $m$​​ 进制下 $\mathrm{xor}$​​​​ 运算为
$$
(i \operatorname{xor} j)_l = (i_l + j_l) \bmod m
$$
发现这个就是循环卷积，于是可以把傅里叶变换的范德蒙矩阵拿过来。
$$
H=
\begin{bmatrix}1&amp; 1 &amp; 1&amp; \cdots &amp; 1\\
1&amp; \omega_m^1&amp; \omega_m^2&amp; \cdots &amp; \omega_m^{m - 1}\\
1&amp; \omega_m^2 &amp; \omega_m^4&amp; \cdots &amp; \omega_m^{2(m - 1)}\\
\vdots &amp; \vdots&amp; \vdots&amp; \ddots&amp; \vdots\\
1&amp; \omega_m^{m - 1}&amp;\omega_m^{2(m - 1)} &amp; \cdots &amp; \omega_m^{(m - 1)(m - 1)}
\end{bmatrix}
$$
它的逆为：
$$
H^{-1}=\dfrac{1}{m}\begin{bmatrix}1&amp; 1 &amp; 1&amp; \cdots &amp; 1\\ 1&amp; \omega_m^{-1}&amp; \omega_m^{-2}&amp; \cdots &amp;
\omega_m^{-(m - 1)}\\ 1&amp; \omega_m^{-2} &amp; \omega_m^{-4}&amp; \cdots &amp; \omega_m^{-2(m - 1)}\\ \vdots&amp; \vdots&amp; \vdots&amp;\ddots&amp; \vdots\\ 1&amp; \omega_m^{-(m - 1)}&amp; \omega_m^{-2(m - 1)} &amp; \cdots &amp; \omega_m^{-(m - 1)(m -
1)}\end{bmatrix}
$$

对于 $\omega_m$ 不存在的情形，需要扩域：

&gt; **分圆多项式**
&gt; 
&gt; $$
&gt; \Phi_n(x) = \prod\limits_{i = 0}^{n - 1}(x - \omega_n^i)^{[i \perp n]}
&gt; $$
&gt; 易证
&gt; $$
&gt; \prod\limits_{d \mid n}\Phi_d(x) = x^n - 1
&gt; $$
&gt; 莫比乌斯反演可得
&gt; $$
&gt; \Phi_n(x) = \prod\limits_{d \mid n}(x^d - 1)^{\mu(n / d)}
&gt; $$ 
&gt; 
&gt; **定理**：
&gt; 1. 分圆多项式在 $Q$ 上不可约。
&gt; 2. 在模 $\Phi_n(x)$ 意义下，$x$ 的阶恰好为 $k$。

所以可以用 $x$ 代替 $\omega_m$，运算在模 $\Phi_m(x)$ 意义下进行。

如果 $\Phi_m(x)$ 比较简单，可以直接模 $\Phi_m(x)$，否则，由于 $\Phi_m(x) \mid (x^m - 1)$ 所以可以先在模 $x^m - 1$ 意义下运算，即做长度为 $m$ 的循环卷积，最后再模 $\Phi_m(x)$。

模板题：[CodeForces 1103E](https://codeforces.com/problemset/problem/1103/E)
```cpp
// Author:  HolyK
// Created: Sun Aug  8 21:08:34 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

using u64 = uint64_t;
using Poly = std::array&lt;u64, 4&gt;;
Poly operator*(Poly a, Poly b) {
  static u64 c[7];
  memset(c, 0, sizeof c);
  for (int i = 0; i &lt; 4; i++) {
    for (int j = 0; j &lt; 4; j++) {
      c[i + j] += a[i] * b[j];
    }
  }
  return {c[0] - c[4] - c[5], c[1] + c[4] - c[6], c[2] - c[4], c[3] + c[4]};
}
Poly &amp;operator+=(Poly &amp;a, Poly b) {
  for (int i = 0; i &lt; 4; i++) {
    a[i] += b[i];
  }
  return a;
}
Poly &amp;operator-=(Poly &amp;a, Poly b) {
  for (int i = 0; i &lt; 4; i++) {
    a[i] -= b[i];
  }
  return a;
}
Poly operator+(Poly a, Poly b) {
  return a += b;
}
Poly operator-(Poly a, Poly b) {
  return a -= b;
}
constexpr Poly w[] = {
  Poly({1ULL, 0ULL, 0ULL, 0ULL}),
  Poly({0ULL, 1ULL, 0ULL, 0ULL}),
  Poly({0ULL, 0ULL, 1ULL, 0ULL}),
  Poly({0ULL, 0ULL, 0ULL, 1ULL}),
  Poly({~0ULL, 1ULL, ~0ULL, 1ULL}),
  Poly({~0ULL, 0ULL, 0ULL, 0ULL}),
  Poly({0ULL, ~0ULL, 0ULL, 0ULL}),
  Poly({0ULL, 0ULL, ~0ULL, 0ULL}),
  Poly({0ULL, 0ULL, 0ULL, ~0ULL}),
  Poly({1ULL, ~0ULL, 1ULL, ~0ULL})
};
constexpr int N(100000), M(10);
void fwt(Poly *a, int f) {
  for (int i = 1; i &lt; N; i *= M) {
    for (int j = 0; j &lt; N; j += i * M) {
      for (int k = 0; k &lt; i; k++) {
        static Poly t[M];
        for (int p = 0; p &lt; M; p++) {
          t[p].fill(0);
          for (int q = 0; q &lt; M; q++) {
            t[p] += a[i * q + j + k] * w[(M + p * f) * q % M];
          }
        }
        for (int p = 0; p &lt; M; p++) {
          a[i * p + j + k] = t[p];
        }
      }
    }
  }
}
Poly fpow(Poly x, int k) {
  Poly r;
  r.fill(0);
  r[0] = 1;
  for (; k; k &gt;&gt;= 1, x = x * x) {
    if (k &amp; 1) r = r * x;
  }
  return r;
}
Poly a[N];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  std::cin &gt;&gt; n;
  for (int i = 0; i &lt; n; i++) {
    int x;
    std::cin &gt;&gt; x;
    a[x][0]++;
  }
  fwt(a, 1);
  for (int i = 0; i &lt; N; i++) {
    a[i] = fpow(a[i], n);
  }
  fwt(a, -1);
  for (int i = 0; i &lt; n; i++) {
    assert(a[i][1] == 0 &amp;&amp; a[i][2] == 0 &amp;&amp; a[i][3] == 0);
    // std::cout &lt;&lt; a[i][0] &lt;&lt; &#34;\n&#34;;
    std::cout &lt;&lt; (a[i][0] &gt;&gt; 5) * 94170628496287261ULL % (1ULL &lt;&lt; 58) &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```
&lt;!-- 对于 $\omega_m$ 不存在的情形，需要使用 `Bluestein&#39;s Algorithm`。 --&gt;

- https://blog.asukakyle.top/post/fwt/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021牛客多校7</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder7/</link>
        <pubDate>Sat, 07 Aug 2021 19:38:21 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder7/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder7/ -| 题号 |                             标题                             | 团队的状态 |
| :--: | :----------------------------------------------------------: | :--------: |
|  A   | [xay loves connected graphs](https://ac.nowcoder.com/acm/contest/11258/A) |   通过   |
|  B   | [xay loves monotonicity](https://ac.nowcoder.com/acm/contest/11258/B) |   通过   |
|  C   | [xay loves jumping](https://ac.nowcoder.com/acm/contest/11258/C) |   未通过   |
|  D   | [xay loves matrices](https://ac.nowcoder.com/acm/contest/11258/D) |   通过   |
|  E   | [xay loves nim](https://ac.nowcoder.com/acm/contest/11258/E) |   通过   |
|  F   | [xay loves trees](https://ac.nowcoder.com/acm/contest/11258/F) |    通过    |
|  G   | [xay loves KDT](https://ac.nowcoder.com/acm/contest/11258/G) |   未通过   |
|  H   | [xay loves count](https://ac.nowcoder.com/acm/contest/11258/H) |    通过    |
|  I   | [xay loves or](https://ac.nowcoder.com/acm/contest/11258/I)  |    通过    |
|  J   | [xay loves Floyd](https://ac.nowcoder.com/acm/contest/11258/J) |   通过   |
|  K   | [xay loves sequence](https://ac.nowcoder.com/acm/contest/11258/K) |    通过    |


## [xay loves connected graphs](https://ac.nowcoder.com/acm/contest/11258/A)
```cpp
// Author:  HolyK
// Created: Sun Aug  8 18:17:17 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline int mod(LL x) {
  return x % P;
}
inline int reduce(int x) {
  return x &gt;= P ? x - P : x;
}
inline int norm(int x) {
  return x &lt; 0 ? x + P : x;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
using Info = std::array&lt;int, 2&gt;;
Info &amp;operator+=(Info &amp;a, Info b) {
  inc(a[0], b[0]);
  inc(a[1], b[1]);
  return a;
}
Info &amp;operator-=(Info &amp;a, Info b) {
  inc(a[0], P - b[0]);
  inc(a[1], P - b[1]);
  return a;
}
Info operator+(Info a, Info b) {
  return a += b;
}
Info operator-(Info a, Info b) {
  return a -= b;
}
Info operator*(Info a, Info b) {
  return {mod(1LL * a[0] * b[0]), mod(1LL * a[0] * b[1] + 1LL * a[1] * b[0])};
}
Info operator*(Info a, LL b) {
  return {mod(a[0] * b), mod(a[1] * b)};
}
using Poly = std::array&lt;Info, 21&gt;;
constexpr int N(1 &lt;&lt; 20);
int n, len, cnt[N];
void fwt(Poly *a) {
  for (int i = 1; i &lt; len; i &lt;&lt;= 1) {
    for (int j = 0; j &lt; len; j += i * 2) {
      for (int k = 0; k &lt; i; k++) {
        for (int p = 0; p &lt;= n; p++) {
          a[i + j + k][p] += a[j + k][p];
        }
      }
    }
  }
}
void ifwt(Poly *a) {
  for (int i = 1; i &lt; len; i &lt;&lt;= 1) {
    for (int j = 0; j &lt; len; j += i * 2) {
      for (int k = 0; k &lt; i; k++) {
        for (int p = 0; p &lt;= n; p++) {
          a[i + j + k][p] -= a[j + k][p];
        }
      }
    }
  }
}
const auto Inv = [] {
  std::array&lt;int, 21&gt; c;
  c[0] = c[1] = 1;
  for (int i = 2; i &lt; 21; i++) {
    c[i] = 1LL * (P - P / i) * c[P % i] % P;
  }
  return c;
}();
Poly ln(Poly a) {
  Poly b;
  for (int i = 0; i &lt; n; i++) b[i] = a[i + 1] * (i + 1);
  for (int i = 1; i &lt; n; i++) {
    for (int j = 1; j &lt;= i; j++) {
      b[i] = b[i] - a[j] * b[i - j];
    }
  }
  for (int i = n; i; i--) {
    b[i] = b[i - 1] * Inv[i];
  }
  b[0].fill(0);
  return b;
}
Poly f[N];
Info a[N];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n;
  len = 1 &lt;&lt; n;
  for (int i = 1; i &lt; len; i++) {
    cnt[i] = 1 + cnt[i &amp; i - 1];
  }
  for (int i = 0; i &lt; len; i++) {
    a[i] = {1, 0};
  }
  for (int i = 0; i &lt; n - 1; i++) {
    for (int j = i + 1; j &lt; n; j++) {
      int x;
      std::cin &gt;&gt; x;
      a[1 &lt;&lt; i | 1 &lt;&lt; j] = {x + 1, x};
    }
  }
  for (int i = 1; i &lt; len; i &lt;&lt;= 1) {
    for (int j = 0; j &lt; len; j += i * 2) {
      for (int k = 0; k &lt; i; k++) {
        a[i + j + k] = a[j + k] * a[i + j + k];
      }
    }
  }
  for (int i = 0; i &lt; len; i++) f[i][cnt[i]] = a[i];
  fwt(f);
  for (int i = 0; i &lt; len; i++) {
    f[i] = ln(f[i]);
  }
  // ifwt(f);
  // std::cout &lt;&lt; f[len - 1][n][1] &lt;&lt; &#34;\n&#34;;
  int ans = 0;
  for (int i = 0; i &lt; len; i++) {
    if (cnt[i] &amp; 1) {
      inc(ans, P - f[i][n][1]);
    } else {
      inc(ans, f[i][n][1]);
    }
  }
  if (n &amp; 1) ans = P - ans;
  std::cout &lt;&lt; ans % P &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## [xay loves monotonicity](https://ac.nowcoder.com/acm/contest/11258/B)
### 线段树
```cpp
// Author:  HolyK
// Created: Sat Aug  7 20:25:17 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2e5 + 5);
int n, c[N], a[N];
void add(int p) {
  for (; p &lt;= n; p += p &amp; -p) c[p] ^= 1;
}
void add(int l, int r) {
  add(l), add(r + 1);
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) r ^= c[p];
  return r;
}

#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
int pos[N &lt;&lt; 2], cnt[N &lt;&lt; 2];

int ask(int o, int l, int r, int x) {
  if (a[x] &gt; a[pos[o]]) return 0;
  int ans = 0;
  while (l &lt; r) {
    int m = l + r &gt;&gt; 1;
    if (a[pos[ls]] &gt;= a[x]) {
      ans += cnt[o] - cnt[ls];
      o = ls;
      r = m;
    } else {
      o = rs;
      l = m + 1;
    }
  }
  assert(a[l] &gt;= a[x]);
  return ans += ask(x) ^ ask(l);
}
void build(int o, int l, int r) {
  if (l == r) {
    pos[o] = l;
    cnt[o] = 0;
    return;
  }
  int m = l + r &gt;&gt; 1;
  build(ls, l, m), build(rs, m + 1, r);
  pos[o] = a[pos[ls]] &gt; a[pos[rs]] ? pos[ls] : pos[rs];
  cnt[o] = cnt[ls] + ask(rs, m + 1, r, pos[ls]);
}
void update(int o, int l, int r, int x) {
  if (l == r) return;
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? update(ls, l, m, x) : update(rs, m + 1, r, x);
  pos[o] = a[pos[ls]] &gt; a[pos[rs]] ? pos[ls] : pos[rs];
  cnt[o] = cnt[ls] + ask(rs, m + 1, r, pos[ls]);
}

int p, s;
void solve(int o, int l, int r, int x, int y) {
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    if (!p) {
      p = pos[o];
      s = cnt[o];
    } else if (a[pos[o]] &gt;= a[p]) {
      s += ask(o, l, r, p), p = pos[o];
    }
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) solve(ls, l, m, x, y);
  if (y &gt; m) solve(rs, m + 1, r, x, y);
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
  }
  for (int i = 1; i &lt;= n; i++) {
    int x;
    std::cin &gt;&gt; x;
    if (x) add(i, i);
  }
  build(1, 1, n);
  int q;
  std::cin &gt;&gt; q;
  while (q--) {
    int opt, x, y;
    std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    if (opt == 1) {
      a[x] = y;
      update(1, 1, n, x);
    } else if (opt == 2) {
      add(x, y);
      update(1, 1, n, x);
      update(1, 1, n, y);
    } else {
      p = s = 0;
      solve(1, 1, n, x, y);
      std::cout &lt;&lt; s &lt;&lt; &#34;\n&#34;;
    }
      
  }
  return 0;
}

```
### 分块
```cpp
// Author:  HolyK
// Created: Sun Aug  8 09:01:25 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2e5 + 5), T(768);
int n, a[N], b[N], c[N], d[N], f[N], t[N];
std::vector&lt;int&gt; s[N / T + 5];
void build(int x) {
  auto &amp;q = s[x];
  q.clear();
  int l = x * T, r = std::min(n, l + T);
  for (int i = r - 1; i &gt;= l; i--) {
    while (!q.empty() &amp;&amp; a[q.back()] &lt; a[i]) q.pop_back();
    if (q.empty()) {
      f[i] = t[i] = i;
      d[i] = 0;
    } else {
      f[i] = q.back();
      t[i] = t[f[i]];
      d[i] = d[f[i]] + (b[i] ^ b[f[i]]);
    }
    q.push_back(i);
  }
  std::reverse(q.begin(), q.end());
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i];
  }
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; b[i];
  }
  int tot = (n - 1) / T + 1;
  for (int i = 0; i &lt; tot; i++) {
    build(i);
  }
  int q;
  std::cin &gt;&gt; q;
  while (q--) {
    int opt, x, y;
    std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    if (opt == 1) {
      a[--x] = y;
      build(x / T);
    } else if (opt == 2) {
      x--, y--;
      int bx = x / T, by = y / T;
      if (bx == by) {
        for (int i = x; i &lt;= y; i++) b[i] ^= 1;
        build(bx);
      } else {
        for (int i = x; i &lt; bx * T + T; i++) b[i] ^= 1;
        for (int i = by * T; i &lt;= y; i++) b[i] ^= 1;
        build(bx), build(by);
        for (int i = bx + 1; i &lt; by; i++) c[i] ^= 1;
      }
    } else {
      x--, y--;
      int ans = 0;
      while (x &lt;= y) {
        if (x == t[x]) {
          int to = y + 1;
          for (int i = x / T + 1; i &lt; tot; i++) {
            if (a[s[i].back()] &lt; a[x]) continue;
            to = *std::lower_bound(s[i].begin(), s[i].end(), x, [&amp;](int i, int j) {
              return a[i] &lt; a[j];
            });
            if (to &lt;= y) {
              ans += b[x] ^ b[to] ^ c[x / T] ^ c[i];
            }
            break;
          }
          x = to;
        } else if (t[x] &lt;= y) {
          ans += d[x];
          x = t[x];
        } else if (f[x] &lt;= y) {
          ans += b[x] ^ b[f[x]];
          x = f[x];
        } else {
          break;
        }
      }
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    }
  }
  return 0;
}
```

## [xay loves jumping](https://ac.nowcoder.com/acm/contest/11258/C)

## [xay loves matrices](https://ac.nowcoder.com/acm/contest/11258/D)
```cpp
// Author:  HolyK
// Created: Sat Aug 14 10:09:34 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z pow(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};
// det(xI + A)
std::vector&lt;Z&gt; charPoly(std::vector&lt;std::vector&lt;Z&gt;&gt; a) {
  int n = a.size();
  for (int j = 0; j &lt; n - 2; j++) {
    for (int i = j + 1; i &lt; n; i++) {
      if (!a[i][j]) continue;
      std::swap(a[i], a[j + 1]);
      for (int k = 0; k &lt; n; k++) {
        std::swap(a[k][i], a[k][j + 1]);
      }
      break;
    }
    if (a[j + 1][j]) {
      auto inv = a[j + 1][j].inv();
      for (int i = j + 2; i &lt; n; i++) {
        auto c = a[i][j] * inv;
        for (int k = 0; k &lt; n; k++) a[i][k] -= a[j + 1][k] * c;
        for (int k = 0; k &lt; n; k++) a[k][j + 1] += a[k][i] * c;
      }
    }
  }
  std::vector&lt;std::vector&lt;Z&gt;&gt; h(n + 1);
  h[0] = {1};
  for (int i = 0; i &lt; n; i++) {
    Z prod = 1;
    h[i + 1].resize(h[i].size() + 1);
    for (int j = 0; j &lt; h[i].size(); j++) {
      h[i + 1][j + 1] = h[i][j];
      h[i + 1][j] += h[i][j] * a[i][i];
    }
    for (int j = 0; j &lt; i; j++) {
      prod *= -a[i - j][i - j - 1];
      auto c = a[i - j - 1][i] * prod;
      for (int k = 0; k &lt; h[i - j - 1].size(); k++) {
        h[i + 1][k] += h[i - j - 1][k] * c;
      }
    }
  }
  return h[n];
}

int main() {
  // freopen(&#34;24.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, d;
  std::cin &gt;&gt; n &gt;&gt; d;
  d++;
  std::vector m(d, std::vector(n, std::vector&lt;Z&gt;(n)));
  for (int i = 0; i &lt; d; i++) {
    for (int j = 0; j &lt; n; j++) {
      for (int k = 0; k &lt; n; k++) {
        std::cin &gt;&gt; m[i][j][k].x;
      }
    }
  }
  
  auto row = [&amp;](int x, int y, Z z) {
    for (int i = 0; i &lt; d; i++) {
      for (int j = 0; j &lt; n; j++) {
        m[i][y][j] += m[i][x][j] * z;
      }
    }
  };
  auto col = [&amp;](int x, int y, Z z) {
    for (int i = 0; i &lt; d; i++) {
      for (int j = 0; j &lt; n; j++) {
        m[i][j][y] += m[i][j][x] * z;
      }
    }
  };
  int cnt = 0;
  Z prod = 1;
  auto &amp;h = m[d - 1];
  for (int i = 0, j; i &lt; n; i++) {
    while (!h[i][i]) {
      for (j = i; j &lt; n; j++) {
        if (!h[j][i]) continue;
        if (i != j) {
          prod *= -1;
          for (int k = 0; k &lt; d; k++) {
            std::swap(m[k][i], m[k][j]);
          }
        }
        break;
      }
      if (j &lt; n) break;
      if (++cnt &gt; n * (d - 1)) {
        for (int i = 0; i &lt;= n * (d - 1); i++) {
          std::cout &lt;&lt; &#34;0&#34; &lt;&lt; &#34; \n&#34;[i == n * (d - 1)];
        }
        return 0;
      }
      for (j = i - 1; j &gt;= 0; j--) {
        if (!h[j][i]) continue;
        col(j, i, -h[j][i] / h[j][j]);
      }
      for (int k = d - 1; k &gt; 0; k--) {
        for (j = 0; j &lt; n; j++) {
          m[k][j][i] = m[k - 1][j][i];
        }
      }
      for (int j = 0; j &lt; n; j++) {
        m[0][j][i] = 0;
      }
    }
    prod *= h[i][i];
    Z inv = h[i][i].inv();
    for (int k = 0; k &lt; d; k++) {
      for (j = 0; j &lt; n; j++) {
        m[k][i][j] *= inv;
      }
    }
    for (j = 0; j &lt; n; j++) {
      if (j == i || !h[j][i]) continue;
      row(i, j, -h[j][i]);
    }
  }
  auto out = [&amp;](auto a) {
    for (int i = 0; i &lt; a.size(); i++) {
      for (int j = 0; j &lt; a[i].size(); j++) {
        std::cerr &lt;&lt; a[i][j] &lt;&lt; &#34; \n&#34;[j + 1 == a[i].size()];
      }
    }
  };
  
  // out(h);
  // out(m[0]);
  d--;
  std::vector a(n * d, std::vector&lt;Z&gt;(n * d));
  for (int i = 0; i &lt; d; i++) {
    for (int j = 0; j &lt; n; j++) {
      for (int k = 0; k &lt; n; k++) {
        a[n * (d - 1) + j][n * i + k] = m[i][j][k];
      }
    }
  }
  for (int i = n; i &lt; n * d; i++) {
    a[i - n][i] = -1;
  }
  // out(a);
  auto f = charPoly(a);
  for (auto &amp;x : f) x *= prod;
  std::vector&lt;int&gt; g(n * d + 1);
  for (int i = cnt; i &lt; f.size(); i++) g[i - cnt] = f[i];
  for (int i = 0; i &lt;= n * d; i++) {
    std::cout &lt;&lt; g[i] &lt;&lt; &#34; \n&#34;[i == n * d];
  }
  return 0;
}
```

## [xay loves nim](https://ac.nowcoder.com/acm/contest/11258/E)

## [xay loves trees](https://ac.nowcoder.com/acm/contest/11258/F) 
```cpp
// Author:  HolyK
// Created: Sat Aug  7 12:43:24 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(6e5 + 5);
int n, m, in[N], out[N], cnt;
std::vector&lt;int&gt; g[N], h[N];
std::vector&lt;std::pair&lt;int*, int&gt;&gt; rec;
int max[N &lt;&lt; 2], tag[N &lt;&lt; 2];
void record(int &amp;x) {
  rec.emplace_back(&amp;x, x);
}
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
// void pushup(int o) {
//   record(max[o]);
//   max[o] = std::max({max[ls], max[rs], tag[o]});
// }
void update(int o, int l, int r, int x, int y, int z) {
  record(max[o]);
  max[o] = z;
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    record(tag[o]);
    tag[o] = z;
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt; m) update(ls, l, m, x, y, z);
  if (y &gt; m) update(rs, m, r, x, y, z);
}
int ask(int o, int l, int r, int x, int y) {
  if (r &lt;= x || y &lt;= l) return 0;
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    return max[o];
  }
  int m = l + r &gt;&gt; 1;
  return std::max({ask(ls, l, m, x, y), ask(rs, m, r, x, y), tag[o]});
}
void dfs2(int x, int p) {
  in[x] = cnt++;
  for (int y : h[x]) {
    if (y == p) continue;
    dfs2(y, x);
  }
  out[x] = cnt;
}
int s[N], top, m2, ans;
int t[1 &lt;&lt; 21];
void up(int x) {
  for (int i = m2 + x &gt;&gt; 1; i; i &gt;&gt;= 1) {
    t[i] = std::max(t[i &lt;&lt; 1], t[i &lt;&lt; 1 | 1]);
  }
}
void dfs1(int x, int p) {
  s[++top] = x;
  t[top + m2] = ask(1, 0, n, in[x], out[x]), up(top);
  int l = 0, r = m2 * 2, rmax = 0;
  for (int o = 1; r - l &gt; 1; ) {
    int m = l + r &gt;&gt; 1;
    if (std::max(rmax, t[o &lt;&lt; 1 | 1]) &gt;= m) {
      o = o &lt;&lt; 1 | 1;
      l = m;
    } else {
      smax(rmax, t[o &lt;&lt; 1 | 1]);
      o = o &lt;&lt; 1;
      r = m;
    }
  }
  if (rmax &gt;= l) l++;
  // std::cerr &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; top - l + 1 &lt;&lt; &#34;\n&#34;;
  smax(ans, top - l + 1);
  int now = rec.size();
  update(1, 0, n, in[x], out[x], top);
  for (int y : g[x]) {
    if (y == p) continue;
    dfs1(y, x);
  }
  t[top + m2] = 0, up(top);
  top--;
  while (rec.size() &gt; now) {
    *rec.back().first = rec.back().second;
    rec.pop_back();
  }
}
void solve() {
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    g[i].clear();
    h[i].clear();
  }
  cnt = ans = 0;
  for (int i = 1, x, y; i &lt; n; i++) {
    std::cin &gt;&gt; x &gt;&gt; y;
    g[x].push_back(y);
    g[y].push_back(x);
  }
  for (int i = 1, x, y; i &lt; n; i++) {
    std::cin &gt;&gt; x &gt;&gt; y;
    h[x].push_back(y);
    h[y].push_back(x);
  }
  m = 1 &lt;&lt; std::__lg(n * 2 - 1);
  m2 = 1 &lt;&lt; std::__lg(n * 2 + 1);
  dfs2(1, 0);
  // std::cerr &lt;&lt; &#34;dfs2 end\n&#34;;
  dfs1(1, 0);
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}

```

## [xay loves KDT](https://ac.nowcoder.com/acm/contest/11258/G)

## [xay loves count](https://ac.nowcoder.com/acm/contest/11258/H) 
```cpp
// Author:  HolyK
// Created: Sat Aug  7 12:06:08 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int c[1000006];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n;
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) {
    int x;
    std::cin &gt;&gt; x;
    c[x]++;
  }
  n = 1e6;
  LL ans = 0;
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; i * j &lt;= n; j++) {
      int k = i * j;
      
      ans += 1LL * c[i] * c[j] * c[k];
      
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}

```

## [xay loves or](https://ac.nowcoder.com/acm/contest/11258/I)  
签到。

## [xay loves Floyd](https://ac.nowcoder.com/acm/contest/11258/J)

## [xay loves sequence](https://ac.nowcoder.com/acm/contest/11258/K) 
```cpp
// Author:  HolyK
// Created: Sat Aug  7 14:36:07 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2e5 + 5), K((1 &lt;&lt; 30) - 1);
int n, q, a[N], b[N];
void brute() {
  while (q--) {
    int l, r, k;
    std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
    std::vector&lt;int&gt; c {a[l]};
    for (int i = l + 1; i &lt;= r; i++) {
      c.push_back((b[i] + k) % k);
    }
    std::sort(c.begin(), c.end());
    std::vector&lt;LL&gt; pre(r - l + 1);
    for (int i = 0; i &lt; r - l + 1; i++) {
      pre[i] = c[i];
    }
    for (int i = 1; i &lt; r - l + 1; i++) {
      pre[i] += pre[i - 1];
    }
    LL ans = std::min(pre.back(), 1LL * (r - l + 1) * k - pre.back());
    // std::cerr &lt;&lt; pre.back() &lt;&lt; &#34; &#34;;
    for (int x = 0; x &lt; r - l + 1; x++) {
      // std::cerr &lt;&lt; std::max(pre[x], 1LL * (r - l - x) * k - pre.back() + pre[x]) &lt;&lt; &#34; \n&#34;[x == r - l];
      smin(ans, std::max(pre[x], 1LL * (r - l - x) * k - pre.back() + pre[x]));
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    // return;
  }
}
struct Node {
  int ls, rs, cnt;
  LL sum;
} t[N * 60];
int cur;
void ins(int &amp;o, int l, int r, int x, int y) {
  t[++cur] = t[o], o = cur;
  t[o].cnt++;
  t[o].sum += y;
  if (r - l == 1) return;
  int m = l + r &gt;&gt; 1;
  x &lt; m ? ins(t[o].ls, l, m, x, y) : ins(t[o].rs, m, r, x, y);
}
int cnt;
LL sum;
void ask(int p, int q, int l, int r, int x, int y) {
  // std::cerr &lt;&lt; &#34; ?? &#34; &lt;&lt; l &lt;&lt; &#34; &#34; &lt;&lt; r &lt;&lt; &#34; &#34; &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; &#34;\n&#34;;
  if (r &lt;= x || y &lt;= l || t[p].cnt - t[q].cnt == 0) return;
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    cnt += t[p].cnt - t[q].cnt;
    sum += t[p].sum - t[q].sum;
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt; m) ask(t[p].ls, t[q].ls, l, m, x, y);
  if (y &gt; m) ask(t[p].rs, t[q].rs, m, r, x, y);
}
int root[N][2];
LL negSum[N];
int negCnt[N];
std::vector&lt;int&gt; c[2];
signed main() {
  // freopen(&#34;k.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;k.out&#34;, &#34;w&#34;, stdout);
  double sta = (double)clock() / CLOCKS_PER_SEC;
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; q;
  for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i], b[i] = a[i];
  for (int i = n; i; i--) b[i] -= b[i - 1];

  for (int i = 2; i &lt;= n; i++) {
    negSum[i] = negSum[i - 1];
    negCnt[i] = negCnt[i - 1];
    if (b[i] &lt; 0) {
      negSum[i] += b[i], negCnt[i]++; 
    }
    c[b[i] &gt;= 0].push_back(b[i]);
  }
  for (auto &amp;v : c) {
    std::sort(v.begin(), v.end());
    v.resize(std::unique(v.begin(), v.end()) - v.begin());
  }
  auto lb = [&amp;](int i, int x) {
    int l = 0, r = c[i].size();
    while (l &lt; r) {
      int m = l + r &gt;&gt; 1;
      if (c[i][m] &lt; x) {
        l = m + 1;
      } else {
        r = m;
      }
    }
    return l;
  };
  for (int i = 2; i &lt;= n; i++) {
    root[i][0] = root[i - 1][0];
    root[i][1] = root[i - 1][1];
    int k = b[i] &gt;= 0;
    ins(root[i][k], 0, c[k].size(), lb(k, b[i]), b[i]);
  }
  int pos0 = lb(1, 0), posk;
  while (q--) {
    int l, r, k;
    std::cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;
    posk = lb(0, -k);
    LL s = a[r] + 1LL * (negCnt[r] - negCnt[l]) * k;
    int n = r - l + 1;
    auto cal = [&amp;](int x) {
      int pre = n - x;
      int low = 0, high = k;
      while (low &lt; high) {
        int mid = low + high &gt;&gt; 1;
        cnt = 0;
        ask(root[r][0], root[l][0], 0, c[0].size(), posk, lb(0, mid - k + 1));
        ask(root[r][1], root[l][1], 0, c[1].size(), pos0, lb(1, mid + 1));
        if (a[l] &lt;= mid) cnt++;
        if (cnt &lt; pre) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      // std::cerr &lt;&lt; &#34;??\n&#34;;
      cnt = 0;
      sum = 0;
      ask(root[r][0], root[l][0], 0, c[0].size(), posk, lb(0, low - k));
      sum += 1LL * cnt * k;
      ask(root[r][1], root[l][1], 0, c[1].size(), pos0, lb(1, low));
      if (a[l] &lt; low) cnt++, sum += a[l];
      assert(cnt &lt;= n - x);
      sum += 1LL * (n - x - cnt) * low;
      // std::cerr &lt;&lt; n - x &lt;&lt; &#34; &#34; &lt;&lt; low &lt;&lt; &#34; &#34; &lt;&lt; cnt &lt;&lt; &#34;\n&#34;;
      return sum + std::max(0LL, 1LL * x * k - s);
    };
    LL pos = (s + k - 1) / k;
    smin(pos, r - l + 1);
    // std::cerr &lt;&lt; &#34;pos : &#34; &lt;&lt; pos &lt;&lt; &#34;\n&#34;;
    LL ans = cal(pos);
    
    if (pos) smin(ans, cal(pos - 1));
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  std::cerr &lt;&lt; &#34;time : &#34; &lt;&lt; (double)clock() / CLOCKS_PER_SEC - sta &lt;&lt; &#34;\n&#34;;
  return 0;
}

```
- https://blog.asukakyle.top/post/2021nowcoder7/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Min_25筛小记</title>
        <link>https://blog.asukakyle.top/post/min_25/</link>
        <pubDate>Sat, 07 Aug 2021 10:38:55 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/min_25/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/min_25/ -## min_25 筛

约定

- $\mathbf{P}$ 表示全体质数集合
- $p_i$ 表示第 $i$ 个质数，特别地，$p_0 =1$。
- $\mathrm{lpf}_i$ 表示 $i$​ 的最小质因子。



&gt; 计算数论函数 $f(n)$​​​​ 的前缀和，要求 $f(p_i)$​​​​ 是低阶多项式，且对于合数 $n$​​​​，$f(n)$​ 可以写成形如 $f(n) = A(\mathrm{lpf}_n^e)B\left(\dfrac{n}{\mathrm{lpf_n^e}}\right)$​​​​的式子，其中 $A(p^e)$​​​​ 可以快速求值或预处理。
&gt;
&gt; 当 $f(n)$​ 是积性函数时，$A(p^e) = f(p^e), B(n) = f(n)$​。

### Part. 1



令
$$
g_k(n, i) = \sum_{j=1}^nj^k[j \in \mathbf{P} \ \mathrm{or}\  \mathrm{lpf}_j &gt; p_i]
$$
直观地，$g_k(n, i)$ 表示埃式筛第 $i$ 轮后剩余 $n$ 以内的数的 $k$ 次方之和。
$$
g_k(n, i) = \begin{cases}
g_k(n, i - 1), &amp; p_i^2 &gt; n\\
g_k(n, i - 1) - p_i^k\left(g_k\left(\lfloor \dfrac{n}{p_i}\rfloor, i-1\right) - \sum_{j=1}^{i-1}p_j^k\right), &amp; p_i^2 \leq n
\end{cases}
$$
直观地，考虑埃式筛第 $i$ 轮：

- 如果 $p_i^2&gt;n$，那么这一轮不会筛去任何数，于是 $g_k(n, i) = g_k(n, i - 1)$ 。
- 如果 $p_i^2\leq n$，那么这一轮会筛去最小质因子等于 $p_i$ 的数，所以要减去计算这些数的 $k$ 次方之和，提出公因子 $p_i^k$ 后可得上式。

递推求出 $g_k(x, \infty)$​​​​ 在所有 $x = \lfloor \dfrac{n}{i}\rfloor$​​​​​​ 处的取值，复杂度是 $O\left(\dfrac{n^{\frac34}}{\log n}\right)$​​。

```cpp
// Calculate g(x, 0) on [n / i]
int m = 0;
for (LL i = 1, j; i &lt;= n; i = j + 1) {
  val[++m] = n / i;
  j = n / val[m];
  g0[m] = (val[m] - 1) % P; // x - 1
  g1[m] = (val[m] + 2) % P * g0[m] % P * (P + 1 &gt;&gt; 1) % P; // 2 + 3 + ... + x
  if (val[m] &lt;= sq) {
    id1[val[m]] = m;
  } else {
    id2[j] = m;
  }
}
  
// Calculate g(x, i)
for (int i = 1; i &lt;= cnt; i++) {
  LL limit = 1LL * primes[i] * primes[i];
  for (int j = 1; val[j] &gt;= limit; j++) {
    LL x = val[j] / primes[i];
    int k = x &lt;= sq ? id1[x] : id2[n / x];
    g0[j] = (g0[j] + i - 1LL - g0[k]) % P;
    g1[j] = (g1[j] - 1LL * primes[i] * (g1[k] - primeSum[i - 1])) % P;
  }
}
```

### Part. 2



令
$$
s(n, i) = \sum_{j=1}^nf(j)[\mathrm{lpf}_j &gt; p_i]
$$
即 $s(n, i)$ 表示 $n$ 以内最小质因子大于等于 $p_i$ 的函数值之和。

则 $f(x)$ 的前缀和为
$$
\sum_{i=1}^nf(i) = s(n, 1) + f(1)
$$
考虑计算 $s(n, i)$。

由 Part. 1 可以快速计算质数的贡献 $\sum_{j=p_i}^nf(j)[j \in \mathbf{P}] = \sum_{k}\mathrm{coef_k}\times g_k(n, \infty)$。

考虑合数的贡献，以 $f(n)$ 是积性函数为例，枚举最小质因子得到
$$
\sum_{j=i}^{p_j^2\leq n}\sum_{c=1}^{p_j^{c+1} \leq n}\left[
f\left(p^{k+1}\right)+
f\left(p_j^k\right)s\left(
\left\lfloor
\frac{n}{p_j^c}
\right\rfloor,
j+1
\right)
\right]
$$
所以
$$
s(n, i) = \begin{cases}
\sum\limits_{j=i}^{p_j \leq n} f(p_j)
+
\sum\limits_{j=i}^{p_j^2\leq n}\sum\limits_{c=1}^{p_j^{c+1} \leq n}\left[
f\left(p^{k+1}\right)+
f\left(p_j^k\right)s\left(
\left\lfloor
\frac{n}{p_j^c}
\right\rfloor,
j+1
\right)
\right], &amp; p_i \leq n\\
0,  &amp; p_i &gt; n
\end{cases}
$$
递归求解。- https://blog.asukakyle.top/post/min_25/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021牛客多校6</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder6/</link>
        <pubDate>Sat, 07 Aug 2021 09:53:25 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder6/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder6/ -| 题号 | 标题                                                         | 团队的状态 |
| ---- | ------------------------------------------------------------ | ---------- |
| A    | [Contracting Convex Hull](https://ac.nowcoder.com/acm/contest/11257/A) | 未通过     |
| B    | [Defend Ponyville](https://ac.nowcoder.com/acm/contest/11257/B) | 通过     |
| C    | [Delete Edges](https://ac.nowcoder.com/acm/contest/11257/C)  | 通过       |
| D    | [Gambling Monster](https://ac.nowcoder.com/acm/contest/11257/D) | 通过       |
| E    | [Growing Tree](https://ac.nowcoder.com/acm/contest/11257/E)  | 通过       |
| F    | [Hamburger Steak](https://ac.nowcoder.com/acm/contest/11257/F) | 通过       |
| G    | [Hasse Diagram](https://ac.nowcoder.com/acm/contest/11257/G) | 通过       |
| H    | [Hopping Rabbit](https://ac.nowcoder.com/acm/contest/11257/H) | 通过       |
| I    | [Intervals on the Ring](https://ac.nowcoder.com/acm/contest/11257/I) | 通过       |
| J    | [Defend Your Country](https://ac.nowcoder.com/acm/contest/11257/J) | 通过       |
| K    | [Starch Cat](https://ac.nowcoder.com/acm/contest/11257/K)    | 通过       |


## [Contracting Convex Hull](https://ac.nowcoder.com/acm/contest/11257/A)

## [Defend Ponyville](https://ac.nowcoder.com/acm/contest/11257/B)
```cpp
// Author:  HolyK
// Created: Fri Aug 13 20:54:58 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z(int v = 0) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z inv() const {
    assert(x);
    return Z(fpow(x));
  }
  Z power(int k) const {
    return Z(fpow(x, k));
  }
  Z &amp;operator+=(const Z &amp;r) {
    inc(x, r.x);
    return *this;
  }
  Z &amp;operator-=(const Z &amp;r) {
    dec(x, r.x);
    return *this;
  }
  Z &amp;operator*=(const Z &amp;r) {
    x = 1LL * x * r.x % P;
    return *this;
  }
  Z &amp;operator/=(const Z &amp;r) {
    x = 1LL * x * fpow(r.x) % P;
    return *this;
  }
  Z operator+(const Z &amp;r) const {
    return Z(*this) += r;
  }
  Z operator-(const Z &amp;r) const {
    return Z(*this) -= r;
  }
  Z operator*(const Z &amp;r) const {
    return Z(*this) *= r;
  }
  Z operator/(const Z &amp;r) const {
    return Z(*this) /= r;
  }
  Z operator-() const {
    return Z(P - x);
  }
  operator int() const {
    return x;
  }
};

// using Z = ModInt&lt;P&gt;;

// det(xI + A)
auto charPoly(std::vector&lt;std::vector&lt;Z&gt;&gt; a) {
  
  int n = a.size();
  for (int j = 0; j &lt; n - 2; j++) {
    for (int i = j + 1; i &lt; n; i++) {
      if (!a[i][j]) continue;
      std::swap(a[i], a[j + 1]);
      for (int k = 0; k &lt; n; k++) {
        std::swap(a[k][i], a[k][j + 1]);
      }
      break;
    }
    if (a[j + 1][j]) {
      auto inv = a[j + 1][j].inv();
      for (int i = j + 2; i &lt; n; i++) {
        auto c = a[i][j] * inv;
        for (int k = 0; k &lt; n; k++) a[i][k] -= a[j + 1][k] * c;
        for (int k = 0; k &lt; n; k++) a[k][j + 1] += a[k][i] * c;
      }
    }
  }
  std::vector&lt;std::vector&lt;Z&gt;&gt; h(n + 1);
  h[0] = {1};
  for (int i = 0; i &lt; n; i++) {
    Z prod = 1;
    h[i + 1].resize(h[i].size() + 1);
    for (int j = 0; j &lt; h[i].size(); j++) {
      h[i + 1][j + 1] = h[i][j];
      h[i + 1][j] += h[i][j] * a[i][i];
    }
    for (int j = 0; j &lt; i; j++) {
      prod *= -a[i - j][i - j - 1];
      auto c = a[i - j - 1][i] * prod;
      for (int k = 0; k &lt; h[i - j - 1].size(); k++) {
        h[i + 1][k] += h[i - j - 1][k] * c;
      }
    }
  }
  return h[n];
}

int main() {
  // freopen(&#34;06.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, t, k;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; k;
  std::vector a(n, std::vector&lt;Z&gt;(n)), b = a;
  auto out = [&amp;](auto a) {
    // for (int i = 0; i &lt; n; i++) {
    //   for (int j = 0; j &lt; n; j++) {
    //     std::cerr &lt;&lt; a[i][j] &lt;&lt; &#34; \n&#34;[j + 1 == n];
    //   }
    // }
  };
  while (m--) {
    int x, y, a1, b1, a2, b2;
    std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; a2 &gt;&gt; b2;
    x--, y--;
    Z p = Z(a1) / Z(b1);
    Z q = Z(a2) / Z(b2);
    p -= q;
    a[x][x] += p;
    a[y][y] += p;
    a[x][y] -= p;
    a[y][x] -= p;
    b[x][x] += q;
    b[y][y] += q;
    b[x][y] -= q;
    b[y][x] -= q;
  }
  n--;
  if (!n) return puts(&#34;0&#34;), 0;
  a.pop_back();
  for (auto &amp;v : a) v.pop_back();
  b.pop_back();
  for (auto &amp;v : b) v.pop_back();
  out(a);
  Z prod(1);
  for (int i = 0, j; i &lt; n; i++) {
    for (j = i; j &lt; n; j++) {
      if (!a[j][i]) continue;
      if (i != j) {
        std::swap(a[i], a[j]);
        std::swap(b[i], b[j]);
        prod *= -1;
       }
      break;
    }
    if (j == n) return puts(&#34;0&#34;), 0;
    prod *= a[i][i];
    Z inv = a[i][i].inv();
    for (int j = i; j &lt; n; j++) a[i][j] *= inv;
    for (int j = 0; j &lt; n; j++) b[i][j] *= inv;
    for (j++; j &lt; n; j++) {
      if (!a[j][i]) continue;
      Z x = a[j][i];
      for (int k = i; k &lt; n; k++) a[j][k] -= x * a[i][k];
      for (int k = 0; k &lt; n; k++) b[j][k] -= x * b[i][k];
    }
  }
  for (int i = n - 1; i; i--) {
    for (int j = 0; j &lt; i; j++) {
      if (!a[j][i]) continue;
      for (int k = 0; k &lt; n; k++) b[j][k] -= a[j][i] * b[i][k];
      a[j][i] = 0;
    }
  }
  
  out(a);
  out(b);
  // for (auto &amp;x : b) for (auto &amp;y : x) y = -y;
  // std::cerr &lt;&lt; &#34;prod &#34; &lt;&lt; prod.val() &lt;&lt; &#34;\n&#34;;
  auto c = charPoly(b);
  for (auto &amp;x : c) x *= prod;
  Z ans = c[0] * Z(t), v = k = fpow(k);
  // assert(c.size() == n);
  for (int i = 1; i &lt; c.size(); i++, v *= k) {
    ans += k == 1 ? c[i] * Z(t) : c[i] * (v.power(t) - Z(1)) / (v - Z(1));
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## [Delete Edges](https://ac.nowcoder.com/acm/contest/11257/C)  

## [Gambling Monster](https://ac.nowcoder.com/acm/contest/11257/D) 
分治fwt。
```cpp
// Author:  HolyK
// Created: Mon Aug  2 14:51:08 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(1e9 + 7);
inline int &amp;inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
  return x;
}
inline int sum(int x, int y) {
  return x + y &gt;= P ? x + y - P : x + y;
}
inline int mod(LL x) {
  return x % P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
using Poly = std::vector&lt;int&gt;;
class FwtBase {
 public:
  FwtBase() = default;
  Poly conv(Poly a, Poly b) {
    assert(a.size() == b.size());
    fwt(a), fwt(b);
    for (int i = 0; i &lt; (int)a.size(); i++)
      a[i] = 1LL * a[i] * b[i] % P;
    ifwt(a);
    return a;
  }
  virtual ~FwtBase() = default;
 private:
  virtual void fwt(Poly &amp;a) {}
  virtual void ifwt(Poly &amp;a) {}
};

class FwtXor: public FwtBase {
  void fwt(Poly &amp;a) {
    int n = a.size();
    assert((n &amp; n - 1) == 0);
    for (int k = 1; k &lt; n; k &lt;&lt;= 1)
      for (int i = 0; i &lt; n; i += k &lt;&lt; 1)
        for (int j = 0, x, y; j &lt; k; j++) {
          x = a[i + j], y = a[i + j + k];
          inc(a[i + j], y);
          a[i + j + k] = sum(x, P - y);
        }
  }
  void ifwt(Poly &amp;a) {
    int n = a.size();
    auto shift = [](int &amp;x) { x = x &amp; 1 ? x + P &gt;&gt; 1 : x &gt;&gt; 1; };
    for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1)
      for (int i = 0; i &lt; n; i += k &lt;&lt; 1)
        for (int j = 0, x, y; j &lt; k; j++) {
          x = a[i + j], y = a[i + j + k];
          shift(inc(a[i + j], y));
          shift(a[i + j + k] = sum(x, P - y));
        }
  }
} fwt_xor;

int n, p[1 &lt;&lt; 16], s[1 &lt;&lt; 16], f[1 &lt;&lt; 16];
void solve() {
  std::cin &gt;&gt; n;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; p[i];
    s[i] = p[i];
    f[i] = 0;
  }
  for (int i = 1; i &lt; n; i++) {
    inc(s[i], s[i - 1]);
  }
  int inv = fpow(s[n - 1]);
  for (int i = 0; i &lt; n; i++) {
    p[i] = mod(1LL * p[i] * inv);
    s[i] = mod(1LL * s[i] * inv);
  }
  // for (int i = n - 1; i &gt;= 0; i--) {
  //   int sum = 0;
  //   for (int j = i + 1; j &lt; n; j++) {
  //     inc(sum, p[i ^ j]);
  //     f[i] = mod(f[i] + 1LL * f[j] * p[i ^ j]);
  //   }
  //   f[i] = (f[i] + 1LL) * fpow(sum) % P;
  // }
  int d = std::__lg(n);
  for (int m = n - 1; m &gt;= 0; m--) {
    int sum = 0;
    for (int i = d - 1, p = n &gt;&gt; 1; i &gt;= 0; i--, p &gt;&gt;= 1) {
      if (!(m &amp; p)) {
        inc(sum, s[p * 2 - 1]);
        inc(sum, P - s[p - 1]);
      }
    }
    f[m] = mod(1LL * fpow(sum) * (f[m] + 1));
    if (!m) break;
    int l = m &amp; m - 1, r = m + (m &amp; -m);
    Poly a(f + l, f + r), b(p, p + (r - l));
    for (int i = 0; i &lt; r - m; i++) a[i] = 0;
    a = fwt_xor.conv(a, b);
    for (int i = 0; i &lt; r - m; i++) {
      inc(f[l + i], a[i]);
    }
  }
  std::cout &lt;&lt; f[0] &lt;&lt; &#34;\n&#34;;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}

```

## [Growing Tree](https://ac.nowcoder.com/acm/contest/11257/E)  
重量平衡树维护括号序，可以用旋转 treap 或者替罪羊。

关于重量平衡树，是否可以用非旋转 treap 实现以及是否可以可持久化有待探讨。
```cpp
// Author:  HolyK
// Created: Fri Aug  6 10:11:54 2021
#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
template &lt;class T, class Comp = std::less&lt;T&gt;&gt;
using Tree = __gnu_pbds::tree&lt;T, __gnu_pbds::null_type, Comp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update&gt;;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(5e5 + 5);
struct Node {
  Node *ch[2], *fa;
  int rnd;
  LL v, l;
  void sch(int d, Node *p) {
    ch[d] = p;
    if (p) p-&gt;fa = this;
  }
  int dir() const {
    return this == fa-&gt;ch[1];
  }
  void rotate() {
    Node *f = fa, *ff = f-&gt;fa;
    int k = dir();
    if (ff) ff-&gt;ch[f-&gt;dir()] = this;
    fa = ff;
    f-&gt;sch(k, ch[!k]), sch(!k, f);
  }
  void label() {
    if (fa) {
      l = fa-&gt;l / 2;
      v = fa-&gt;v + l * (dir() ? 1 : -1);
    } else {
      v = l = 1LL &lt;&lt; 60;
    }
    
    if (ch[0]) ch[0]-&gt;label();
    if (ch[1]) ch[1]-&gt;label();
  }
} t[N * 2], *cur;

Node *newNode() {
  static std::mt19937 rng(19260817);
  cur-&gt;ch[0] = cur-&gt;ch[1] = cur-&gt;fa = nullptr;
  cur-&gt;rnd = rng();
  return cur++;
}
Node *ins(Node *o) {
  Node *p = newNode();
  if (!o-&gt;ch[1]) {
    o-&gt;sch(1, p);
  } else {
    o = o-&gt;ch[1];
    while (o-&gt;ch[0]) o = o-&gt;ch[0];
    o-&gt;sch(0, p);
  }
  while (p-&gt;fa &amp;&amp; p-&gt;rnd &lt; p-&gt;fa-&gt;rnd) {
    p-&gt;rotate();
  }
  p-&gt;label();
  return p;
}
struct Comp {
  bool operator()(Node *const &amp;a, Node *const &amp;b) const {
    return a-&gt;v &lt; b-&gt;v;
  }
};
Tree&lt;Node*, Comp&gt; s[N];
Node *l[N], *r[N];
int c[N];
void solve() {
  cur = t;
  l[1] = newNode();
  l[1]-&gt;label();
  r[1] = ins(l[1]);
  int m;
  std::cin &gt;&gt; c[1] &gt;&gt; m;
  s[c[1]].insert(l[1]);
  int ans = 0, n = 1;
  while (m--) {
    int opt, x, y;
    std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    opt ^= ans, x ^= ans, y ^= ans;
    if (opt == 1) {
      l[++n] = ins(l[x]);
      r[n] = ins(l[n]);
      c[n] = y;
      s[y].insert(l[n]);
    } else if (opt == 2) {
      ans = s[y].order_of_key(r[x]) - s[y].order_of_key(l[x]);
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    } else {
      assert(false);
    }
  }
  for (int i = 1; i &lt;= n; i++) {
    s[c[i]].clear();
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

## [Hamburger Steak](https://ac.nowcoder.com/acm/contest/11257/F) 
二分后贪心。
```cpp
// Author:  HolyK
// Created: Mon Aug  2 12:51:09 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
int a[N];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin &gt;&gt; n &gt;&gt; m;
  LL ans = 0, sum = 0;
  
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    sum += a[i];
    smax(ans, a[i]);
  }
  smax(ans, (sum + m - 1) / m);
  LL v = 0;
  int id = 1;
  for (int i = 1; i &lt;= n; i++) {
    
    if (v + a[i] &lt;= ans) {
      std::cout &lt;&lt; 1 &lt;&lt; &#34; &#34; &lt;&lt; id &lt;&lt; &#34; &#34; &lt;&lt; v &lt;&lt; &#34; &#34; &lt;&lt; v + a[i] &lt;&lt; &#34;\n&#34;;
      v += a[i];
    } else {
      std::cout &lt;&lt; 2 &lt;&lt; &#34; &#34; &lt;&lt; id + 1 &lt;&lt; &#34; &#34; &lt;&lt; 0 &lt;&lt; &#34; &#34; &lt;&lt; v + a[i] - ans &lt;&lt; &#34; &#34; &lt;&lt; id &lt;&lt; &#34; &#34; &lt;&lt; v &lt;&lt; &#34; &#34; &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
      id++;
      v = v + a[i] - ans;
    }
    if (v == ans) id++, v = 0;
  }
  return 0;
}

```

## [Hasse Diagram](https://ac.nowcoder.com/acm/contest/11257/G) 

$$
f(n) = (e + 1) f(\frac{n}{p^e}) + e\operatorname{d}(\frac{n}{p^e})
$$

$\operatorname{d}(n)$ 表示因数个数。

min_25筛同时筛 $f, d$。
```cpp
// Author:  HolyK
// Created: Sat Aug  7 08:42:22 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
using u32 = uint32_t;
using u64 = uint64_t;
constexpr u32 P(1145140019u);
inline void inc(u32 &amp;x, u32 y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline u32 mod(u64 x) {
  return x % P;
}
u32 fpow(u32 x, u32 k = P - 2) {
  u32 r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
constexpr int N(2e5 + 5);
bool np[N];
u32 primes[N], cnt, g0[N];
void sieve(u32 n) {
  for (u32 i = 2, j; i &lt;= n; i++) {
    if (!np[i]) {
      primes[++cnt] = i;
    }
    for (j = 1; j &lt;= cnt &amp;&amp; i * primes[j] &lt;= n; j++) {
      np[i * primes[j]] = true;
      if (i % primes[j] == 0) break;
    }
  }
}
u64 val[N];
int id1[N], id2[N];
void solve() {
  u64 n;
  std::cin &gt;&gt; n;
  int m = 0;
  for (u64 i = 1, j; i &lt;= n; i = j + 1) {
    val[++m] = n / i;
    j = n / val[m];
    g0[m] = (val[m] - 1) % P;
    if (val[m] &lt;= 1e5) {
      id1[val[m]] = m;
    } else {
      id2[j] = m;
    }
  }
  for (u32 i = 1; i &lt;= cnt; i++) {
    u64 limit = u64(primes[i]) * primes[i];
    if (limit &gt; n) break;
    for (u32 j = 1; val[j] &gt;= limit; j++) {
      u64 x = val[j] / primes[i];
      int k = x &lt;= 1e5 ? id1[x] : id2[n / x];
      g0[j] = mod(g0[j] + (P - g0[k]) + i - 1);
    }
  }

  auto cal = [&amp;](auto rec, u64 x, u32 i) -&gt; std::pair&lt;u32, u32&gt; {
    if (x == 1) return {0, 1};
    if (primes[i] &gt; x) return {0, 0};
    int k = x &lt;= 1e5 ? id1[x] : id2[n / x];
    u32 sum_f = mod(g0[k] + P - i + 1), sum_d = sum_f * 2 % P;
    for (u32 j = i; j &lt;= cnt &amp;&amp; u64(primes[j]) * primes[j] &lt;= x; j++) {
      for (u64 k = 1, s = primes[j]; s * primes[j] &lt;= x; k++, s *= primes[j]) {
        auto [f, d] = rec(rec, x / s, j + 1);
        sum_f = mod(sum_f + k + 1 + (k + 1) * f + k * d);
        sum_d = mod(sum_d + k + 2 + (k + 1) * d);
      }
    }
    return {sum_f, sum_d};
  };
  std::cout &lt;&lt; cal(cal, n, 1).first &lt;&lt; &#34;\n&#34;;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  sieve(1e5);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}

```

## [Hopping Rabbit](https://ac.nowcoder.com/acm/contest/11257/H) 
线段树维护矩形并。
```cpp
// Author:  HolyK
// Created: Mon Aug  2 13:55:48 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
int min[N &lt;&lt; 2], tag[N &lt;&lt; 2];
void pushup(int o) {
  min[o] = std::min(min[ls], min[rs]);
}
void add(int o, int z) {
  min[o] += z;
  tag[o] += z;
}
void pushdown(int o) {
  if (tag[o]) {
    add(ls, tag[o]);
    add(rs, tag[o]);
    tag[o] = 0;
  }
}
void update(int o, int l, int r, int x, int y, int z) {
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    add(o, z);
    return;
  }
  int m = l + r &gt;&gt; 1;
  pushdown(o);
  if (x &lt; m) update(ls, l, m, x, y, z);
  if (y &gt; m) update(rs, m, r, x, y, z);
  pushup(o);
}
int ask(int o, int l, int r) {
  if (r - l == 1) return l;
  int m = l + r &gt;&gt; 1;
  pushdown(o);
  return min[ls] ? ask(rs, m, r) : ask(ls, l, m);
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin &gt;&gt; n &gt;&gt; m;
  std::vector&lt;std::vector&lt;std::array&lt;int, 3&gt;&gt;&gt; g(m);
  for (int i = 0; i &lt; n; i++) {
    int a, b, c, d;
    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
    a = (a % m + m) % m;
    b = (b % m + m) % m;
    c = (c % m + m) % m;
    d = (d % m + m) % m;
    g[a].push_back({b, d, 1});
    g[c].push_back({b, d, -1});
    if (a &gt;= c) {
      g[0].push_back({b, d, 1});
    }
  }
  for (int i = 0; i &lt; m; i++) {
    for (auto [x, y, z] : g[i]) {
      if (x &lt; y) {
        update(1, 0, m, x, y, z);
      } else {
        std::swap(x, y);
        update(1, 0, m, 0, m, z);
        if (x &lt; y) update(1, 0, m, x, y, -z);
      }
    }
    if (min[1] == 0) {
      std::cout &lt;&lt; &#34;YES\n&#34;;
      std::cout &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; ask(1, 0, m) &lt;&lt; &#34;\n&#34;;
      return 0;
    }
  }
  std::cout &lt;&lt; &#34;NO\n&#34;;
  return 0;
}

```

## [Intervals on the Ring](https://ac.nowcoder.com/acm/contest/11257/I) 
$$
\overline{\bigcup A_i} = \bigcap \overline{A_i}
$$

```cpp
// Author:  HolyK
// Created: Mon Aug  2 12:05:21 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    std::vector&lt;PII&gt; a(m);
    for (int i = 0; i &lt; m; i++) {
      std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
    }
    std::sort(a.begin(), a.end());
    std::cout &lt;&lt; m &lt;&lt; &#34;\n&#34;;
    for (int i = 0; i &lt; m; i++) {
      std::cout &lt;&lt; a[(i + 1) % m].first &lt;&lt; &#34; &#34; &lt;&lt; a[i].second &lt;&lt; &#34;\n&#34;;
    }
  }
  return 0;
}

```

## [Defend Your Country](https://ac.nowcoder.com/acm/contest/11257/J) 
```cpp
// Author:  HolyK
// Created: Mon Aug  2 16:17:15 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e6 + 5);
int n, m, a[N];
std::vector&lt;int&gt; g[N];
LL ans, sum, val[N];
int in[N], low[N], cnt, siz[N];
void dfs(int x) {
  in[x] = low[x] = ++cnt;
  LL min = a[x], s = a[x];
  int c = 1;
  siz[x] = 1;
  val[x] = a[x];
  bool cut = false;
  for (int y : g[x]) {
    if (!in[y]) {
      dfs(y);
      siz[x] ^= siz[y];
      smin(low[x], low[y]);
      val[x] += val[y];
      if (low[y] &gt;= in[x]) {
        cut = true;
        if (siz[y] &amp; 1) {
          c = 0;
        }
      }
    } else {
      smin(low[x], in[y]);
    }
  }
  if (c &amp; 1) {
    smax(ans, sum - a[x] * 2);
  }
}
void solve() {
  std::cin &gt;&gt; n &gt;&gt; m;
  sum = 0;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    sum += a[i];
    g[i].clear();
    in[i] = 0;
    siz[i] = 0;
  }
  while (m--) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    g[x].push_back(y);
    g[y].push_back(x);
  }
  if (n % 2 == 0) {
    std::cout &lt;&lt; sum &lt;&lt; &#34;\n&#34;;
    return;
  }
  ans = -sum;
  cnt = 0;
  dfs(1);
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

## [Starch Cat](https://ac.nowcoder.com/acm/contest/11257/K)    
点分树处理中心到每个点的dp值。

随机数据暴力求lca很快。
```cpp
// Author:  HolyK
// Created: Fri Aug  6 16:44:46 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P = 998244353;

struct Rand{
  unsigned int n,seed;
  Rand(unsigned int n,unsigned int seed)
    :n(n),seed(seed){}
  int get(long long lastans){
    seed ^= seed &lt;&lt; 13;
    seed ^= seed &gt;&gt; 17;
    seed ^= seed &lt;&lt; 5;
    return (seed^lastans)%n+1;
  }
};

constexpr int N(5e5 + 5);
int n, a[N], siz[N];

std::vector&lt;int&gt; g[N];
bool vis[N];
void getSize(int x, int p) {
  siz[x] = 1;
  for (int y : g[x]) {
    if (y == p || vis[y]) continue;
    getSize(y, x);
    siz[x] += siz[y];
  }
}
int getRoot(int x, int p, int s) {
  for (int y : g[x]) {
    if (y == p || vis[y] || siz[y] * 2 &lt; s) continue;
    return getRoot(y, x, s);
  }
  return x;
}
LL f[20][N][2], dp[N][2][2];
int anc[20][N];
void dfs(int x, int p, int d, int r) {
  anc[d][x] = r;
  f[d][x][0] = std::max(dp[x][0][0], dp[x][0][1]);
  f[d][x][1] = std::max(dp[x][1][0], dp[x][1][1]);
  for (int y : g[x]) {
    if (y == p || vis[y]) continue;
    dp[y][0][0] = std::max(dp[x][0][0], dp[x][0][1]);
    dp[y][0][1] = dp[x][0][0] + a[y];
    dp[y][1][0] = std::max(dp[x][1][0], dp[x][1][1]);
    dp[y][1][1] = dp[x][1][0] + a[y];
    dfs(y, x, d, r);
  }
}
void solve(int x, int d) {
  getSize(x, 0);
  x = getRoot(x, 0, siz[x]);
  dp[x][0][0] = 0;
  dp[x][0][1] = dp[x][1][0] = -1e18;
  dp[x][1][1] = a[x];
  dfs(x, 0, d, x);
  vis[x] = true;
  for (int y : g[x]) {
    if (vis[y]) continue;
    solve(y, d + 1);
  }
}
LL query(int x, int y) {
  if (x == y) return a[x];
  for (int i = 0; i &lt; 20; i++) {
    if (anc[i + 1][x] != anc[i + 1][y]) {
      int p = anc[i][x];
      return std::max(f[i][x][1] + f[i][y][1] - a[p], f[i][x][0] + f[i][y][0]);
    }
  }
  // return -1;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, seed;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; seed;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
  }
  for (int i = 2, x; i &lt;= n; i++) {
    std::cin &gt;&gt; x;
    g[x].push_back(i);
    g[i].push_back(x);
  }
  solve(1, 0);
  LL lastans = 0, ans = 0;
  Rand rand(n, seed);
  for (int i = 0; i &lt; m; i++) {
    int u = rand.get(lastans);
    int v = rand.get(lastans);
    int x = rand.get(lastans);
    lastans = query(u, v);
    ans = (ans + lastans % P * x) % P;
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}
```
- https://blog.asukakyle.top/post/2021nowcoder6/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 