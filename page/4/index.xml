<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/</link>
    <description>Recent content on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 05 Aug 2022 23:16:50 +0800</lastBuildDate>
    
        <atom:link href="https://blog.asukakyle.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Gym102441</title>
        <link>https://blog.asukakyle.top/post/gym102441/</link>
        <pubDate>Thu, 08 Apr 2021 22:39:55 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/gym102441/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/gym102441/ -## 总览
|   题号   | A | B | C | D | E | F | G | H | I | J | K |
|:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 完成情况 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |

## A. Template for Search
&gt; 给定由小写字母、字符`*` 和 `?` 组成的字符串 $s$，其中 `*` 可以被替换成任意串（包括空串），`?` 可以被替换成任意字符，求 $s$ 可以表示成的最短回文串。
&gt; 
&gt; $1 \leq |s| \leq 500$。 

设 $dp[l][r]$ 表示 $l \dots r$ 能组成的最短回文串，有三种转移：

- $s_l$ 匹配 $s_r$
- $s_l = *$ 匹配右边一段
- $s_r = *$ 匹配左边一段

## B. Redistribution of Digits

## C. Partial Sums
&gt; $n \times m$ 矩阵列 $\{A_k\}$ 满足递推关系
&gt; $$
&gt; A_k[i, j] = \sum_{u = 1}^i\sum_{v = 1}^jA_{k-1}[u, v] \bmod 2
&gt; $$
&gt; 
&gt; 给出 $A_0$，求 $\{A_k\}$ 的最小循环节。
&gt; 
&gt; $1 \leq n \times m \leq 10^6$

递推关系是二维前缀和。数列 $a_n$ 做 $k$ 次前缀和的结果是 
$$
a&#39;_n = \sum_{i = 1}^na_i\binom{n - i + k - 1}{n - i}
$$
这个式子可以这样推导，初始为 $i$ 每步可以加一个非负值，走 $k$ 步，求 $i$ 到 $n$ 的路径数，等价于 $x_i+x_{i+1}+\dots+x_{n}=k, x_i, x_{i+1}, \dots, x_{n-1} \geq 0, x_n \geq 1$，用隔板法可得答案为 $\dbinom{n - i + k - 1}{n - i}$。

二维相互独立，所以 
$$
A_k[i, j] = \sum_{u, v}A_0[u, v]\binom{i - u + k - 1}{i - u}\binom{j - v + k - 1}{j - v} \bmod 2
$$

由卢卡斯定理，当 $k = 2^{d_0} &gt; n$ 时，$\binom{i - u + k - 1}{i - u} \equiv 1 \pmod 2$，所以循环节是 $2^{d_0}$ 的因子。

枚举循环节 $k = 2^d$，由卢卡斯定理 $\binom{i - u + k - 1}{i - u} \equiv 1 \pmod 2$ 当且仅当 $i - u = t \times 2^d$，即 $u = i - 2^dt$，用二维前缀和可以 $O(nm)$ 验证。

复杂度 $O(nm\log(nm))$。

```cpp
#include &lt;bits/stdc++.h&gt;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin &gt;&gt; n &gt;&gt; m;
  std::vector&lt;std::vector&lt;int&gt;&gt; a(n);
  for (int i = 0; i &lt; n; i++) {
    a[i].resize(m);
    std::string s;
    std::cin &gt;&gt; s;
    for (int j = 0; j &lt; m; j++) a[i][j] = s[j] - &#39;0&#39;;
  }
  auto b = a;
  for (int k = 1; ; k &lt;&lt;= 1) {
    if ([&amp;]{
      for (int i = 0; i &lt; n; i++)
        for (int j = 0; j &lt; m; j++) {
          b[i][j] = a[i][j];
          if (i &gt;= k) b[i][j] ^= b[i - k][j];
          if (j &gt;= k) b[i][j] ^= b[i][j - k];
          if (i &gt;= k &amp;&amp; j &gt;= k) b[i][j] ^= b[i - k][j - k];
          if (b[i][j] ^ a[i][j]) return false;
        }
      return true;
    }()) {
      return std::cout &lt;&lt; k &lt;&lt; &#34;\n&#34;, 0;
    }
    if (k &gt; n &amp;&amp; k &gt; m) assert(false);
  }
  return 0;
}

```

## D. Lis on Circle
&gt; $n$ 个人顺时针围成一圈，第 $i$ 个人手上有 $m_i$ 个数 $a_1, a_2, \dots, a_{m_i}$，从 1 开始顺时针进行游戏，轮到一个人时他可以选择跳过，也可以出一个数，但这个数必须比之前的人出的数大。不能有连续超过 $k$ 个人跳过，求最多能出多少数。
&gt; 
&gt; $0 \leq n, \sum m_i \leq 10^5, 0 \leq a_i \leq 10^9$。 

按数从小到大dp，设 $dp[i]$ 表示最后一个数是 $i$ 出的，最多出了多少数，转移是区间取 $\min$ 和单点赋值，线段树维护即可。

注意没有数的极端情况。

```cpp
#include &lt;bits/stdc++.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
PII max[N &lt;&lt; 2];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
void update(int o, int l, int r, int x, PII y) {
  smax(max[o], y);
  if (l == r) return;
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? update(ls, l, m, x, y) : update(rs, m + 1, r, x, y);
}
PII ask(int o, int l, int r, int x, int y) {
  if (l &gt; r || r &lt; x || l &gt; y) return {-1e9, -1};
  if (x &lt;= l &amp;&amp; r &lt;= y) return max[o];
  int m = l + r &gt;&gt; 1;
  return std::max(ask(ls, l, m, x, y), ask(rs, m + 1, r, x, y));
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, k;
  std::cin &gt;&gt; m &gt;&gt; k;
  std::vector&lt;PII&gt; a;
  for (int i = 1; i &lt;= m; i++) {
    int t, x;
    std::cin &gt;&gt; t;
    while (t--) {
      std::cin &gt;&gt; x;
      a.emplace_back(x, i);
    }
  }
  n = a.size();
  if (!n) return std::cout &lt;&lt; &#34;0\n&#34;, 0;
  std::sort(a.begin(), a.end());
  for (auto &amp;[x ,y] : max) x = -1e9, y = -1;
  std::vector&lt;PII&gt; f(n, PII(-1e9, -1));
  update(1, 0, m, 0, {0, -1});
  for (int i = 0, j = 0; i &lt; n; i++) {
    for (; j &lt; i &amp;&amp; a[j].first &lt; a[i].first; j++) {
      update(1, 0, m, a[j].second, {f[j].first, j});
    }
    f[i] = std::max(ask(1, 0, m, a[i].second - k - 1, a[i].second - 1), ask(1, 0, m, a[i].second - k - 1 + m, m));
    f[i].first++;
    assert(f[i].second &lt; i);
  }
  std::vector&lt;int&gt; ans;
  for (int i = std::max_element(f.begin(), f.end()) - f.begin(); i &gt;= 0 &amp;&amp; f[i].first &gt;= 1; i = f[i].second) ans.emplace_back(i);
  std::reverse(ans.begin(), ans.end());
  std::cout &lt;&lt; ans.size() &lt;&lt; &#34;\n&#34;;
  for (int i : ans) {
    std::cout &lt;&lt; a[i].second &lt;&lt; &#34; &#34; &lt;&lt; a[i].first &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}

```


## E. Very Simple Sum
&gt; 给定数列 $a_1, a_2, \dots, a_n, b_1, b_2, \dots, b_n$，求
&gt; $$
&gt; \sum_{1\leq x, y, z, w \leq n}(a_x+a_y+a_z+a_w)^{b_x\oplus b_y \oplus b_z \oplus b_w} \bmod 998244353
&gt; $$
&gt; 
&gt; $1 \leq n \leq 10^5, 1 \leq a_i, b_i \leq 500$。

设 $cnt[i][j]$ 表示 $i^j$ 项的个数，二维卷积 $C[n][m] = \sum_{x + y = n, z \oplus w = m}A[x][z]\times B[y][w]$，分别用 $FFT, FWT$ 计算即可。

复杂度 $O(ab\log(ab))$。

```cpp
#include &lt;bits/stdc++.h&gt;
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
constexpr int P(998244353), G(3);
inline int&amp;inc(int &amp;x, int y) { return (x += y) &gt;= P ? x -= P : x; }
inline int sum(int x, int y) { return x + y &gt;= P ? x + y - P : x + y; }
inline int sub(int x, int y) { return x - y &lt; 0 ? x - y + P : x - y; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P)
    if (k &amp; 1) r = 1LL * r * x % P;
  return r;
}


using Polynom = std::vector&lt;int&gt;;
std::vector&lt;int&gt; w;
void getOmega(int k) {
  w.resize(k);
  w[0] = 1;
  int base = fpow(G, (P - 1) / (k &lt;&lt; 1));
  for (int i = 1; i &lt; k; i++) w[i] = 1LL * w[i - 1] * base % P;
}
void dft(int *a, int n) {
  assert((n &amp; n - 1) == 0);
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = (1LL * a[i + j] - y + P) * w[j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void dft(Polynom &amp;a) { dft(a.data(), a.size()); }
void idft(int *a, int n) {
  assert((n &amp; n - 1) == 0);
  for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[j] % P;
        a[i + j] = sum(x, y), a[i + j + k] = sub(x, y);
      }
    }
  }
  for (int i = 0, inv = P - (P - 1) / n; i &lt; n; i++) a[i] = 1LL * a[i] * inv % P;
  std::reverse(a + 1, a + n);
}
void idft(Polynom &amp;a) { idft(a.data(), a.size()); }
void fwt(Polynom &amp;a) {
  int n = a.size();
  assert((n &amp; n - 1) == 0);
  for (int k = 1; k &lt; n; k &lt;&lt;= 1)
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1)
      for (int j = 0, x, y; j &lt; k; j++) {
        x = a[i + j], y = a[i + j + k];
        inc(a[i + j], y);
        a[i + j + k] = sum(x, P - y);
      }
}
void ifwt(Polynom &amp;a) {
  int n = a.size();
  auto shift = [](int &amp;x) { x = x &amp; 1 ? x + P &gt;&gt; 1 : x &gt;&gt; 1; };
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1)
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1)
      for (int j = 0, x, y; j &lt; k; j++) {
        x = a[i + j], y = a[i + j + k];
        shift(inc(a[i + j], y));
        shift(a[i + j + k] = sum(x, P - y));
      }
}

int main() {
  int n;
  readInt(n);
  std::vector&lt;int&gt; a(n), b(n);
  for (int &amp;x : a) readInt(x);
  for (int &amp;x : b) readInt(x);
  std::vector&lt;Polynom&gt; c(512, Polynom(2048));
  for (int i = 0; i &lt; n; i++) c[b[i]][a[i]]++;
  for (auto &amp;v : c) dft(v);
  for (int j = 0; j &lt; 2048; j++) {
    Polynom d(512);
    for (int i = 0; i &lt; 512; i++) d[i] = c[i][j];
    fwt(d);
    for (int i = 0; i &lt; 512; i++) d[i] = 1LL * d[i] * d[i] % P * d[i] % P * d[i] % P;
    ifwt(d);
    for (int i = 0; i &lt; 512; i++) c[i][j] = d[i];
  }
  for (auto &amp;v : c) idft(v);
  int ans = 0;
  for (int i = 0; i &lt; 512; i++)
    for (int j = 0; j &lt; 2048; j++)
      ans = (ans + 1LL * c[i][j] * fpow(j, i)) % P;
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## F. Random XOR
&gt; 给定 $a_1, a_2, \dots, a_n$，随机从中选取一些数的异或和为 $s$，求 $s^2$ 的期望，对 $10^9+7$ 取模。
&gt; 
&gt; $n \leq 10^5$。

设 $s = \sum_{i\geq 0}b_i2^i$，则 
$$
\begin{aligned}
s^2 &amp;= \sum_{i, j}b_ib_j2^{i+j}\\
E(s^2) &amp;= \sum_{i, j}P(b_i \And b_j)2^{i+j} 
\end{aligned}
$$

$P(b_i \And b_j)$ 表示 $b_i, b_j$ 同时为 $1$ 的概率，可以 $O(n)$ 计算。

复杂度 $O(n \log^2(P))$。

```cpp
#include &lt;bits/stdc++.h&gt;

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int P(1e9 + 7);
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, t, m;
  std::cin &gt;&gt; n &gt;&gt; t &gt;&gt; m;
  m = 1LL * t * fpow(m) % P;
  std::vector&lt;int&gt; a(n);
  for (int &amp;x : a) std::cin &gt;&gt; x;
  int ans = 0;
  for (int i = 0, x = 1; i &lt;= 30; i++, x &lt;&lt;= 1)
    for (int j = 0, y = 1; j &lt;= 30; j++, y &lt;&lt;= 1) {
      std::array&lt;int, 4&gt; p;
      p[0] = 1, p[1] = 0, p[2] = 0, p[3] = 0;
      for (int &amp;x : a) {
        int v = (x &gt;&gt; i &amp; 1) &lt;&lt; 1 | (x &gt;&gt; j &amp; 1);
        p = {
          static_cast&lt;int&gt;((1LL * p[v ^ 0] * m + 1LL * p[0] * (1 - m)) % P),
          static_cast&lt;int&gt;((1LL * p[v ^ 1] * m + 1LL * p[1] * (1 - m)) % P),
          static_cast&lt;int&gt;((1LL * p[v ^ 2] * m + 1LL * p[2] * (1 - m)) % P),
          static_cast&lt;int&gt;((1LL * p[v ^ 3] * m + 1LL * p[3] * (1 - m)) % P)
        };
      }
      ans = (ans + 1LL * p[3] * x % P * y) % P;
    }
  std::cout &lt;&lt; (ans + P) % P &lt;&lt; &#34;\n&#34;;
  return 0;
}

```

## G. Sum of Distances in Cactus
&gt; 给定一棵边权为 1 的点仙人掌，求两点间最短路之和。
&gt; 
&gt; $n \leq 10^5$。

对每条边算贡献，对于每个环计算 $\sum_{i,j} s_is_j\min(|i-j|, len - |i-j|)$，前缀和优化即可。

```cpp
#include &lt;bits/stdc++.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
std::vector&lt;int&gt; g[N];
int n, in[N], low[N], cnt, fa[N], siz[N];
LL ans;
void dfs(int x) {
  in[x] = low[x] = ++cnt;
  siz[x] = 1;
  for (int y : g[x]) {
    if (y == fa[x]) continue;
    if (!in[y]) {
      fa[y] = x;
      dfs(y);
      siz[x] += siz[y];
      smin(low[x], low[y]);
    } else {
      smin(low[x], in[y]);
    }
    if (low[y] &gt; in[x]) {
      ans += 1LL * (n - siz[y]) * siz[y];
    }
  }
  for (int y : g[x]) {
    if (fa[y] == x || in[y] &lt; in[x]) continue;
    std::vector&lt;LL&gt; a, b;
    int p = 0;
    for (int i = y; i != x; i = fa[i]) {
      a.push_back(siz[i] - p);
      p = siz[i];
    }
    a.push_back(n - p);
    b.push_back(0);
    assert(*std::min_element(a.begin(), a.end()) &gt; 0);
    assert(std::accumulate(a.begin(), a.end(), 0) == n);
    for (int i = 1, n = a.size(); i &lt; n; i++) {
      LL a1 = a[i - 1], a2 = 0, b1 = b[i - 1], b2 = 0;
      if (i - n / 2 &gt; 0) a1 -= a2 = a[i - n / 2 - 1], b1 -= b2 = b[i - n / 2 - 1];
      ans += (a1 * i - b1 + a2 * (n - i) + b2) * a[i];
      b.push_back(b[i - 1] + i * a[i]);
      a[i] += a[i - 1];
    }
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int m;
  std::cin &gt;&gt; n &gt;&gt; m;
  while (m--) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    g[x].push_back(y), g[y].push_back(x);
  }
  dfs(1);
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}

```

## H. Not A + B
签到题。

## I. Cutting
&gt; 给一个整数，每次操作将这个数从中间切成两半，然后替换为差的绝对值，直到最后，求最终的最小值以及操作过程。
&gt;
&gt; $0 \leq x \leq 10^12$。

搜索，对于 $10^7$ 内的状态可以记忆化，大的状态数不多。

```cpp
#include &lt;bits/stdc++.h&gt;
using LL = long long;
using PR = std::pair&lt;int, LL&gt;;
PR &amp;get(LL i) {
    static PR f[10000000];
    static std::map&lt;LL, PR&gt; g;
    return i &lt; 10000000 ? f[i] : g[i];
}
template &lt;class T&gt;
inline int smin(T &amp;x, T y) {
    return y &lt; x ? x = y, 1 : 0;
}
PR dfs(LL i) {
    if (i &lt; 10) return PR(i, 0);
    auto &amp;v = get(i);
    if (v.first) return v;
    v = {10, 0};
    for (LL x = 10; i / x; x *= 10) {
        auto j = i / x - i % x;
        if (j &lt; 0) j = -j;
        if (j &amp;&amp; smin(v.first, dfs(j).first)) v.second = j;
    }
    return v;
}
int main() {
    int t;
    scanf(&#34;%d&#34;, &amp;t);
    while (t--) {
        LL x;
        scanf(&#34;%lld&#34;, &amp;x);
        std::vector&lt;LL&gt; v;
        for (LL o = x; o; o = dfs(o).second) v.push_back(o);
        printf(&#34;%d &#34;, (int)v.size());
        for (LL x : v) printf(&#34;%lld &#34;, x);
        printf(&#34;\n&#34;);
    }
    return 0;
}
```

## J. Paternity Testing

&gt; $n$ 个节点的有根树，$q$ 次询问区间 $[l, r]$ 中满足 $l \leq i, j \leq r, i \in subtree_j$ 的数对 $(i, j)$  的个数。
&gt;
&gt; $n, q \leq 50000$，强制在线。

考虑求不满足条件的个数，容易发现条件为两个子树不交，所以跑一下dfs序转化为 $in[i] &gt; out[j]$。

如果只有一次询问，把 $l\dots r$ 分别按 $in,out$ 排序后双指针扫描即可。

分块，设块长为 $T$，对于节点 $i$ 分别用双指针扫描预处理出每块中 $in[i] &gt; out[j]$ 和 $out[i] &lt; in[j]$ 的 $j$ 的个数 $g[i][b], h[i][b]$，复杂度 $O(n\log n + \frac{n^2}{T})$。

然后预处理块与块之间的区间答案，$ans[u][v] = \sum_{i = l}^{r} \sum_{j = u}^v g[i][j]$，用前缀和可以做到 $O(\frac{n^2}{T})$。

对于每一次询问，区间分成两个部分：中间连续的块和两边的散点。

块之间的贡献已经预处理，散点自己的贡献可以双指针求出，散点和块的贡献可以根据 $g, h$ 的前缀和计算，复杂度 $O(T\log T)$。

总复杂度 $O(n \log n + \frac{n^2}{T} + qT\log T)$，取 $T = \frac{n}{\sqrt{q}}$ 可过。

```cpp
#include &lt;bits/stdc++.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(5e4 + 5);
std::vector&lt;int&gt; g[N], h[N];
int in[N], out[N];
void dfs(int x) {
  static int cnt;
  in[x] = ++cnt;
  for (int y : g[x]) dfs(y);
  out[x] = cnt;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, q;
  std::cin &gt;&gt; n;
  for (int i = 2, x; i &lt;= n; i++) {
    std::cin &gt;&gt; x;
    g[x].push_back(i);
  }
  std::cin &gt;&gt; q;
  dfs(1);
  int t = n / sqrt(q), m = (n - 1) / t + 1;
  std::vector&lt;int&gt; pin(n), pout;
  std::iota(pin.begin(), pin.end(), 1);
  pout = pin;
  auto cmp = [](int *p) {
    return [p](int i, int j) {
      return p[i] &lt; p[j];
    };
  };
  std::sort(pin.begin(), pin.end(), cmp(in));
  std::sort(pout.begin(), pout.end(), cmp(out));
  auto block = [&amp;](int i) { return (i - 1) / t; };
  std::vector&lt;int&gt; cnt(m);
  for (int i = 0, j = 0; i &lt; n; i++) {
    int x = pin[i];
    for (; out[pout[j]] &lt; in[x]; j++) cnt[block(pout[j])]++;
    g[x] = cnt;
  }
  for (auto &amp;x : cnt) x = 0;
  for (int i = n - 1, j = i; i &gt;= 0; i--) {
    int x = pout[i];
    for (; out[x] &lt; in[pin[j]]; j--) cnt[block(pin[j])]++;
    h[x] = cnt;
  }
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt; m; j++) g[i][j] += g[i][j - 1];
  }
  for (int i = 1; i &lt;= n; i++) {
    for (int j = 1; j &lt; m; j++) h[i][j] += h[i][j - 1];
  }
  std::vector&lt;std::vector&lt;LL&gt;&gt; sum(m), iBlockAns(m);
  for (int i = 0; i &lt; m; i++) {
    sum[i].resize(n + 1);
    for (int j = 1; j &lt;= n; j++) sum[i][j] = g[j][i] + sum[i][j - 1];
  }
  for (int i = 0; i &lt; m; i++) {
    iBlockAns[i].resize(i + 1);
    int r = i == m - 1 ? n : i * t + t;
    LL now = 0;
    for (int j = i, l = i * t + 1; j &gt;= 0; j--, l -= t) {
      for (int k = l; k &lt; l + t &amp;&amp; k &lt;= r; k++) {
        now += g[k][i];
      }
      iBlockAns[i][j] = now;
      if (j) iBlockAns[i][j] -= sum[j - 1][r] - sum[j - 1][l - 1];
    }
  }
  LL ans = 0;
  while (q--) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    l = (l ^ ans) % n + 1;
    r = (r ^ ans) % n + 1;
    if (l &gt; r) std::swap(l, r);
    ans = 1LL * (r - l + 1) * (r - l) / 2 + r - l + 1;
    int bl = block(l), br = block(r);
    pin.clear();
    if (bl == br) {
      for (int i = l; i &lt;= r; i++) pin.push_back(i);
    } else {
      for (int i = l, k = std::min(bl * t + t, n); i &lt;= k; i++) pin.push_back(i);
      for (int i = br * t + 1; i &lt;= r; i++) pin.push_back(i);
    }
    pout = pin;

    std::sort(pin.begin(), pin.end(), cmp(in));
    std::sort(pout.begin(), pout.end(), cmp(out));
    for (int i = 0, j = 0; i &lt; pin.size(); i++) {
      while (out[pout[j]] &lt; in[pin[i]]) j++;
      ans -= j;
    }
    if (bl + 1 &lt;= br - 1) {
      bl++, br--;
      ans -= iBlockAns[br][bl];
      for (int i : pin) {
        ans -= g[i][br] - g[i][bl - 1];
        ans -= h[i][br] - h[i][bl - 1];
      }
    } 
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## K. Chess Positions
- https://blog.asukakyle.top/post/gym102441/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces955D]Scissors</title>
        <link>https://blog.asukakyle.top/post/codeforces955dscissors/</link>
        <pubDate>Fri, 26 Mar 2021 17:56:38 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codeforces955dscissors/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codeforces955dscissors/ -

&gt; 给定两个串 $s,t$ 整数 $k$ ,你可以在 $s$ 中取出任意的两个不相交的长度为 $k$ 串，将它们按顺序拼在一起形成一个新串。
&gt;
&gt; 求一种取串的方案使得 $t$ 是新串的子串。
&gt;
&gt; $|s|,|t| \leq 5 \times 10^5$。

kmp 算出正串和反串的能匹配 $t$ 的前/后缀最大长度。

设 $s$ 串的前缀 $[pre_1 \dots pre_i]$ 能匹配 $t$ 的前缀集合为 $P$，后缀 $[suf_{i+1},suf_n]$ 能匹配 $t$ 的后缀集合为 $Q$，只要判断是否存在 $x\in P,y\in Q,x, y\leq k,x+y=|s|$ 即可。

类似 AC 自动机那样建出 fail 树，那么一个点能匹配的前缀长度集合就是在 fail 树上到根的路径，在正串 fail 树上维护集合 $P$，每次添加一个数 $x$ 时，标记 $k-x$ 对应在反串 fail 树上的点，每次查询反串 fail 树上一个点的祖先是否被标记。

具体实现时，标记一个点可以用子树加一，查询的时候单点查询即可。

复杂度 $O(n \log n)$。

```cpp
#include &lt;bits/stdc++.h&gt;
#define dbg(...) std::cerr &lt;&lt; &#34;\033[32;1m&#34;, fprintf(stderr, __VA_ARGS__), std::cerr &lt;&lt; &#34;\033[0m&#34;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }
using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e6 + 5);

int n, m, k;
std::vector&lt;int&gt; g[N];
int in[N], out[N], cnt;
void dfs(int x) {
  in[x] = ++cnt;
  for (int y : g[x]) {
    dfs(y);
  }
  out[x] = cnt;
}
int c[N];
void add(int p, int x) {
  for (; p &lt;= cnt; p += p &amp; -p) {
    c[p] += x;
  }
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) {
    r += c[p];
  }
  return r;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::string s, t;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; s &gt;&gt; t;
  std::vector&lt;int&gt; p(m), q(m + n + 1); 
  p[0] = -1;
  for (int i = 1, j; i &lt; m; i++) {
    for (j = p[i - 1]; j &gt;= 0 &amp;&amp; t[j + 1] != t[i]; j = p[j]) ;
    p[i] = j + (t[j + 1] == t[i]);
  }
  q[m - 1] = m;
  g[m].push_back(m - 1);
  for (int i = m - 2, j; i &gt;= 0; i--) {
    for (j = q[i + 1]; j &lt; m &amp;&amp; t[j - 1] != t[i]; j = q[j]) ;
    q[i] = j - (t[j - 1] == t[i]);
    g[q[i]].push_back(i);
  }
  for (int i = n - 1, j = m; i &gt;= 0; i--) {
    for (; j &lt; m &amp;&amp; t[j - 1] != s[i]; j = q[j]) ;
    j -= t[j - 1] == s[i];  
    if (j == 0) {
      if (i &gt;= n - k &amp;&amp; k - 1 &lt; n - k) {
        std::cout &lt;&lt; &#34;Yes\n&#34; &lt;&lt; 1 &lt;&lt; &#34; &#34; &lt;&lt; n - k + 1 &lt;&lt; &#34;\n&#34;;
        return 0;
      }
      j = q[j];
    }
    g[j].push_back(i + m + 1);
    q[i + m + 1] = j;
  }
  dfs(m);
  std::vector&lt;int&gt; vis(m);
  for (int i = 0, j = -1; i &lt; n - k; i++) {
    for (; j &gt;= 0 &amp;&amp; t[j + 1] != s[i]; j = p[j]) ;
    j += t[j + 1] == s[i];
    if (j == m - 1) {
      if (i &lt; k &amp;&amp; k - 1 &lt; n - k) {
        std::cout &lt;&lt; &#34;Yes\n&#34; &lt;&lt; 1 &lt;&lt; &#34; &#34; &lt;&lt; n - k + 1 &lt;&lt; &#34;\n&#34;;
        return 0;
      }
      j = p[j];
    }
    if (i &lt; k - 1) continue;
    for (int k = j; k &gt;= m - ::k - 1 &amp;&amp; vis[k] &lt;= 0; k = p[k]) {
      vis[k] = i + 1;
      if (k &lt; ::k) {
        add(in[k + 1], 1), add(out[k + 1] + 1, -1);
      } else {
        vis[k] = -vis[k];
      }
    }
    if (ask(in[i + m + 2])) {
      std::cout &lt;&lt; &#34;Yes\n&#34;;
      int x = q[i + m + 2];
      for (; x &lt; m &amp;&amp; vis[x - 1] &lt;= 0; x = q[x]) ;
      std::cout &lt;&lt; vis[x - 1] - k + 1 &lt;&lt; &#34; &#34; &lt;&lt; i + 2 &lt;&lt; &#34;\n&#34;;
      return 0;
    }
  }
  std::cout &lt;&lt; &#34;No\n&#34;;
  return 0;
}
```
- https://blog.asukakyle.top/post/codeforces955dscissors/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>数论知识总结</title>
        <link>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 19 Mar 2021 10:28:29 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ -
## 1 欧几里得算法

&gt; 欧几里得算法可以求两个数的最大公约数 $\gcd(a, b)$。

不妨设 $a \geq b, a = kb + r(k \geq 1, 0 \leq r &lt; b)$。

一方面，设 $d_1$ 为 $a, b$ 的一个公约数，则
$$
\begin{aligned}
a &amp;= k_ad_1\\
b &amp;= k_bd_1\\
r &amp;= a - kb\\
  &amp;= (k_a - kk_b)d_1
\end{aligned}
$$
即 $d_1$ 也是 $r$ 的约数，$b, r$ 的公约数。

另一方面，设 $d_2$ 为 $b, r$ 的一个公约数，则
$$
\begin{aligned}
b &amp;= k&#39;_bd_2\\
r &amp;= k_r&#39;d_2\\
a &amp;= kb + r\\
  &amp;= (kk&#39;_b + k_r&#39;)d_2
\end{aligned}
$$
即 $d_2$ 也是 $a$ 的约数，$a, b$ 的公约数。

所以 $a, b$ 的公约数集合和 $b, r$ 的公约数集合相同，于是 $\gcd(a, b) = \gcd(b, r) = \gcd(b, a \bmod b)$

递归求解，终止状态为 $b = 0$，此时原 $a, b$ 的公约数集合为 $a$ 的约数集合。

因为 $a = kb + r &gt; (k + 1)r$ 所以 $r &lt; \frac{a}{k + 1} \leq \frac{a}{2}$，所以每次 $a$ 最少折半，算法复杂度为 $O(\log a + \log b)$。

```cpp
int gcd(int a, int b) {
  return b ? gcd(b, a % b) : a;
}
```

## 2 裴蜀定理
&gt; 设 $a, b$ 是不全为零的整数，则存在整数 $x, y$ 使得 $ax + by = \gcd(a, b)$。

### 2.1 拓展欧几里得算法

&gt; 拓展欧几里得算法可以求方程 $ax + by = g$ 的一组解，其中 $g = \gcd(a, b)$。

不妨设 $a \geq b, a = kb + r(k \geq 1, 0 \leq r &lt; b)$。

$$
\begin{aligned}
g &amp;= ax + by \\
  &amp;= (kb + r)x + by \\
  &amp;=  b(kx + y) + rx\\
  &amp;= bx&#39; + ry&#39; \\
\end{aligned}
$$

假设我们已经得出方程 $bx + ry = g$ 的一组解 $x&#39;, y&#39;$，那么原方程的解可以表示为：
$$
\begin{cases}
x &amp;= y&#39;\\
y &amp;= x&#39; - ky&#39;
\end{cases}
$$

可以在欧几里得算法的递归中完成，$a = g, b = 0$ 时显然 $x = 1, y = 0$ 是一组解。

```cpp
int exgcd(int a, int b, int &amp;x, int &amp;y) {
  if (!b) return x = 1, y = 0, a;
  int g = exgcd(b, a % b, y, x);
  y -= a / b * x;
  return g;
}
```

假设用该算法得出一组特解 $(x_0, y_0)$，那么通解为 $(x_0 + k\dfrac b g, y_0 - k\dfrac a g)$。

&gt; **推论：** 方程 $ax + by = c$ 有解的充分必要条件是 $\gcd(a, b) \mid c$。
&gt; 
&gt; **证明：**
&gt; 充分性由裴蜀定理可得证。
&gt; 
&gt; 必要性：设 $\gcd(a, b) = g, a = ug, b = vg$，则 $c = g(ux + vy)$，所以 $g \mid c$。$\square$

因此，对于方程 $ax + by = c$，首先用欧几里得算法求出 $ax+by=g$ 的一组解 $(x_0, y_0)$，则

原方程的一组特解为 $(\dfrac cg x_0, \dfrac cg y_0)$，通解为 $(\dfrac cg x_0 + k\dfrac bg, \dfrac cg y_0 - k \dfrac a g)$。

### 2.2 线性同余方程
&gt; 形如 $ax \equiv b \pmod c$ 的方程称为线性同余方程。

求解线性同余方程可以使用拓展欧几里得算法：

原方程等价于 $ax - b = cy$，即 $ax - cy = b$。

由 *裴蜀定理的推论* 得知方程有解当且仅当 $\gcd(a, c) \mid b$，此时可以用拓展欧几里得算法求解。

### 2.3 乘法逆元
&gt; 若 $ax \equiv 1 \pmod b$，则 $x$ 称为 $a \bmod b$ 的乘法逆元，简称逆元，记作 $a^{-1}$。

求解上述线性方程组即可求出单个整数 $a$ 的乘法逆元。

#### 2.3.1 线性递推逆元
&gt; 求 $1 \dots n \bmod p$ 的乘法逆元。

设 $p = kn + r$，则
$$
\begin{aligned}
kn + r &amp;\equiv 0 &amp;\pmod p\\
r^{-1}(kn + r) &amp;\equiv 0 &amp;\pmod p\\
r^{-1}kn + 1 &amp;\equiv 0 &amp;\pmod p\\
n^{-1} &amp;\equiv -r^{-1}k &amp;\pmod p
\end{aligned}
$$
得到线性递推式
$$
n^{-1} \equiv
\begin{cases}
1, &amp; n = 1\\
-\lfloor\frac p n \rfloor (p \bmod n)^{-1}, &amp; n &gt; 1
\end{cases}
\pmod p
$$

## 3 费马小定理
&gt; 设 $p$ 是质数，$a$ 是任意整数且 $a \not\equiv 0 \pmod p$，则 
&gt; $$
&gt; a^{p - 1} \equiv 1 \pmod p
&gt; $$

&gt; **引理3.1** 若 $p \mid ab, \gcd(p, a) = 1$，则 $p \mid b$。
&gt; 
&gt; **证明：**
&gt; 根据 *裴蜀定理* 方程 $px + ay = 1$ 有整数解 $(x_0, y_0)$。
&gt; 
&gt; 所以，$b = pbx_0 + aby_0 = p(bx_0 + \frac{ab}{p})$。
&gt; 
&gt; 又因为 $p \mid ab$ 所以 $p \mid b$。 $\square$

&gt; **引理3.2** 设 $p$ 是质数，$a$ 是任意整数且 $a \not\equiv 0 \pmod p$，则数 $a, 2a, 3a, \dots, (p - 1)a \pmod p$ 是 $1 \dots p - 1$ 的一个排列。
&gt; 
&gt; **证明：** 
&gt; 因为 $p \nmid a$ 所以 $ia$ 的值只可能在 $1$ 和 $p - 1$ 间，下面证明他们两两不同。
&gt; 
&gt; 假设 $1 \leq j, k \leq p - 1, ja \equiv ka \pmod p$，则 $p \mid (j - k)a$。
&gt; 
&gt; 因为假设 $p \nmid a$，所以 $p \mid (j - k)$ (*引理3.1*)。
&gt; 
&gt; 又 $2 - p \leq j - k\leq p - 2$，所以 $j - k = 0$。
&gt; 
&gt; 所以数 $a, 2a, 3a, \dots, (p - 1)a \pmod p$ 两两不同。$\square$

**证明：**
由 *引理3.2* 
$$
\begin{aligned}
\prod_{i = 1}^{p - 1} ia \equiv (p - 1)! \pmod p\\
a^{p - 1} (p - 1)! \equiv (p - 1)! \pmod p\\
p \mid \left(a^{p -1} - 1\right)(p - 1)!
\end{aligned}
$$
因为 $p \nmid (p-1)!$，所以 $p \mid (a^{p - 1} - 1)$ (*引理3.1*)，即 $a^{p - 1} \equiv 1 \pmod p$。$\square$

用费马小定理可以求模质数的逆元：
$$
\begin{aligned}
a \cdot a^{p - 2} &amp;\equiv 1 &amp;\pmod p\\
a^{-1} &amp;\equiv a^{p - 2} &amp;\pmod p
\end{aligned}
$$

## 4 中国剩余定理(Chinese Remainder Theorem)
&gt; 设整数 $m_1, m_2, \dots, m_n$ 其中 **任两数** 互质，$M = \prod_{i = 1}^nm_i, M_i = \frac{M}{m_i}$，则对任意正整数 $a_1, a_2, \dots, a_n$，线性同余方程组
&gt; $$
&gt; \begin{cases}
&gt; x &amp;\equiv a_1 \pmod {m_1} \\
&gt; x &amp;\equiv a_2 \pmod {m_2} \\
&gt; &amp;\vdots \\
&gt; x &amp;\equiv a_n \pmod {m_n}
&gt; \end{cases}
&gt; $$
&gt; 在模 $M$ 意义下有唯一解
&gt; $$
&gt; x \equiv \sum_{i = 1}^{n} a_iM_iv_i \pmod M
&gt; $$
&gt; 其中 $M_iv_i \equiv 1 \pmod {m_i}$

**证明：**
将 $x$ 代入各同余方程，显然都成立。

另外，假设 $x_1$ 和 $x_2$ 都是方程组的解，那么

$$
\forall i \in \{1, 2, \cdots , n\},  x_1 - x_2 \equiv 0 \pmod {m_i}
$$

因为 $m_1, m_2, \ldots, m_n$ 两两互质，所以 $x_1 - x_2 \equiv 0 \pmod M$，所以方程组在模 $M$ 意义下有唯一解。$\square$

```cpp
int n;
std::cin &gt;&gt; n;
std::vector&lt;int&gt; a(n), m(n);
LL p = 1;
for (int i = 0; i &lt; n; i++) {
  std::cin &gt;&gt; m[i] &gt;&gt; a[i];
  p *= m[i];
}
LL ans = 0;
for (int i = 0; i &lt; n; i++) {
  int x, y;
  exgcd(p / m[i] % m[i], m[i], x, y);
  ans = (ans + p / m[i] * a[i] * x) % p;
}
std::cout &lt;&lt; (ans + p) % p &lt;&lt; &#34;\n&#34;;
```
### 4.1 拓展中国剩余定理
&gt; 当 $m_1, m_2, \dots, m_n$ 不满足两两互质时，中国剩余定理失效（因为 $v_i$ 可能不存在），可以通过合并同余方程的方式解决。

考虑线性同余方程组
$$
\begin{cases}
x &amp;\equiv a_1 &amp;\pmod{m_1}\\
x &amp;\equiv a_2 &amp;\pmod{m_2}
\end{cases}
$$
由第一个方程得 $x = a_1 + k_1m_1$，代入第二个方程，$a_1 + k_1m_1 \equiv a_2 \pmod{m_2}$，即 $k_1m_1 + k_2m_2 = a_2 - a_1$。

由 *裴蜀定理的推论* 得知方程有解当且仅当 $\gcd(m_1, m_2) \mid (a_2 - a_1)$，此时可以用拓展欧几里得算法求解 $k_1, k_2$。

假设求出 $k_1$ 的通解为 $k_1 = k_0 + t\dfrac{m_2}{\gcd(m_1, m_2)}$，则 $x = a_1 + k_1m_1 = a_1 + k_0m_1 + t\dfrac{m_1m_2}{\gcd(m_1, m_2)}$，即
$$
x \equiv a_1 + k_0m_1 \pmod{\operatorname{lcm}(m_1, m_2)}
$$

这样我们把两个同余方程合并成了一个，重复上述操作即可求出原方程组的解。


## 5 欧拉函数
&gt; 欧拉函数 $\varphi(m)$ 表示在 $1$ 到 $m$ 之间与 $m$ 互素的数的个数。即
&gt; $$
&gt; \varphi(m) = |\{x | \gcd(x, m) = 1, 1 \leq x \leq m\}|
&gt; $$

### 5.1 欧拉函数公式
&gt; ① 如果 $p$ 为素数且 $k \geq 1$ 则 $\varphi(p^k) = p^k - p^{k - 1}$。
&gt; 
&gt; ② 如果 $\gcd(m, n) = 1$，则 $\varphi(mn) = \varphi(m)\varphi(n)$。

**证明：**

① 只有 $p, 2p, 3p, \dots, (p^{k - 1} -1)p, p^k$ 和 $p^k$ 不互素，所以 $\varphi(p^k) = p^k - p^{k - 1}$。

② 设
$$
A = \{a | 1 \leq a \leq mn, \gcd(a, mn) = 1\}
$$
$$
B = \left\{(b, c) | 
\begin{aligned}
&amp;1 \leq b \leq m,\gcd(b, m) = 1,\\
&amp;1 \leq c \leq n,\gcd(c, n) = 1
\end{aligned}
\right\}
$$
则 $|A| = \varphi(mn), |B| = \varphi(m)\varphi(n)$。

一方面，对于 $A$ 中的任意元素 $a$，因为 $m, n$ 互质，所以 $\gcd(a, m) = \gcd(a, n) = 1$。

所以 $\gcd(a \bmod m, m) = \gcd(a \bmod n, n) = 1$。

所以 $(a \bmod m, a \bmod n)$ 一定在集合 $B$ 中。

假设存在 $a_1, a_2$ 使得 $(a_1 \bmod m, a_1 \bmod n) = (a_2 \bmod m, a_2 \bmod n)$，则 $m \mid (a_1 - a_2), n \mid (a_1 - a_2)$。

又因为 $m, n$ 互质，所以 $mn \mid (a_1 - a_2)$，而 $a_1, a_2 &lt; mn$，所以 $a_1 = a_2$。

另一方面，对于 $B$ 中的任意元素 $(b, c)$，根据中国剩余定理，在模 $mn$ 意义下必定存在唯一的 $x$ 满足

$$
\begin{cases}
&amp;x \equiv b \pmod m\\
&amp;x \equiv c \pmod n
\end{cases}
$$

因为 $\gcd(x, m) = \gcd(b, m) = 1, \gcd(x, n) = \gcd(c, n) = 1$，所以 $\gcd(x, mn) = 1$，即 $x$ 在集合 $A$ 中。

综上我们建立了集合 $A, B$ 之间的单射，所以 $|A| = |B|$，即 $\varphi(mn) = \varphi(m)\varphi(n)$。$\square$

&gt; ③ 设整数 $m$ 可以分解为素数的乘积 $m = p_1^{k_1}p_2^{k_2}\dots p_r^{k_r}$（由算数基本定理得知这样的分解存在且唯一，这在后文会给出证明），则 
&gt; $$
&gt; \varphi(m) = m\prod_{i=1}^{r}(1 - \frac{1}{p_i})
&gt; $$

**证明：**
由①②得
$$
\begin{aligned}
\varphi(m) &amp;= \prod_{i=1}^r\varphi(p_i^{k_i})\\
        &amp;= \prod_{i=1}^rp_i^{k_i}(1 - \frac{1}{p_i})\\
        &amp;= m\prod_{i=1}^{r}(1 - \frac{1}{p_i})
\end{aligned}
$$
$\square$

### 5.2 欧拉定理
&gt; 如果 $\gcd(a, m) = 1$，则
&gt; $$
&gt; a^{\varphi(m)} \equiv 1 \pmod m
&gt; $$
&gt; 

类似费马小定理的证明，取在 $1$ 到 $m$ 之间与 $m$ 互素的数分别与 $a$ 相乘即可。

### 5.3 拓展欧拉定理
&gt; $$
&gt; a^b\equiv
&gt; \begin{cases}
&gt; a^{b\ \bmod\ \varphi(p)},&amp;\gcd(a,p)=1\\
&gt; a^b,&amp;\gcd(a,p)\ne1,b&lt;\varphi(p)\\
&gt; a^{b\ \bmod\ \varphi(p)\ +\ \varphi(p)},&amp;\gcd(a,p)\ne1,b\ge\varphi(p) 
&gt; \end{cases} \pmod p
&gt; $$

证明较复杂，这里不给出。

## 6 素数
### 6.1 无穷多素数定理
&gt; 存在无穷多个素数。

**证明：**
设当前已找到素数 $p_1, p_2, \dots, p_r$，下面证明总可以找到另外的素数。

令
$$
A = p_1p_2\dots p_r + 1
$$
若 $A$ 本身是素数，则证明已完成，否则存在一个素数 $q$ 整除 $A$。

如果 $q$ 是 $p_1p_2\dots p_r$ 中的一个，那么 $A \equiv 1 \pmod q$，矛盾，所以 $q$ 是一个新素数。
$\square$

### 6.2 算术级数的素数狄利克雷定理
&gt; 设 $\gcd(a, m) = 1$，则存在无穷多个素数满足
&gt; $$
&gt; p \equiv a \pmod m
&gt; $$

### 6.3 素数定理
&gt; 设 $\pi(x)$ 表示小于 $x$ 的素数个数，则
&gt; $$
&gt; \lim_{x \to \infty}\frac{\pi(x)}{x / \ln(x)} = 1
&gt; $$

### 6.4 算数基本定理（唯一分解定理）
&gt; 设整数 $n \geq 2$，则 $n$ 可以唯一分解成素数的乘积
&gt; $$
&gt; n = p_1p_2\dots p_r(p_1 \leq p_2 \leq \dots \leq p_r)
&gt; $$

分解的唯一性并不是显然的，因此有必要对这个定理给出证明。
证明分为下面两个部分。

&gt; 断言1：$n$ 可以分解成素数的乘积。

**证明：**
$(1)$ $n = 2, 3$ 时显然成立。

$(2)$ 假设 $n \leq N$ 可分解为素数的乘积。
对于 $N + 1$，若它已经是素数，则证明完成。

否则 $N + 1$ 是合数，这说明它可以分解成 $N + 1 = n_1n_2, 2 \leq n_1, n_2 \leq N$，由归纳假设，$n_1, n_2$ 都可以表示成素数的乘积，因此 $N+1$ 也可以表示成素数的乘积。

由 $(1)(2)$ 归纳得知断言1成立。$\square$

&gt; 断言2：$n$ 的素数分解是唯一的。

**证明：**
假设 $n$ 能分解成两种形式的素数乘积
$$
n = p_1p_2\dots p_r = q_1q_2\dots q_s
$$
根据 *引理3.1*，因为 $p_1 | q_1q_2\dots q_s$，所以 $p_1$ 整除 $q_1, q_2, \dots, q_s$ 其中的某一个，设为 $q_k$。

因为 $p_1, q_k$ 均为素数，所以 $p_1 = q_k$，于是可以将它从等式两边除去。重复上述操作 $r$ 次，最终只可能剩下等式 $1 = 1$，于是 $r = s, p_i = q_i$。$\square$


### 6.5 梅森素数和完全数

&gt; 如果对整数 $a \geq 2, n \geq 2, a^n-1$ 是素数，则 $a = 2$ 且 $n$ 为素数。
&gt; 
&gt; 形如 $2^p-1$ 的素数被称为梅森素数。

**证明：**
当 $a &gt; 2$ 时，因为
$$
a^n-1 = (a - 1)(a^{n-1}+a^{n-2}+\dots+a^2+a+1)
$$
所以 $a^n-1$ 有约数 $a - 1$，是合数。

当 $n$ 是合数时，设 $n = mk$，则
$$
2^n - 1 = \left(2^{m}\right)^k - 1 = (2^m - 1)(2^{m(k-1)}+2^{m(k-2)}+\dots+2^{m}+1)
$$
所以 $2^n-1$ 有约数 $2^m - 1$，是合数。$\square$

&gt; 真因数之和等于本身的正整数称为完全数。（真因数即除了本身以外的因数）

梅森素数和完全数有很大的相关性：

&gt; **6.4.1 欧几里得完全数公式**
&gt; 如果 $2^p-1$ 是素数，则 $2^{p-1}(2^p-1)$ 是完全数。
&gt; 
&gt; **6.4.2 欧拉完全数定理**
&gt; 如果 $n$ 是**偶完全数**，则 $n = 2^{p-1}(2^p-1)$，其中$2^p-1$ 是梅森素数。

至今没有人发现有奇完全数。

### 6.6 Miller-Rabin 素性测试

### 6.7 Pollard-Rho 质因数分解


## 7 二项式系数
### 7.1 模 p 二项式定理
&gt; 设 $p$ 为素数，
&gt; 
&gt; ①
&gt; $$
&gt; \binom{p}{k} \equiv \begin{cases}
&gt; 0, &amp; 1 \leq k \leq p - 1\\
&gt; 1, &amp; k = 0 \text{ or } k = p
&gt; \end{cases}
&gt; \pmod p
&gt; $$
&gt; ②
&gt; 对任意数 $A, B$，有
&gt; $$
&gt; (A + B)^p \equiv A^p + B^p \pmod p
&gt; $$

**证明：**
① $\dbinom{p}{k} = \dfrac{p^{\underline{k}}}{k!}$

当 $1 \leq k \leq p - 1$ 时，由于 $p$ 是质数，分子上的 $p$ 不会被约去，所以 $\dbinom{p}{k}\equiv 0 \pmod p$；

当 $k = 0$ 或 $k = p$ 时，$\binom{p}{k} = 1$。

② 用二项式定理展开再套用①的公式即得证。$\square$

### 7.2 Lucas 定理
&gt; 设 $p$ 为素数，
&gt; $$
&gt; \binom n m \equiv \binom{\lfloor n / p \rfloor}{\lfloor m / p \rfloor} \binom{n \bmod p}{m \bmod p} \pmod p
&gt; $$

**证明：**
$$
(1 + x)^p = 1 + \binom{p}{1}x + \binom{p}{2}x^2 + \dots + \binom{p}{p}x^p
$$

由 *模 p 二项式定理* 有
$$
\begin{aligned}
(1 + x)^p &amp;\equiv 1 + x^p &amp;\pmod p\\
(1 + x)^{p^k} &amp;\equiv (1 + x^p)^{p^{k - 1}} \equiv \dots \equiv 1 + x^{p^k} &amp;\pmod p
\end{aligned}
$$

设
$$
\begin{cases}
n &amp;= \sum_{i \geq 0}a_ip^i\\
m &amp;= \sum_{i \geq 0}b_ip^i
\end{cases}
$$
则
$$
\begin{aligned}
(1 + x)^n = \prod_{i \geq 0} (1 + x)^{a_ip^i} 
&amp;\equiv \prod_{i \geq 0}(1 + x^{p^i})^{a_i} &amp;\pmod p\\
[x^m](1 + x)^n &amp;\equiv [x^m]\prod_{i \geq 0}(1 + x^{p^i})^{a_i} &amp;\pmod p\\
\binom{n}{m} &amp;\equiv \prod_{i \geq 0} \binom{a_i}{b_i} &amp;\pmod p
\end{aligned}
$$

$\square$

### 7.3 拓展 Lucas 定理
&gt; 对于 $p$ 是合数的情形，Lucas 定理失效，此时可以通过另外的方法求二项式系数对 $p$ 的模。思路如下：
&gt; 
&gt; 将 $p$ 质因数分解为 $p = \sum_{i = 1}^{r} q_i^{k_i}$，分别求出 $\dbinom{n}{m} \bmod q_i^{k_i}$，然后用中国剩余定理合并。

通常二项式系数的计算式为 $\dbinom{n}{m} = \dfrac{n!}{m!(n - m)!}$，需要求出 $m!(n-m)!$ 的逆元，然而在 $q_i \mid m!(n - m)!$ 的情况下逆元不存在，需要特殊处理。

设 $n = q^{r(n)}k(n)$，其中 $k \nmid q$，则 
$$
\binom{n}{m} = \frac{n!}{m!(n - m)!} = \frac{n!}{k(m!)k((n-m)!)}\cdot q^{-r(m) - r(n - m)}
$$
这样逆元都是存在的，问题在于求 $r(n!)$。

**太毒瘤了，咕咕咕……**

### 7.4 Kummer 定理
&gt; $\dbinom{n + m}{m}$ 中素因子 $p$ 的个数等于 $n, m$ 在 $p$ 进制下做加法的进位次数。

例题 [CF582D](https://www.luogu.com.cn/problem/CF582D)

## 8 二次剩余
直接拖了 yosupo 的板子。
```cpp
namespace SqrtMod {
using Int = long long;
// a^-1 (mod m)
//   m &gt; 0
Int modInv(Int a, Int m) {
  Int b = m, x = 1, y = 0, t;
  for (; ; ) {
    t = a / b; a -= t * b;
    if (a == 0) {
      assert(b == 1 || b == -1);
      if (b == -1) y = -y;
      return (y &lt; 0) ? (y + m) : y;
    }
    x -= t * y;
    t = b / a; b -= t * a;
    if (b == 0) {
      assert(a == 1 || a == -1);
      if (a == -1) x = -x;
      return (x &lt; 0) ? (x + m) : x;
    }
    y -= t * x;
  }
}
// Jacobi symbol (a/m)
//   m &gt; 0, m: odd
int jacobi(Int a, Int m) {
  int s = 1;
  if (a &lt; 0) a = a % m + m;
  for (; m &gt; 1;) {
    a %= m;
    if (a == 0) return 0;
    const int r = __builtin_ctz(a);
    if ((r &amp; 1) &amp;&amp; ((m + 2) &amp; 4)) s = -s;
    a &gt;&gt;= r;
    if (a &amp; m &amp; 2) s = -s;
    std::swap(a, m);
  }
  return s;
}

// sqrt(a) (mod p)
//   p: prime, p &lt; 2^31, -p^2 &lt;= a &lt;= P^2
//   (b + sqrt(b^2 - a))^((p+1)/2) in F_p(sqrt(b^2 - a))
std::vector&lt;Int&gt; sqrtMod(Int a, Int p) {
  static std::mt19937 rnd(1024);
  if (p == 2) return {a &amp; 1};
  const int j = jacobi(a, p);
  if (j == 0) return {0};
  if (j == -1) return {};
  Int b, d;
  for (;;) {
    b = rnd() % p;
    d = (b * b - a) % p;
    if (d &lt; 0) d += p;
    if (jacobi(d, p) == -1) break;
  }
  Int f0 = b, f1 = 1, g0 = 1, g1 = 0, tmp;
  for (Int e = (p + 1) &gt;&gt; 1; e; e &gt;&gt;= 1) {
    if (e &amp; 1) {
      tmp = (g0 * f0 + d * ((g1 * f1) % p)) % p;
      g1 = (g0 * f1 + g1 * f0) % p;
      g0 = tmp;
    }
    tmp = (f0 * f0 + d * ((f1 * f1) % p)) % p;
    f1 = (2 * f0 * f1) % p;
    f0 = tmp;
  }
  if (g0 &lt; p - g0) return {g0, p - g0};
  return {p - g0, g0};
}
} // namespace SqrtMod
```
## 9 离散对数
&gt; 求解同余方程 $a^x \equiv b \pmod p$。

### 9.1 大步小步算法(Baby Step Giant Step)
设 $\gcd(a, p) = 1$。

令 $x = kT - m(T = \lceil \sqrt p \rceil, 0 \leq m &lt; T)$。

原方程变为
$$a^{kT - m} \equiv b \pmod p$$

由于 $a, p$ 互质，$a$ 存在逆元，于是方程等价于
$$(a^T)^{k} \equiv ba^m \pmod p$$

把 $ba^m$ 的所有值插入哈希表，然后枚举 $k$ 即可。

复杂度 $O(\sqrt p)$。

### 9.2 EXBSGS
设 $\gcd(a, p) \neq 1$。

先验证 $x = 0$，下面假定 $x &gt; 0$。

设 $d = \gcd(a, p)$，当 $d \nmid b$ 时方程无解。

否则方程等价于
$$a^{x-1}\dfrac{a}{d} \equiv \dfrac{b}{d} \pmod {\dfrac{p}{d}}$$

重复此过程，直到底数和模数互质，此时可以用 `BSGS` 求解。

```cpp
void exgcd(LL a, LL b, LL &amp;x, LL &amp;y) {
  if (!b) {
    x = 1, y = 0;
  } else {
    exgcd(b, a % b, y, x);
    y -= a / b * x;
  }
}
int inv(int a, int p) {
  LL x, y;
  exgcd(a, p, x, y);
  return (x % p + p) % p;
}

int bsgs(int a, int b, int p) { // Assume: $0 \leq a, b &lt; p$
  if (b == 1 || p == 1) return 0;
  int d = std::gcd(a, p);
  if (d != 1) {
    if (b % d) return -1;
    p /= d;
    int ans = bsgs(a, 1LL * b / d * inv(a / d, p) % p, p);
    return ~ans ? ans + 1 : ans;
  }
  HashTable::Map mp;
  int t = sqrt(p) + 1, pw = 1;
  for (int i = 0; i &lt; t; i++, pw = 1LL * pw * a % p) {
    mp[1LL * pw * b % p] = i;
  }
  for (int i = 1, a = pw; i &lt;= t; i++, pw = 1LL * pw * a % p) {
    auto it = mp.find(pw);
    if (it != mp.end()) return i * t - it-&gt;second;
  }
  return -1;
}
```
## 10 阶和原根
**下面的内容大部分摘自 OI Wiki。**

### 10.1 阶
&gt; **阶**：由欧拉定理可知，对 $a\in \mathbf{Z}$，$m\in\mathbf{N}^{*}$，若 $\gcd(a,m)=1$，则 $a^{\varphi(m)}\equiv 1\pmod m$。
&gt;
&gt; 因此满足同余式 $a^n \equiv 1 \pmod m$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\delta_m(a)$。

&gt; **定理 10.1.1**：$a,a^2,\cdots,a^{\delta_m(a)}$ 模 $m$ 两两不同余。
&gt; 
&gt; **定理 10.1.2**：若 $a^n \equiv 1 \pmod m$，则 $\delta_m(a)\mid n$。
&gt; 
&gt; **推论**：若 $a^p\equiv a^q\pmod m$，则有 $p\equiv q\pmod{\delta_m(a)}$。

还有两个与四则运算有关的重要性质。

&gt; **定理 10.1.3**：设 $m\in\mathbf{N}^{*}$，$a,b\in\mathbf{Z}$，$\gcd(a,m)=\gcd(b,m)=1$，则
&gt;
&gt; $$
&gt; \delta_m(ab)=\delta_m(a)\delta_m(b)
&gt; $$
&gt;
&gt; 的充分必要条件是
&gt;
&gt; $$
&gt; \gcd\big(\delta_m(a),\delta_m(b)\big)=1
&gt; $$

**证明**：

**必要性**

由 $a^{\delta_m(a)}\equiv 1 \pmod m$ 及 $b^{\delta_m(b)} \equiv 1 \pmod m$，可知

$$
(ab)^{\operatorname{lcm}(\delta_m(a),\delta_m(b))}\equiv 1 \pmod m
$$

由前面所述阶的性质，有

$$
\delta_m(ab)\mid\operatorname{lcm}\big(\delta_m(a),\delta_m(b)\big)
$$

又由于 $\delta_m(ab)=\delta_m(a)\delta_m(b)$，故

$$
\delta_m(a)\delta_m(b)\mid\operatorname{lcm}\big(\delta_m(a),\delta_m(b)\big)
$$

即 $\gcd(\delta_m(a),\delta_m(b))=1$。

**充分性**

由 $(ab)^{\delta_m(ab)}\equiv 1 \pmod m$ 可知

$$
1 \equiv (ab)^{\delta_m(ab)\delta_m(b)}\equiv a^{\delta_m(ab)\delta_m(b)} \pmod m
$$

故 $\delta_m(a)\mid\delta_m(ab)\delta_m(b)$。结合 $\gcd(\delta_m(a),\delta_m(b))=1$ 即得

$$
\delta_m(a)\mid\delta_m(ab)
$$

对称地，同理可得

$$
\delta_m(b)\mid\delta_m(ab)
$$

所以

$$
\delta_m(a)\delta_m(b)\mid\delta_m(ab)
$$

另一方面，有

$$
(ab)^{\delta_m(a)\delta_m(b)}\equiv(a^{\delta_m(a)})^{\delta_m(b)}\times(b^{\delta_m(b)})^{\delta_m(a)}\equiv 1 \pmod m
$$

故

$$
\delta_m(ab)\mid\delta_m(a)\delta_m(b)
$$

综合以上两点即得

$$
\delta_m(ab)=\delta_m(a)\delta_m(b)
$$

$\square$

&gt; **定理 10.1.4**：设 $k \in \mathbf{N}$，$m\in \mathbf{N}^{*}$，$a\in\mathbf{Z}$，$\gcd(a,m)=1$，则
&gt;
&gt; $$
&gt; \delta_m(a^k)=\dfrac{\delta_m(a)}{\gcd\big(\delta_m(a),k\big)}
&gt; $$

**证明**：注意到：

$$
a^{k\delta_m(a^k)}=(a^k)^{\delta_m(a^k)}\equiv 1 \pmod m
$$

$$
\Rightarrow \delta_m(a)\mid k\delta_m(a^k)
$$

$$
\Rightarrow \dfrac{\delta_m(a)}{\gcd\big(\delta_m(a),k\big)}\mid\delta_m(a^k)
$$

另一方面，由 $a^{\delta_m(a)}\equiv 1 \pmod m$，可知：

$$
(a^k)^{\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}}=(a^{\delta_m(a)})^{\dfrac{k}{\gcd(\delta_m(a),k)}}\equiv 1 \pmod m
$$

故：

$$
\delta_m(a^k)\mid\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}
$$

综合以上两点，得：

$$
\delta_m(a^k)=\dfrac{\delta_m(a)}{\gcd(\delta_m(a),k)}
$$

$\square$

### 10.2 原根
&gt; **原根**：设 $m \in \mathbf{N}^{*}$，$a\in \mathbf{Z}$。若 $\gcd(a,m)=1$，且 $\delta_m(a)=\varphi(m)$，则称 $a$ 为模 $m$ 的原根。


#### 10.2.1 原根个数
&gt; 若一个数 $m$ 有原根，则它原根的个数为 $\varphi(\varphi(m))$。

#### 10.2.2 原根存在定理
&gt; **原根存在定理**：一个数 $m$ 存在原根当且仅当 $m=2,4,p^{\alpha},2p^{\alpha}$，其中 $p$ 为奇素数，$\alpha\in \mathbf{N}^{*}$。

#### 10.2.3 求原根
&gt; **原根判定定理**：若一个数 $g$ 是模 $m$ 的原根，则有对于 $\varphi(m)$ 任何大于 $1$ 且不为自身的因数 $p$，都有 $g^{\varphi(m)/p}\not\equiv 1\pmod m$。

&gt; **最小原根的数量级** 王元于 $1959$ 年证明了若 $m$ 有原根，其最小原根是不多于 $m^{0.25}$ 级别的。

于是可以从小到大枚举判定。

由 *定理 10.1.4* 可知，设 $g$ 为模 $m$ 的任意原根，$a = g^x$，则 $a$ 为模 $m$ 的原根当且仅当 $\gcd(x, \varphi(m)) = 1$。

所以可以枚举 $x$ 求出所有 $\varphi(\varphi(m))$ 个原根。

## 11 数论函数
### 11.1 积性函数
&gt; 若数论函数 $f$ 满足对于任意的 $a, b \in \mathbf{N}^*, \gcd(a, b) = 1$ 都有 $f(ab) = f(a)f(b)$，则称 $f$ 为积性函数。
&gt; 
&gt; 特别地，如果对于任意 $a, b \in \mathbf{N}^*$ 都满足上面的条件，则称 $f$ 为完全积性函数。

- https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces1413F]Roads and Ramen</title>
        <link>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</link>
        <pubDate>Fri, 19 Mar 2021 10:09:39 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/ -
&gt; 给定一棵 $n$ 个点的无根树，每条边都有标记0或1。现在有 $m$ 次操作，每次操作将第 $id$ 条边的标记异或1。在每次操作后输出当前树上最长的有偶数个1的路径长度。
&gt;
&gt; $n,m \leq 5 \times 10^5$。

## 动态DP

设 $dp[x][0/1]$ 表示 $x$ 向下有偶数/奇数个1的最长路径，$dp[x][2]$ 表示 $x$ 子树内偶数个1的直径。

容易写出转移（$val_y$ 表示 $y$ 的父边的权值）：
$$
\begin{aligned}
dp&#39;[x][0] &amp;= \max\{dp[x][0], dp[y][val_y] + 1\}\\
dp&#39;[x][1] &amp;= \max\{dp[x][1], dp[y][val_y \oplus 1] + 1\}\\
dp&#39;[x][2] &amp;= \max\{dp[x][0] + dp[y][val_y] + 1, dp[x][1] + dp[y][val_y \oplus 1] + 1, dp[x][2],dp[y][2]\}
\end{aligned}
$$
改写成 $x$ 从重儿子 $y$ 转移的矩阵（这里以 $val_y = 0$ 为例）：
$$
\begin{bmatrix}
dp&#39;[x][0]\\
dp&#39;[x][1]\\
dp&#39;[x][2]\\
0
\end{bmatrix}
=
\begin{bmatrix}
1 &amp; -\infty &amp; -\infty &amp; dp[x][0]\\
-\infty &amp; 1 &amp; -\infty &amp; dp[x][1]\\
dp[x][0] + 1 &amp; dp[x][1] + 1 &amp; 0 &amp; dp[x][2]\\
-\infty &amp; -\infty &amp; -\infty &amp; 0
\end{bmatrix}
\begin{bmatrix}
dp[y][0]\\
dp[y][1]\\
dp[y][2]\\
0
\end{bmatrix}
$$
上面的 $dp[x]$ 是指排除掉 $x$ 重儿子的答案，$dp&#39;[x]$ 是指完整的 $x$ 的答案。

$dp[x]$ 考虑直接用 `std::multiset` 存一下每个节点虚儿子的 $dp[y][0], dp[y][1], dp[y][2]$，取每个的最大和次大值即可快速求出。

复杂度是 $O(4^3 m \log n + m \log^2n)$，能跑过 $5 \times 10^5$ 也是奇迹。

**细节**：在 `multiset` 中删除 $-\infty$ 时不能直接查找对应的值，应该直接删除 `multiset` 中最小的那个值（具体见函数 `void erase(std::multiset&lt;int&gt;&amp;, int)`）。

```cpp
#include &lt;bits/stdc++.h&gt;
#ifdef LOCAL
#define dbg(args...) std::cerr &lt;&lt; &#34;\033[32;1m&#34; &lt;&lt; #args &lt;&lt; &#34; -&gt; &#34;, err(args)
#else
#define dbg(...)
#endif
inline void err() { std::cerr &lt;&lt; &#34;\033[0m\n&#34;; }
template&lt;class T, class... U&gt;
inline void err(const T &amp;x, const U &amp;... a) { std::cerr &lt;&lt; x &lt;&lt; &#39; &#39;; err(a...); }
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }

typedef long long LL;
typedef std::pair&lt;int, int&gt; PII;

using Matrix = std::array&lt;std::array&lt;int, 4&gt;, 4&gt;;
Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) {
  Matrix r;
  r[0][0] = std::max({ a[0][0] + b[0][0], a[0][1] + b[1][0], a[0][2] + b[2][0], a[0][3] + b[3][0] });
  r[0][1] = std::max({ a[0][0] + b[0][1], a[0][1] + b[1][1], a[0][2] + b[2][1], a[0][3] + b[3][1] });
  r[0][2] = std::max({ a[0][0] + b[0][2], a[0][1] + b[1][2], a[0][2] + b[2][2], a[0][3] + b[3][2] });
  r[0][3] = std::max({ a[0][0] + b[0][3], a[0][1] + b[1][3], a[0][2] + b[2][3], a[0][3] + b[3][3] });
  r[1][0] = std::max({ a[1][0] + b[0][0], a[1][1] + b[1][0], a[1][2] + b[2][0], a[1][3] + b[3][0] });
  r[1][1] = std::max({ a[1][0] + b[0][1], a[1][1] + b[1][1], a[1][2] + b[2][1], a[1][3] + b[3][1] });
  r[1][2] = std::max({ a[1][0] + b[0][2], a[1][1] + b[1][2], a[1][2] + b[2][2], a[1][3] + b[3][2] });
  r[1][3] = std::max({ a[1][0] + b[0][3], a[1][1] + b[1][3], a[1][2] + b[2][3], a[1][3] + b[3][3] });
  r[2][0] = std::max({ a[2][0] + b[0][0], a[2][1] + b[1][0], a[2][2] + b[2][0], a[2][3] + b[3][0] });
  r[2][1] = std::max({ a[2][0] + b[0][1], a[2][1] + b[1][1], a[2][2] + b[2][1], a[2][3] + b[3][1] });
  r[2][2] = std::max({ a[2][0] + b[0][2], a[2][1] + b[1][2], a[2][2] + b[2][2], a[2][3] + b[3][2] });
  r[2][3] = std::max({ a[2][0] + b[0][3], a[2][1] + b[1][3], a[2][2] + b[2][3], a[2][3] + b[3][3] });
  r[3][0] = std::max({ a[3][0] + b[0][0], a[3][1] + b[1][0], a[3][2] + b[2][0], a[3][3] + b[3][0] });
  r[3][1] = std::max({ a[3][0] + b[0][1], a[3][1] + b[1][1], a[3][2] + b[2][1], a[3][3] + b[3][1] });
  r[3][2] = std::max({ a[3][0] + b[0][2], a[3][1] + b[1][2], a[3][2] + b[2][2], a[3][3] + b[3][2] });
  r[3][3] = std::max({ a[3][0] + b[0][3], a[3][1] + b[1][3], a[3][2] + b[2][3], a[3][3] + b[3][3] });
  return r;
}

constexpr int N(5e5 + 5), INF(1e9);

int n, m, val[N], fa[N], son[N], siz[N];

std::vector&lt;int&gt; g[N];

void dfs1(int x) {
  siz[x] = 1;  
  for (int y : g[x]) {
    if (y == fa[x]) continue;
    fa[y] = x;
    dfs1(y);
    siz[x] += siz[y];
    if (siz[y] &gt; siz[son[x]]) son[x] = y;
  }
}

struct Node {
  Node *ls, *rs, *fa;
  Matrix val, sum;
  inline void pushup() {
    sum = ls ? ls-&gt;sum * val : val;
    if (rs) sum = sum * rs-&gt;sum;
  }
} t[N];
std::multiset&lt;int&gt; vir[N][3];
void updateVal(int x) {
  auto &amp;v = t[x].val;
  auto p0 = vir[x][0].rbegin(), p1 = vir[x][1].rbegin();
  int k = val[son[x]], m0 = *p0, m1 = *p1;
  v[0][k] = 1, v[0][!k] = v[0][2] = -INF, v[0][3] = m0;
  v[1][!k] = 1, v[1][k] = v[1][2] = -INF, v[1][3] = m1;
  v[2][k] = m0 + 1, v[2][!k] = m1 + 1, v[2][2] = 0;
  v[2][3] = vir[x][0].size() &gt; 1 ? std::max(m0 + *++p0, m1 + *++p1) : 0;
  smax(v[2][3], *vir[x][2].rbegin());
  v[3][0] = v[3][1] = v[3][2] = -INF, v[3][3] = 0;
}
int f[N][3];
void dfs2(int x) {
  f[x][0] = f[x][2] = 0, f[x][1] = -INF;
  vir[x][0].insert(0), vir[x][1].insert(-INF), vir[x][2].insert(0);
  for (int y : g[x]) {
    if (y == fa[x]) continue;
    dfs2(y);
    smax(f[x][2], f[y][2]);
    smax(f[x][2], f[x][0] + f[y][val[y]] + 1);
    smax(f[x][2], f[x][1] + f[y][!val[y]] + 1);
    smax(f[x][0], f[y][val[y]] + 1);
    smax(f[x][1], f[y][!val[y]] + 1);
    if (y == son[x]) continue;
    vir[x][0].insert(f[y][val[y]] + 1);
    vir[x][1].insert(f[y][!val[y]] + 1);
    vir[x][2].insert(f[y][2]);
  }
  updateVal(x);
}
int top[N], s[N], sum[N];
Node* build(int l, int r) {
  if (l == r) return t[s[l]].pushup(), t + s[l];
  int m = l, tot = sum[r] + sum[l - 1];
  while (m &lt; r &amp;&amp; sum[m] &lt;&lt; 1 &lt; tot) m++;
  Node *o = t + s[m];
  if (l &lt; m) o-&gt;ls = build(l, m - 1), o-&gt;ls-&gt;fa = o;
  if (m &lt; r) o-&gt;rs = build(m + 1, r), o-&gt;rs-&gt;fa = o;
  o-&gt;pushup();
  return o;
}
Node *root;
void dfs3(int x, int tp) {
  top[x] = tp;
  if (x == tp) {
    int m = 0;
    for (int i = x; i; i = son[i]) {
      s[++m] = i;
      sum[m] = sum[m - 1] + siz[i] - siz[son[i]];
    }
    if (x &gt; 1)
      build(1, m)-&gt;fa = t + fa[x];
    else
      root = build(1, m);
  }
  if (!son[x]) return;
  dfs3(son[x], tp);
  for (int y : g[x]) {
    if (y == fa[x] || y == son[x]) continue;
    dfs3(y, y);
  }
}
inline void erase(std::multiset&lt;int&gt; &amp;s, int x) {
  if (x &lt; 0)
    assert(*s.begin() &lt; 0), s.erase(s.begin());
  else 
    s.erase(s.find(x));
}
void work(int x, int y) {
  assert(fa[y] == x);
  Node *o = t + x;
  int &amp;v = val[y];
  if (son[x] == y) {
    v ^= 1;
  } else {
    Node *p = t + y;
    while (p-&gt;fa != o) p = p-&gt;fa;
    erase(vir[x][0], p-&gt;sum[v][3] + 1);
    erase(vir[x][1], p-&gt;sum[!v][3] + 1);
    v ^= 1;
    vir[x][0].insert(p-&gt;sum[v][3] + 1);
    vir[x][1].insert(p-&gt;sum[!v][3] + 1);
  }
  for (updateVal(x); o-&gt;fa; o = o-&gt;fa) {
    if (o-&gt;fa-&gt;ls != o &amp;&amp; o-&gt;fa-&gt;rs != o) {
      x = o-&gt;fa - t, y = val[top[o - t]];
      erase(vir[x][0], o-&gt;sum[y][3] + 1);
      erase(vir[x][1], o-&gt;sum[!y][3] + 1);
      erase(vir[x][2], o-&gt;sum[2][3]);
      o-&gt;pushup();
      vir[x][0].insert(o-&gt;sum[y][3] + 1);
      vir[x][1].insert(o-&gt;sum[!y][3] + 1);
      vir[x][2].insert(o-&gt;sum[2][3]);
      updateVal(x);
    } else {
      o-&gt;pushup();
    }
  }
  o-&gt;pushup();
}
struct Edge {
  int x, y, z;
} e[N];
int main() {
  readInt(n);
  for (int i = 1; i &lt; n; i++) {
    auto &amp;[x, y, z] = e[i];
    readInt(x, y, z);
    g[x].push_back(y), g[y].push_back(x);
  }
  dfs1(1);
  for (int i = 1; i &lt; n; i++) {
    auto &amp;[x, y, z] = e[i];
    if (fa[y] != x) std::swap(x, y);
    assert(fa[y] == x);
    val[y] = z;
  }
  
  dfs2(1);
  dfs3(1, 1);
  readInt(m);
  while (m--) {
    int i; readInt(i);
    work(e[i].x, e[i].y);
    printf(&#34;%d\n&#34;, root-&gt;sum[2][3]);
  }
  return 0;
}

```

## Top Tree
旧的Top Tree 写法
```cpp
#include &lt;bits/stdc++.h&gt;
#define dbg(...)                                           \
  std::cerr &lt;&lt; &#34;\033[32;1m&#34;, fprintf(stderr, __VA_ARGS__), \
      std::cerr &lt;&lt; &#34;\033[0m&#34;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}
using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(5e5 + 5);

struct Info {
  int c, len, d[2][2], r[2];
  Info() : c(0), len(0) {
    d[0][0] = 0, d[0][1] = -1e9;
    d[1][0] = 0, d[1][1] = -1e9;
    r[0] = r[1] = -1e9;
  }
  void reverse() {
    std::swap(d[0][0], d[1][0]);
    std::swap(d[0][1], d[1][1]);
  }
  Info &amp;compress(Info a, Info b) {
    c = a.c ^ b.c;
    len = a.len + b.len;
    d[0][0] = std::max(a.d[0][0], a.len + b.d[0][a.c]);
    d[0][1] = std::max(a.d[0][1], a.len + b.d[0][!a.c]);
    d[1][0] = std::max(b.d[1][0], b.len + a.d[1][b.c]);
    d[1][1] = std::max(b.d[1][1], b.len + a.d[1][!b.c]);
    r[0] = std::max(
        {a.r[0], b.r[0], a.d[1][0] + b.d[0][0], a.d[1][1] + b.d[0][1]});
    r[1] = std::max(
        {a.r[1], b.r[1], a.d[1][0] + b.d[0][1], a.d[1][1] + b.d[0][0]});
    return *this;
  }
  Info &amp;rake(Info a, Info b) {
    c = b.c;
    len = b.len;
    d[0][0] = std::max(a.d[0][0], b.d[0][0]);
    d[0][1] = std::max(a.d[0][1], b.d[0][1]);
    d[1][0] = std::max(b.d[1][0], b.len + a.d[0][b.c]);
    d[1][1] = std::max(b.d[1][1], b.len + a.d[0][!b.c]);
    r[0] = std::max(
        {a.r[0], b.r[0], a.d[0][0] + b.d[0][0], a.d[0][1] + b.d[0][1]});
    r[1] = std::max(
        {a.r[1], b.r[1], a.d[0][0] + b.d[0][1], a.d[0][1] + b.d[0][0]});
    return *this;
  }
};


struct SplayTree {
  static SplayTree *null;
  SplayTree *ch[3], *fa;
  bool rev;
  Info info;
  SplayTree() : rev(false), info() {
    static bool init = true;
    if (init) {
      init = false;
      null = new SplayTree;
      null-&gt;ch[0] = null-&gt;ch[1] = null-&gt;ch[2] = null-&gt;fa = null;
    }
    ch[0] = ch[1] = ch[2] = fa = null;
  }
  bool notRoot() const { return fa-&gt;ch[0] == this || fa-&gt;ch[1] == this; }
  void reverse() {
    rev ^= 1;
    std::swap(ch[0], ch[1]);
    info.reverse();
  }
  bool dir() const { return fa-&gt;ch[1] == this; }
  void sch(int d, SplayTree *c) { ch[d] = c, c-&gt;fa = this; }
  void rotate() {
    SplayTree *p = fa;
    bool d = dir();
    fa = p-&gt;fa;
    if (fa != null) {
      fa-&gt;ch[fa-&gt;ch[2] == p ? 2 : p-&gt;dir()] = this;
    }
    p-&gt;sch(d, ch[!d]), sch(!d, p);
    p-&gt;pushup();
  }
  void splay() {
    static SplayTree *s[N], **t;
    t = s;
    for (auto x = this; x-&gt;notRoot(); x = x-&gt;fa) *++t = x-&gt;fa;
    while (t != s) (*t--)-&gt;pushdown();
    for (pushdown(); notRoot(); rotate()) {
      if (fa-&gt;notRoot()) {
        (fa-&gt;dir() == dir() ? fa : this)-&gt;rotate();
      }
    }
    pushup();
  }
  virtual void pushup() {}
  virtual void pushdown() {}
  virtual ~SplayTree() {}
};
SplayTree *SplayTree::null;

struct RakeTree : SplayTree {
  void pushup() {
    info.rake(ch[0]-&gt;info, Info().rake(ch[2]-&gt;info, ch[1]-&gt;info));
  }
};

struct CompressTree : SplayTree {
  void pushup() {
    info.compress(ch[0]-&gt;info, Info().rake(ch[2]-&gt;info, ch[1]-&gt;info));
    // dbg(&#34;vt pushup!\n&#34;);
  }
  void pushdown() {
    if (rev) {
      rev = false;
      ch[0]-&gt;reverse(), ch[1]-&gt;reverse();
    }
  }
  void access() {
    splay();
    if (ch[1] != null) {
      auto r = new RakeTree;
      r-&gt;sch(0, ch[2]), r-&gt;sch(2, ch[1]), r-&gt;pushup();
      ch[1] = null, sch(2, r), pushup();
    }
    for (; fa != null; rotate()) {
      fa-&gt;splay();
      SplayTree *m = fa, *p = m-&gt;fa;
      assert(p != null);
      p-&gt;splay();
      if (p-&gt;ch[1] != null) {
        m-&gt;sch(2, p-&gt;ch[1]);
        m-&gt;pushup();
      } else {
        if (m-&gt;ch[0] == null) {
          p-&gt;sch(2, m-&gt;ch[1]);
        } else if (m-&gt;ch[1] == null) {
          p-&gt;sch(2, m-&gt;ch[0]);
        } else {
          auto x = m-&gt;ch[0];
          x-&gt;fa = null;
          while (x-&gt;pushdown(), x-&gt;ch[1] != null) x = x-&gt;ch[1];
          x-&gt;splay();
          p-&gt;sch(2, x);
          x-&gt;sch(1, m-&gt;ch[1]);
          x-&gt;pushup();
        }
        delete m;
      }
      p-&gt;sch(1, this);
      p-&gt;pushup();
    }
    pushup();
  }
  void evert() { access(), reverse(), pushdown(); }
};
void link(CompressTree *x, CompressTree *y, int c) {
  x-&gt;access(), y-&gt;evert();
  auto e = new SplayTree;
  e-&gt;info.len = 1, e-&gt;info.c = c;
  x-&gt;sch(1, y), y-&gt;sch(0, e);
  y-&gt;pushup(), x-&gt;pushup();
}

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin &gt;&gt; n;
  CompressTree *t = new CompressTree[n + 1];
  assert(SplayTree::null);
  std::vector&lt;int&gt; u(n - 1), v(n - 1);
  for (int i = 0, c; i &lt; n - 1; i++) {
    std::cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; c;
    link(t + u[i], t + v[i], c);
  }
  std::cin &gt;&gt; m;
  while (m--) {
    int i;
    std::cin &gt;&gt; i;
    i--;
    t[u[i]].evert(), t[v[i]].access();
    t[u[i]].ch[1]-&gt;info.c ^= 1;
    t[u[i]].pushup();
    t[v[i]].pushup();
    std::cout &lt;&lt; t[v[i]].info.r[0] &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```
## 其他解法
比如线段树、括号序列，留坑。- https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codechef CCC]Hit the Coconuts</title>
        <link>https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/</link>
        <pubDate>Thu, 18 Mar 2021 21:51:42 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/ -&gt; 题意： $N$ 个椰子, 第 $i$ 个需要敲 $a_i$ 下才能打开，问最坏情况下最少要敲多少下才能打开 $k$ 个椰子。 

不妨设 $a_i \le a_{i + 1}$。

要敲开一个椰子，现在有两种方法：

 1. 随便拿起一个椰子不停地敲，最多要 $a_n$ 次。
 2. 有目的性地想要敲开某个椰子 $a_i$，可以发现最优的策略就是每个椰子都敲 $a_i$ 次，最多要敲 $a_i\times(n - i + 1)$ 次，所有情况下取最小值。

第二种情况实际上包含了第一种。

那么要敲开 $k$ 个椰子，也有两种方法：

 1. 每次都随便拿一个敲开，最多要 $a_n + a_{n - 1}+ \dots + a_{n - k + 1}$ 次。
 2. 选 $k$ 个椰子 $a_{b_1}, a_{b_2}, \dots, a_{b_k}(b_i &lt; b_{i + 1})$，有目的性地敲开它们。发现最优策略下最多要敲 $\sum_{i = 1}^k (a_{b_i} - a_{b_i - 1}) \times (n - b_i + 1)$ 次，其中 $a_{b_0} = 0$，所有情况下取最小值。

第二种情况也包含了第一种。

因此考虑第二种情况的求解，设 $dp[i][k]$ 表示前 $i$ 个椰子敲开 $k$ 个（包括第 $i$ 个椰子）的最少次数。

$$
dp[i][k] = \min\{dp[j][k - 1] + (a_i - a_j) \times (n - i + 1)\}
$$

这显然是一个斜率优化的形式，化一下式子（第二维省略）：

$$
dp[i] = \min\{a_j \times (i - n - 1) + dp[j]\} + a_i \times (n - i + 1)
$$

设直线 $L_j(x) = a_j \cdot x + dp[j]$，求 $\min L_j(i - n - 1)$，斜率和横坐标都是递增的，可以用栈维护一个上凸壳，复杂度 $O(nk + n\log n)$。

```cpp
#include &lt;bits/stdc++.h&gt;
#ifdef LOCAL
#define dbg(args...) std::cerr &lt;&lt; &#34;\033[32;1m&#34; &lt;&lt; #args &lt;&lt; &#34; -&gt; &#34;, err(args)
#else
#define dbg(...)
#endif
inline void err() { std::cerr &lt;&lt; &#34;\033[0m\n&#34;; }
template&lt;class T, class... U&gt;
inline void err(const T &amp;x, const U &amp;... a) { std::cerr &lt;&lt; x &lt;&lt; &#39; &#39;; err(a...); }
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }

typedef long long LL;
typedef std::pair&lt;int, int&gt; PII;

constexpr int N(1005);
int n, k, a[N];
LL dp[N];
struct Line {
  int k; LL b;
  Line(int k = 0, LL b = 0): k(k), b(b) {}
  inline LL func(int x) { return 1LL * k * x + b; }
  inline bool check(const Line &amp;p, const Line &amp;q) const {
    return (b - p.b) * (k - q.k) &gt; (b - q.b) * (k - p.k);
  }
} q[N];
int main() {
  int t; readInt(t);
  while (t--) {
    readInt(n, k);
    for (int i = 1; i &lt;= n; i++) readInt(a[i]);
    std::sort(a + 1, a + 1 + n);
    for (int i = 1; i &lt;= n; i++) dp[i] = 1e9;
    for (int c = 0, r; c &lt; k; c++) {
      q[r = 1] = Line(a[c], dp[c]);
      for (int i = c + 1; i &lt;= n; i++) {
        int x = i - n - 1;
        while (r &gt; 1 &amp;&amp; q[r].func(x) &gt;= q[r - 1].func(x)) r--;
        Line now = Line(a[i], dp[i]);
        dp[i] = q[r].func(x) - 1LL * a[i] * x;
        while (r &gt; 1 &amp;&amp; !now.check(q[r], q[r - 1])) r--;
        q[++r] = now;
      }
    }
    LL ans = dp[k];
    for (int i = k + 1; i &lt;= n; i++) smin(ans, dp[i]);
    printf(&#34;%lld\n&#34;, ans);
  }
  return 0;
}
```
- https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[PKUWC2018]猎人杀</title>
        <link>https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/</link>
        <pubDate>Thu, 18 Mar 2021 21:47:16 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/ -&gt; $n$ 个人，每个人有个权值 $a_i$。进行 $n$ 轮操作，每轮开枪杀死一个人，$i$ 被杀死的概率 $p_i=\dfrac{a_i}{\sum_{x\ is\ alive}a_x}$ ，求最后死的那个人是 $1$ 的概率。答案对 $998244353$ 取模。
&gt;
&gt; $a_i &gt; 0, 1 \le \sum a_i \le 10^5$。

设 $s = \sum_{i=1}^na_i,w=\sum_{x\ is\ alive}a_x$，那么有
$$
\begin{aligned}
p_i &amp;= \frac{a_i}{w}\\
\frac wsp_i &amp;= \frac {a_i}{s}\\
p_i &amp;= \frac {a_i}{s} + \frac{s - w}s p_i
\end{aligned}
$$
最后的这个式子可以理解为，每次开枪的目标是所有活人和死人，如果打到活人就会杀死他，如果打到死人不算，重打。

这样变成进行无限轮，每轮的目标都是所有人，打到某个人的概率更容易表示。

然后考虑容斥，设 $A = \{ a_2, a_3, \dots, a_n \}$， $1$ 在第 $r$ 轮被打死，且至少有 $k$ 个人在 $1$ 之后被打死。
$$
\begin{aligned}
ans
&amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \sum_{r = 1}^{\infty} \left(\frac{s - a_1 - \sum_{i \in S} a_i}{s}\right)^{r - 1} \cdot \frac{a_1}{s}\\
&amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{s} \cdot \sum_{r = 0}^{\infty} \left(\frac{s - a_1 - \sum_{i \in S} a_i}{s}\right)^{r}\\
&amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{s} \cdot \frac{1}{1 - \dfrac{s - a_1 - \sum_{i \in S} a_i}{s}}\\
&amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{a_1 + \sum_{i \in S} a_i}\\
&amp;= \sum_{k = 0}^{s - a_1} \frac{a_1}{a_1 + k} \times \sum_{S \subseteq A, \sum_{i \in S} a_i = k} (-1)^{|S|}\\
&amp;= \sum_{k = 0}^{s - a_1} \frac{a_1}{a_1 + k} \times [x^k] \prod_{i=2}^n(1 - x^{a_i})
\end{aligned}
$$
分治求 $\prod_{i=2}^n(1 - x^{a_i})$ 即可，复杂度 $O(n \log n \log s)$ 。

```cpp
#include &lt;bits/stdc++.h&gt;
#ifdef LOCAL
#define dbg(args...) std::cerr &lt;&lt; &#34;\033[32;1m&#34; &lt;&lt; #args &lt;&lt; &#34; -&gt; &#34;, err(args)
#else
#define dbg(...)
#endif
inline void err() { std::cerr &lt;&lt; &#34;\033[0m\n&#34;; }
template&lt;class T, class... U&gt;
inline void err(const T &amp;x, const U &amp;... a) { std::cerr &lt;&lt; x &lt;&lt; &#39; &#39;; err(a...); }
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }

constexpr int P(998244353), G(3);
inline void inc(int &amp;x, int y) { (x += y) &gt;= P ? x -= P : 0; }
inline int sum(int x, int y) { return x + y &gt;= P ? x + y - P : x + y; }
inline int sub(int x, int y) { return x - y &lt; 0 ? x - y + P : x - y; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P)
    if (k &amp; 1) r = 1LL * r * x % P;
  return r;
}

namespace Polynomial {
using Polynom = std::vector&lt;int&gt;;
std::vector&lt;int&gt; w;
void getOmega(int k) {
  w.resize(k);
  w[0] = 1;
  int base = fpow(G, (P - 1) / (k &lt;&lt; 1));
  for (int i = 1; i &lt; k; i++) w[i] = 1LL * w[i - 1] * base % P;
}
void dft(int *a, int n) {
  assert((n &amp; n - 1) == 0);
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = (1LL * a[i + j] - y + P) * w[j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void dft(Polynom &amp;a) { dft(a.data(), a.size()); }
void idft(int *a, int n) {
  assert((n &amp; n - 1) == 0);
  for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[j] % P;
        a[i + j] = sum(x, y), a[i + j + k] = sub(x, y);
      }
    }
  }
  for (int i = 0, inv = P - (P - 1) / n; i &lt; n; i++) a[i] = 1LL * a[i] * inv % P;
  std::reverse(a + 1, a + n);
}
void idft(Polynom &amp;a) { idft(a.data(), a.size()); }
Polynom operator*(Polynom a, Polynom b) {
  int len = a.size() + b.size() - 1;
  if (a.size() &lt;= 8 || b.size() &lt;= 8) {
    Polynom c(len);
    for (unsigned i = 0; i &lt; a.size(); i++)
      for (unsigned j = 0; j &lt; b.size(); j++)
        c[i + j] = (c[i + j] + 1LL * a[i] * b[j]) % P;
    return c;
  }
  int n = 1 &lt;&lt; std::__lg(len - 1) + 1;
  a.resize(n), b.resize(n);
  dft(a), dft(b);
  for (int i = 0; i &lt; n; i++) a[i] = 1LL * a[i] * b[i] % P;
  idft(a);
  a.resize(len);
  return a;
}
} // namespace Polynomial

using Polynomial::Polynom;
using Polynomial::operator*;

constexpr int N(1e5 + 5);
int n, a[N], s;
Polynom calc(int l, int r) {
  if (l == r) {
    Polynom ans(a[l] + 1);
    ans[0] = 1, ans.back() = P - 1;
    return ans;
  }
  int m = l + r &gt;&gt; 1;
  Polynom ans = calc(l, m) * calc(m + 1, r);
  if (ans.size() &gt; s + 1) ans.resize(s + 1);
  return ans;
}
int main() {
  readInt(n);
  for (int i = 1; i &lt;= n; i++) readInt(a[i]), s += a[i];
  s -= a[1];
  auto p = calc(2, n);
  int ans = 0;
  for (int i = 0; i &lt;= s; i++) ans = (ans + 1LL * fpow(a[1] + i) * p[i]) % P;
  ans = 1LL * ans * a[1] % P;
  printf(&#34;%d\n&#34;, ans);
  return 0;
}
```
- https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>李超线段树和set维护凸包</title>
        <link>https://blog.asukakyle.top/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8Cset%E7%BB%B4%E6%8A%A4%E5%87%B8%E5%8C%85/</link>
        <pubDate>Thu, 18 Mar 2021 21:30:30 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8Cset%E7%BB%B4%E6%8A%A4%E5%87%B8%E5%8C%85/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8Cset%E7%BB%B4%E6%8A%A4%E5%87%B8%E5%8C%85/ -
## 问题引入
有一些点 $(a_i, b_i)$，需要多次询问 $\max\{ax_0+b\}$。

## 李超线段树
利用李超线段树可以很好地维护上述信息。

李超线段树就是支持 $O(\log N)$ 插入直线和查询 $\max{L_i(x)}$ 的数据结构。

线段树的每个节点保存 $L(mid)$ 最大的那条直线。

插入一条直线时，比较 $L_{old}(mid)$ 和 $L_{new}(mid)$，较大者保留，较小者继续递归。

```cpp
constexpr int N(1e5 + 5);
struct Line {
  LL k, b;
  LL f(int x) {
    return k * x + b;
  }
} t[N &lt;&lt; 2];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
void ins(int o, int l, int r, Line x) {
  int m = l + r &gt;&gt; 1;
  bool lv = x.f(l) &gt; t[o].f(l), mv = x.f(m) &gt; t[o].f(m), rv = x.f(r) &gt; t[o].f(r);
  if (mv) std::swap(x, t[o]);
  if (lv == rv || l == r) return;
  lv != mv ? ins(ls, l, m, x) : ins(rs, m + 1, r, x);
}
LL ask(int o, int l, int r, int x) {
  if (l == r) return t[o].f(x);
  int m = l + r &gt;&gt; 1;
  return std::max(t[o].f(x), x &lt;= m ? ask(ls, l, m, x) : ask(rs, m + 1, r, x));
}
```

李超树可以合并，下面copy自jiangly的代码。

```cpp
Node *merge(Node *p, Node *q, int l, int r) {
  if (p == nullptr)
    return q;
  if (q == nullptr)
    return p;
  int m = (l + r) / 2;
  p -&gt; lc = merge(p -&gt; lc, q -&gt; lc, l, m);
  p -&gt; rc = merge(p -&gt; rc, q -&gt; rc, m, r);
  modify(p, l, r, q -&gt; line);
  return p;
}
```

也可以维护lazytag，和普通线段树一样，就是在修改的时候要把当前区间的直线往下放（这种没写过，下面的代码也是复制的，来自 [Li Chao Tree Extended](http://codeforces.com/blog/entry/86731)）。

```cpp
void PushLine(Node* &amp;n, data_t tl, data_t tr) {
  if (n == nullptr) return;
  data_t mid = (tl + tr) / 2;
  InsertLineKnowingly(n-&gt;lc, tl, mid, n-&gt;line);
  InsertLineKnowingly(n-&gt;rc, mid + 1, tr, n-&gt;line);
  n-&gt;line = Line&lt;data_t&gt;();
}
```

## set 维护凸包
也可以用平衡树维护凸包来实现这个东西，有cf老哥搞了个set的版本，抄过来了。

```cpp
constexpr LL QB = LLONG_MIN;
struct Line {
  LL a, b; // y = ax + b
  mutable std::function&lt;const Line *()&gt; next;
  bool operator&lt;(const Line &amp;r) const {
    if (r.b != QB) return a &lt; r.a;
    auto q = next();
    if (!q) return 0;
    return b - q-&gt;b &lt; (q-&gt;a - a) * r.a;
  }
};

using LLL = __int128;
struct DynamicHull : std::multiset&lt;Line&gt; {
  using multiset::multiset;

  bool bad(iterator y) {
    auto z = next(y);
    if (y == begin()) {
      if (z == end()) return false;
      return y-&gt;a == z-&gt;a &amp;&amp; y-&gt;b &lt;= z-&gt;b;
    }
    auto x = prev(y);
    if (z == end()) {
      return x-&gt;a == y-&gt;a &amp;&amp; y-&gt;b &lt;= x-&gt;b;
    }
    return LLL(x-&gt;b - y-&gt;b) * (z-&gt;a - y-&gt;a) &gt;= LLL(y-&gt;b - z-&gt;b) * (y-&gt;a - x-&gt;a);
  }

  void ins(LL a, LL b) {
    auto it = insert({a, b});
    it-&gt;next = [=] {
      auto q = next(it);
      return q == end() ? nullptr : &amp;*q;
    };

    if (bad(it)) {
      erase(it);
    } else {
      iterator z;
      while (it != begin() &amp;&amp; bad(z = prev(it))) erase(z);
      it++;
      while (it != end() &amp;&amp; bad(it)) it = erase(it);
    }
  }

  LL askMax(LL x) {
    auto l = *lower_bound({x, QB});
    return l.a * x + l.b;
  }
};
```- https://blog.asukakyle.top/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8Cset%E7%BB%B4%E6%8A%A4%E5%87%B8%E5%8C%85/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Fast Fourier Transform</title>
        <link>https://blog.asukakyle.top/post/fft/</link>
        <pubDate>Thu, 18 Mar 2021 15:28:59 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/fft/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/fft/ -
## Introduction

&gt; `快速傅里叶变换(Fast Fourier Transform，FFT)`是一种可在 $O(n \log n)$ 时间内完成的`离散傅里叶变换 (Discrete Fourier Transform，DFT)` 的算法，用来实现将信号从原始域（通常是时间或空间）到频域的互相转化。

FFT 在算法竞赛中主要用来加速多项式乘法（循环卷积）。

### 多项式

形如
$$
A(x) = a_0 + a_1x + a_2x^2 + \dots + a_{n-1}x^{n - 1}
$$
的式子称为 $x$ 的 $n - 1$ 次多项式，其中 $a_0, a_1, \dots, a_{n - 1}$ 称为多项式系数，$n-1$ 称为多项式的次数，记为 $\deg A(x)$ 或 $\deg A$。

### 点值

$n - 1$ 次多项式 $A(x)$ 在 $x = m$ 处的**点值**
$$
A(m) = \sum_{k=0}^{n-1} a_km^k
$$

### 多项式乘法

记 $A(x)\times B(x)$ 表示多项式 $A(x), B(x)$ 做多项式乘法，可以简写为 $A(x)\cdot B(x)$ 或 $A(x)B(x)$。

多项式乘法
$$
\begin{aligned}
C(x) = &amp;A(x) \times B(x)\\
= &amp;\left(a_0 + a_1x + \dots + a_{\deg A}x^{\deg A}\right)\cdot\left(b_0 + b_1x + \dots + b_{\deg B}x^{\deg B}\right)\\
= &amp;\sum_{r = 0}^{\deg A + \deg B} \sum_{k = 0}^r a_kb_{r - k} x^r
\end{aligned}
$$
用系数关系可以表示为
$$
c_r = \sum_{k = 0}^ra_kb_{r - k}
$$

其中 $\deg C = \deg A + \deg B$。

易证它们的点值满足如下关系
$$
C(m) = A(m)B(m)
$$

### 循环卷积

记 $\operatorname{conv}(A, B, n)$ 表示多项式 $A(x), B(x)$ 做长度为 $n$ 的循环卷积。

循环卷积
$$
C(x) = \operatorname{conv}(A, B, n)
$$
系数关系表示为
$$
c_k = \sum_{p, q}[(p + q) \bmod n = k]a_pb_q
$$
其中 $\deg C = n - 1$。

容易发现，当 $n &gt; \deg A + \deg B$ 时，该运算等价于多项式乘法。

### DFT

&gt; `离散傅里叶变换(Discrete Fourier Transform, DFT)` 将多项式 $A(x)=\sum_{k=0}^{n-1}a_kx^k$ 转换为一些特殊的点值。

记  $n$ 次单位复根
$$
\omega_n = e^{\frac{2i\pi}n}=\cos\dfrac{2\pi}{n}+i\sin\dfrac{2\pi}{n}
$$
$DFT(A)$ 就是要计算点值 $A(\omega_n^k), k = 0， 1， 2， \dots, n-1$。

单位根自带的循环特性使得循环卷积 $C(x) = \operatorname{conv}(A, B, n)$ 的点值也满足：
$$
C(\omega_n^k) = A(\omega_n^k)B(\omega_n^k)
$$

### IDFT

IDFT 是 DFT 的逆变换。

首先，用等比数列求和易证：
$$
\begin{aligned}
\frac1n\sum_{k = 0}^{n - 1}\omega_n^{vk} &amp;= [v \bmod n = 0]
\end{aligned}
$$
考虑循环卷积 $C(x) = \operatorname{conv}(A, B, n)$ 的系数表示
$$
\begin{aligned}
c_r = &amp;\sum_{p, q}[(p + q) \bmod n = r]a_pb_q\\
= &amp;\sum_{p, q}[(p + q - r) \bmod n = 0]a_pb_q\\
= &amp;\sum_{p, q}\frac1n\sum_{k = 0}^{n - 1}\omega_n^{pk+qk-rk}a_pb_q\\
= &amp;\sum_{p, q}\frac1n\sum_{k = 0}^{n - 1}\omega_n^{-rk}\cdot\omega_n^{pk}a_p\cdot\omega_n^{qk}b_q\\
= &amp;\frac1n\sum_{k = 0}^{n - 1}\omega_n^{-rk}\left(\sum_{p}\omega_n^{pk}a_p\sum_q\omega_n^{qk}b_q\right)\\
= &amp;\frac1n\sum_{k = 0}^{n - 1}\left(\omega_n^{-r}\right)^kA(\omega_n^k)B(\omega_n^k)\\
= &amp;\frac1n\sum_{k = 0}^{n - 1}\left(\omega_n^{n-r}\right)^kC(\omega_n^k)
\end{aligned}
$$

设多项式
$$
C&#39;(x) = \sum_{k=0}^{n-1}C(\omega_n^k)x^k
$$
只要计算 $DFT(C&#39;)$ 即可得到 $C(x)$ 的系数，于是我们用 DFT 完成了逆变换 IDFT。

用两次 DFT 和一次 IDFT就可以计算 $\operatorname{conv}(A, B, n)$。

暴力的复杂度是 $O(n^2)$，此处不赘述。

### FFT

现在尝试将 DFT 问题分解以优化时间复杂度。

**本部分认为 $n = \deg A + 1$ 为 $2$ 的整数次幂。对于更一般的情况，暂不考虑。**

#### DIF

**将序列 $a_i$ 分成左右两半**。
$$
\begin{aligned}
A(\omega_n^{r}) &amp;= \sum_{k = 0}^{n-1}a_k\omega_n^{rk}\\
&amp;= \sum_{k = 0}^{n / 2 - 1} \left(a_k\cdot\omega_n^{rk} + a_{k+n/2}\cdot\omega_n^{rk+rn/2}\right)\\
&amp;= \sum_{k = 0}^{n / 2 - 1} \left[a_k\cdot\omega_n^{rk} + (-1)^r\cdot a_{k+n/2}\cdot\omega_n^{rk}\right]\\
&amp;= \sum_{k = 0}^{n / 2 - 1} \left[a_k+(-1)^ra_{k+n/2}\right]\omega_{n}^{rk}
\end{aligned}
$$
**进一步，将 $A(\omega_{n}^r)$ 按奇偶分类**：
$$
\begin{aligned}
A\left(\omega_n^{2r}\right) &amp;= \sum_{k=0}^{n/2-1}\left(a_k+a_{k+n/2}\right)\omega_{n/2}^{rk}\\
A\left(\omega_n^{2r+1}\right) &amp;= \sum_{k=0}^{n/2-1}\left(\omega_{n}^ka_k-\omega_{n}^ka_{k+n/2}\right)\omega_{n/2}^{rk}
\end{aligned}
$$

设
$$
\begin{aligned}
&amp;p_k=a_k+a_{k+n/2}, &amp;P(x) = \sum_{k = 0}^{n/2-1}p_kx^k\\
&amp;q_k=\omega_{n}^k(a_k-a_{k+n/2}), &amp;Q(x) = \sum_{k=0}^{n/2-1}q_kx^k
\end{aligned}
$$
我们只需要求出 $P(\omega_{n/2}^r)$ 和 $Q(\omega_{n/2}^r)$ ，即求解规模为原来一半的两个子问题 $DFT(P), DFT(Q)$，就能在 $O(n)$ 时间内计算出 $DFT(A)$。


#### DIT

**在算法竞赛中这种方法更常见。**

注意到在 `DIF` 中我们最后将 $A(\omega_n^r)$ 奇偶分类求解，那不妨思考**将序列 $a_k$ 按奇偶分类**。

设
$$
\begin{aligned}
A_0(x) = a_0 + a_2x + \dots + a_{n - 2}x^{n / 2}\\
A_1(x) = a_1 + a_3x+ \dots + a_{n - 1}x^{n / 2}
\end{aligned}
$$
则
$$
A(x) = A_0(x^2) + xA_1(x^2)
$$
所以
$$
\begin{aligned}
A(\omega_n^k) &amp;= A_0(\omega_n^{2k}) + \omega_n^kA_1(\omega_n^{2k})\\
&amp;= A_0(\omega_{n/2}^k) + \omega_n^kA_1(\omega_{n/2}^k)
\end{aligned}
$$
**将 $A(\omega_n^k)$ 再分为左右两半**，这里运用了等式  $\omega_{n/2}^k = \omega_{n/2}^{k + n/2}$ 和 $\omega_n^k+\omega_n^{k+n/2} = 0$ :
$$
\begin{aligned}
A(\omega_n^k) &amp;= A_0(\omega_{n/2}^k) + \omega_n^kA_1(\omega_{n/2}^k)\\
A\left(\omega_n^{k+n/2}\right) &amp;= A_0(\omega_{n/2}^k) - \omega_n^kA_1(\omega_{n/2}^k)
\end{aligned}
$$
我们只需要求出 $A_0(\omega_{n/2}^k)$ 和 $A_1(\omega_{n/2}^k)$ ，即求解规模为原来一半的两个子问题 $DFT(A_0), DFT(A_1)$，就能在 $O(n)$ 时间内计算出 $DFT(A)$。

#### Complexity

设次数为 $n - 1$ 的多项式做 DFT 的时间复杂度为 $T(n)$，则
$$
T(n) = 2T(\frac{n}{2}) + O(n)
$$
根据主定理
$$
T(n) = O(n \log n)
$$


## Implementation
### Recursive
上述两种计算方式均可以使用递归实现，这里直接给出代码，不再赘述。

#### DIF

```cpp
const double PI = acos(-1.0);
void dft(std::vector&lt;Complex&gt; &amp;a) {
  int n = a.size(), m = n &gt;&gt; 1;
  if (n == 1) return;
  std::vector&lt;Complex&gt; p(m), q(m);
  for (int i = 0; i &lt; m; i++) {
    p[i] = a[i] + a[i + m];
    q[i] = (a[i] - a[i + m]) * Complex(cos(2 * PI * i / n), sin(2 * PI * i / n));
  }
  dft(p), dft(q);
  for (int i = 0; i &lt; m; i++)
    a[i &lt;&lt; 1] = p[i], a[i &lt;&lt; 1 | 1] = q[i];
}
void idft(std::vector&lt;Complex&gt; &amp;a) {
  dft(a);
  for (auto &amp;v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
```

#### DIT

```cpp
const double PI = acos(-1.0);
void dft(std::vector&lt;Complex&gt; &amp;a) {
  int n = a.size(), m = n &gt;&gt; 1;
  if (n == 1) return;
  std::vector&lt;Complex&gt; p(m), q(m);
  for (int i = 0; i &lt; m; i++) {
    p[i] = a[i &lt;&lt; 1];
    q[i] = a[i &lt;&lt; 1 | 1];
  }
  dft(p), dft(q);
  for (int i = 0; i &lt; m; i++) {
    Complex &amp;u = p[i], v = Complex(cos(2 * PI * i / n), sin(2 * PI * i / n)) * q[i];
    a[i] = u + v, a[i + m] = u - v;
  }
}
void idft(std::vector&lt;Complex&gt; &amp;a) {
  dft(a);
  for (auto &amp;v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
```

下面探讨以 **非递归方式** 实现 `DIF` 与 `DIT`。

### Non-recursive
#### DIT
先讲较常用的DIT。
考虑递归的过程：
$$
\begin{aligned}
&amp;0. (a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7)\\
&amp;1. (a_0, a_2, a_4, a_6)(a_1, a_3, a_5, a_7)\\
&amp;2. (a_0, a_4)(a_2, a_6)(a_1, a_5)(a_3, a_7)\\
&amp;3. (a_0)(a_4)(a_2)(a_6)(a_1)(a_5)(a_3)(a_7)\\
&amp;2&#39; (A_{00}, A_{01})(A_{10},A_{11})(A_{00},A_{01})(A_{10}, A_{11})\\
&amp;1&#39; (A_{00}, A_{01}, A_{02}, A_{03})(A_{10}, A_{11}, A_{12}, A_{13})\\
&amp;0&#39; (A_0, A_1, A_2, A_3, A_4, A_5, A_6, A_7)
\end{aligned}
$$

发现 $0 \rightarrow 3$ 只是在重新安排数据位置，并没有修改数据，如果我们能把映射关系找到，那就可以一步到位，直接从 $3$ 开始。

设一个数在第 $i$ 个阶段 $(0 \leq i \leq \log_2n)$ 的位置为 $p_i$，相对位置为 $p_i&#39;$（`相对位置`指它在括号里的位置，例如上面第 $1$ 阶段 $a_1$ 的相对位置为 $0$）。

容易发现
$$
p&#39;_i = p_i \bmod \frac{n}{2^i}
$$
$$
p_{i + 1} = p_{i} - p&#39;_i + 
\begin{cases}
\dfrac{n}{2^{i+1}}+\dfrac{p&#39;_i-1}{2} &amp; p_i&#39; \equiv 1 \pmod 2\\
\dfrac{p&#39;_i}{2} &amp; p_i&#39; \equiv 0 \pmod 2
\end{cases}
$$
如果将 $p_0$ 写成二进制 $\overline{b_4b_3b_2b_1b_0}$（这里以 $n = 32$ 为例），那么单次变化的过程相当于把二进制的后几位 `rotate` 一位，总的变化过程可以描述为：
$$
\begin{aligned}
\overline{|b_4b_3b_2b_1b_0} \rightarrow \overline{|b_0b_4b_3b_2b_1} \\
\overline{b_0|b_4b_3b_2b_1} \rightarrow \overline{b_0|b_1b_4b_3b_2} \\
\overline{b_0b_1|b_4b_3b_2} \rightarrow \overline{b_0b_1|b_2b_4b_3} \\
\overline{b_0b_1b_2|b_4b_3} \rightarrow \overline{b_0b_1b_2|b_3b_4} \\
\overline{b_0b_1b_2b_3|b_4} \rightarrow \overline{b_0b_1b_2b_3|b_4}
\end{aligned}
$$
可以发现，整个过程实际上是在做 `bit-reverse` 操作！ 

至此我们找到了映射关系，成功把前面的步骤都砍掉了，只剩回溯，可以改成循环。

```cpp
void dft(std::vector&lt;Complex&gt; &amp;a) {
  int n = a.size();
  for (int i = 0, j = 0; i &lt; n; i++) {
    if (i &gt; j) std::swap(a[i], a[j]);
    for (int k = n &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);
  }
  for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        auto t = a[i + j + k] * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j + k] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
      }
    }
  }
}
```

#### DIF

这里先将DIF的过程简单复述：

**第一步：将序列 $a$ 对半分**
$$
\begin{aligned}
&amp;p_k=a_k+a_{k+n/2}, &amp;P(x) = \sum_{k = 0}^{n/2-1}p_kx^k\\
&amp;q_k=\omega_{n}^k(a_k-a_{k+n/2}), &amp;Q(x) = \sum_{k=0}^{n/2-1}q_kx^k
\end{aligned}
$$
**第二步：递归计算 $DFT(p), DFT(q)$**
**第三步：重新安排数据位置**
$$
\begin{aligned}
A\left(\omega_n^{2r}\right) &amp;= P(\omega_{n/2}^r)\\
A\left(\omega_n^{2r+1}\right) &amp;= Q(\omega_{n/2}^r)
\end{aligned}
$$
发现回溯的过程（即第三步）实际上也只是在重新安排数据存储的位置，而且是上面 DIT 第一步的逆过程，所以就是位反转的逆过程，所以还是位反转。

所以最后安排数据位置可以一步搞定，只剩递归压栈的过程，可以改成循环。

```cpp
void dft(vector&lt;Complex&gt; &amp;a) {
  int n = a.size();
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1) {
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        auto t = a[i + j + k];
        a[i + j + k] = (a[i + j] - t) * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j] = a[i + j] + t;
      }
    }
  }
  for (int i = 0, j = 0; i &lt; n; i++) {
    if (i &gt; j) std::swap(a[i], a[j]);
    for (int k = n &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);
  }
}
```

### Combination

发现 DIF 的最后一步和 DIT 的第一步都是位反转，所以先 DIF 再 DIT，就可以省略位反转。

完整代码

```cpp
#include &lt;bits/stdc++.h&gt;

template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}

struct Complex {
  double a, b; // a + bi
  Complex(double a = 0, double b = 0): a(a), b(b) {}
};
inline Complex operator+(const Complex &amp;p, const Complex &amp;q) {
  return Complex(p.a + q.a, p.b + q.b);
}
inline Complex operator-(const Complex &amp;p, const Complex &amp;q) {
  return Complex(p.a - q.a, p.b - q.b);
}
inline Complex operator*(const Complex &amp;p, const Complex &amp;q) {
  return Complex(p.a * q.a - p.b * q.b, p.a * q.b + p.b * q.a);
}

const double PI = acos(-1.0);
void dft(std::vector&lt;Complex&gt; &amp;a) {
  int n = a.size();
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1) {
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        auto t = a[i + j + k];
        a[i + j + k] = (a[i + j] - t) * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j] = a[i + j] + t;
      }
    }
  }
}
void idft(std::vector&lt;Complex&gt; &amp;a) {
  int n = a.size();
  for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        auto t = a[i + j + k] * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j + k] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
      }
    }
  }
  for (auto &amp;v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
int main() {
  int n, m, k;
  readInt(n), readInt(m);
  k = 1 &lt;&lt; std::__lg(n + m) + 1;
  std::vector&lt;Complex&gt; a(k), b(k), c(k);
  for (int i = 0; i &lt;= n; i++) readInt(a[i].a);
  for (int i = 0; i &lt;= m; i++) readInt(b[i].a);
  dft(a), dft(b);
  for (int i = 0; i &lt; k; i++) c[i] = a[i] * b[i];
  idft(c);
  for (int i = 0; i &lt;= n + m; i++) printf(&#34;%d &#34;, (int)(c[i].a + 0.5));
  return 0;
}
```

## Number Theory Transform

如果一个质数存在 $2^n$ 次单位根，那么在这个质数的剩余系下上面的结论依旧成立，可以使用FFT，多称这种FFT为`快速数论变换(Number Theory Transform, NTT)`。

质数 $P$ 的 $2^n$ 次单位根可以通过它的原根计算出来。

最常见的质数是 $P = 998244353$，它的原根 $g = 3$。

下面是常用 NTT 模数的质数和原根表：

&lt;table&gt;
    &lt;tr&gt;
    &lt;td&gt;周期 $n$&lt;/td&gt;
    &lt;td&gt;素数 $p$&lt;/td&gt;
    &lt;td&gt;(原始根)&lt;/td&gt;
    &lt;td&gt;$z$ ($z^n = 1$)&lt;/td&gt;
    &lt;td&gt;$p-1$ の素因数分解&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;26&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;469762049&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;2187&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;26&lt;/sup&gt; * 7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;25&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;167772161&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;243&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;25&lt;/sup&gt; * 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;24&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;754974721&lt;/td&gt;
    &lt;td&gt;11&lt;/td&gt;
    &lt;td&gt;739831874&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;24&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;377487361&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;48510621&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;595591169&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;361399025&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 71&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;645922817&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;224270701&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 7 * 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;880803841&lt;/td&gt;
    &lt;td&gt;26&lt;/td&gt;
    &lt;td&gt;273508579&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 3 * 5 * 7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;897581057&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;872686320&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 107&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;998244353&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;15311432&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;23&lt;/sup&gt; * 7 * 17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;104857601&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;39193363&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 5&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;113246209&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;58671006&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;138412033&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;99040867&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3 * 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;155189249&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;14921912&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 37&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;163577857&lt;/td&gt;
    &lt;td&gt;23&lt;/td&gt;
    &lt;td&gt;121532577&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3 * 13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;230686721&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;71750113&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 5 * 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;415236097&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;73362476&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;666894337&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;147340140&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3 * 53&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;683671553&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;236932120&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 163&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;918552577&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;86995699&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3 * 73&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;935329793&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;86363943&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 223&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;943718401&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;754500478&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 5&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;985661441&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;79986183&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;22&lt;/sup&gt; * 5 * 47&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;111149057&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;60767546&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 53&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;132120577&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;102376994&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;136314881&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;2981173&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 5 * 13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;169869313&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;143354861&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3&lt;sup&gt;4&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;186646529&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;88383805&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 89&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;199229441&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;174670364&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 5 * 19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;211812353&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;113852926&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 101&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;249561089&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;61724276&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 7 * 17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;257949697&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;186470816&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 41&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;270532609&lt;/td&gt;
    &lt;td&gt;22&lt;/td&gt;
    &lt;td&gt;74891632&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 43&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;274726913&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;255478716&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 131&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;383778817&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;324881819&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 61&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;387973121&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;124477810&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 5 * 37&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;459276289&lt;/td&gt;
    &lt;td&gt;11&lt;/td&gt;
    &lt;td&gt;238723101&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 73&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;463470593&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;428228038&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 13 * 17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;576716801&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;153098993&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 5&lt;sup&gt;2&lt;/sup&gt; * 11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;597688321&lt;/td&gt;
    &lt;td&gt;11&lt;/td&gt;
    &lt;td&gt;395834143&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 5 * 19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;635437057&lt;/td&gt;
    &lt;td&gt;11&lt;/td&gt;
    &lt;td&gt;171402456&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 101&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;639631361&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
    &lt;td&gt;432237000&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 5 * 61&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;648019969&lt;/td&gt;
    &lt;td&gt;17&lt;/td&gt;
    &lt;td&gt;592437138&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 103&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;710934529&lt;/td&gt;
    &lt;td&gt;17&lt;/td&gt;
    &lt;td&gt;69533131&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 113&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;715128833&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;355872337&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 11 * 31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;740294657&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;237508734&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 353&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;786432001&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;228383098&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 5&lt;sup&gt;3&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;799014913&lt;/td&gt;
    &lt;td&gt;13&lt;/td&gt;
    &lt;td&gt;374051146&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 127&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;824180737&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;133412682&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 131&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;899678209&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;118485495&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 11 * 13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;924844033&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;44009197&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3&lt;sup&gt;2&lt;/sup&gt; * 7&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;950009857&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;741494216&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 151&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;962592769&lt;/td&gt;
    &lt;td&gt;7&lt;/td&gt;
    &lt;td&gt;695637473&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3&lt;sup&gt;3&lt;/sup&gt; * 17&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;975175681&lt;/td&gt;
    &lt;td&gt;17&lt;/td&gt;
    &lt;td&gt;518451017&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 5 * 31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;1004535809&lt;/td&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;702606812&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 479&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt;&lt;/td&gt;
    &lt;td&gt;1012924417&lt;/td&gt;
    &lt;td&gt;5&lt;/td&gt;
    &lt;td&gt;673144645&lt;/td&gt;
    &lt;td&gt;2&lt;sup&gt;21&lt;/sup&gt; * 3 * 7 * 23&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

代码（预处理单位根，较好地平衡了代码复杂度和常数且有一定的封装度）：

```cpp
#include &lt;bits/stdc++.h&gt;
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }

constexpr int P(998244353), G(3);
inline void inc(int &amp;x, int y) { (x += y) &gt;= P ? x -= P : 0; }
inline int sum(int x, int y) { return x + y &gt;= P ? x + y - P : x + y; }
inline int sub(int x, int y) { return x - y &lt; 0 ? x - y + P : x - y; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P)
    if (k &amp; 1) r = 1LL * r * x % P;
  return r;
}


namespace Polynomial {
using Polynom = std::vector&lt;int&gt;;
int n;
std::vector&lt;int&gt; w;
void getOmega(int k) {
  w.resize(k);
  w[0] = 1;
  int base = fpow(G, (P - 1) / (k &lt;&lt; 1));
  for (int i = 1; i &lt; k; i++) w[i] = 1LL * w[i - 1] * base % P;
}
void dft(Polynom &amp;a) {
  for (int k = n &gt;&gt; 1; k; k &gt;&gt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = (1LL * a[i + j] - y + P) * w[j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void idft(Polynom &amp;a) {
  for (int k = 1; k &lt; n; k &lt;&lt;= 1) {
    getOmega(k);
    for (int i = 0; i &lt; n; i += k &lt;&lt; 1) {
      for (int j = 0; j &lt; k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[j] % P;
        a[i + j] = sum(x, y);
        a[i + j + k] = sub(x, y);
      }
    }
  }
  int inv = fpow(n);
  for (int i = 0; i &lt; n; i++) a[i] = 1LL * a[i] * inv % P;
  std::reverse(a.begin() + 1, a.end());
}
} // namespace Polynom
using Polynomial::dft;
using Polynomial::idft;
void poly_multiply(unsigned *A, int n, unsigned *B, int m, unsigned *C) {
  int k = Polynomial::n = 1 &lt;&lt; std::__lg(n + m) + 1;
  std::vector&lt;int&gt; a(k), b(k);
  for (int i = 0; i &lt;= n; i++) a[i] = A[i];
  for (int i = 0; i &lt;= m; i++) b[i] = B[i];
  dft(a), dft(b);
  for (int i = 0; i &lt; k; i++) a[i] = 1LL * a[i] * b[i] % P;
  idft(a);
  for (int i = 0; i &lt;= n + m; i++) C[i] = a[i];
}
int main() {
  int n, m, k;
  readInt(n, m);
  Polynomial::n = k = 1 &lt;&lt; std::__lg(n + m) + 1;
  std::vector&lt;int&gt; a(k), b(k);
  for (int i = 0; i &lt;= n; i++) readInt(a[i]);
  for (int i = 0; i &lt;= m; i++) readInt(b[i]);
  dft(a), dft(b);
  for (int i = 0; i &lt; k; i++) a[i] = 1LL * a[i] * b[i] % P;
  idft(a);
  for (int i = 0; i &lt;= n + m; i++) printf(&#34;%d &#34;, a[i]);
  return 0;
}

```


## 常数优化

### 求系数为整数的多项式乘积 $A(x)B(x)$

$$
\begin{aligned}
P(x) &amp;= A(x)+ iB(x)\\
P^2(x) &amp;= A^2(x) -B^2(x) + i2A(x)B(x)\\
A(x)B(x) &amp;= \frac12\operatorname{Imag}P^2(x) 
\end{aligned}
$$

### 求系数为整数的多项式 $A(x), B(x)$ 的点值表示

$$
\begin{aligned}
P(x) &amp;= A(x)+ iB(x)\\
\overline{P}(x) &amp;= A(x)-iB(x)\\
A(x) &amp;= \frac{P(x) + \overline P (x)}{2}\\
B(x) &amp;= \frac{P(x) - \overline P (x)}{2i}
\end{aligned}
$$

毛爷爷结论：
$$
\overline P(\omega^k) = \overline{P(\omega^{-k})}
$$
所以只要一次DFT。

## 拆系数FFT

### 求 $A(x)B(x)$，系数范围 $[0,2^{30})$


$$
\begin{aligned}
A(x) &amp;= A_0(x)&amp; + &amp;2^{15}A_1(x) &amp;  \\
B(x) &amp;= B_0(x)&amp; + &amp;2^{15}B_1(x) &amp;  \\
A(x)B(x) &amp;= A_0(x)B_0(x)&amp; + &amp;2^{15}(A_0(x)B_1(x) + A_1(x)B_0(x)) + &amp;2^{30}A_1(x)B_1(x)
\end{aligned}
$$


先两次 DFT 求 $A_0, A_1, B_0, B_1$ 的点值表示。

然后两次 IDFT(等价于DFT) 求 $A_0B_0, A_0B_1, A_1B_0, A_1B_1$ 的系数。

## Bluestein’s Algorithm

上面提到的 FFT 算法虽然限制了 $n$ 为 2 的次幂，但在大多数情况下已经足够解决问题。

对于更一般的 $n$ 需要用到 `Bluestein’s Algorithm` ，可以参考2016年国家集训队论文《再探快速傅里叶变换——毛啸》。

后续可能会填这个坑。- https://blog.asukakyle.top/post/fft/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces1148H] Holy Diver</title>
        <link>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</link>
        <pubDate>Sat, 13 Mar 2021 00:43:08 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codeforces1148h-holy-diver/ -
&gt; 给定一个最初为空的数组，然后进行 $n$ 次操作，每次操作给定 $x,l,r,k$，在数组末尾插入 $x$ ，然后查询满足 $mex(\{a_i, a_{i + 1}, \dots, a_j\}) = k$ 的数对 $(i,j)$ 的个数，**强制在线**。
&gt;
&gt; $mex(S)$ 表示集合 $S$ 中最小的未出现的 **自然数**。
&gt;
&gt; $n \leq 2 \times 10^5$。

为表示方便，下面记 $mex(i, j) = mex(\{a_i, a_{i + 1}, \dots, a_j\})$。

容易发现，如果向集合 $S$ 中添加数，$mex(S)$ 不会减小。

所以如果固定右端点 $j$，$mex(i, j)$ 是**非严格单调减**的；固定左端点 $i$，$mex(i, j)$ 是**非严格单调增**的。

维护一个 $n \times n$ 矩阵，$A[i][j] = mex(j, i)$，则矩阵 $A$  的每一行从左到右都是非严格单调减的，每一列从上到下都是非严格单调增的。

第 $i$ 次操作增加一个数 $x$，考虑从第 $i - 1$ 行拓展到第 $i$ 行时矩阵 $A$ 的变化。

首先 $A[i][i]=[x=0]$。

下面只考虑 $j &lt; i$ 的情况。

如果 $A[i-1][j]=x$，则 $A[i][j]&gt;x$，否则 $A[i][j] = A[i - 1][j]$。

所以每次变化的只有等于 $x$ 的那些位置，根据单调性，这是一段区间，记为 $[p,q]$。

设 $j \in [p, q]$，要求 $mex(j, i)$，只需要知道最后一次出现的位置小于 $j$ 的最小的数。所以用线段树维护序列 $seq_{lastpos[x]} = x$ ，每次求区间最小值，找到对应位置 $index$，这个位置右边的所有 $A[i][j]$ 都等于这个最小值，然后令 $q = index$，反复迭代，直到待求区间为空。

分析一下这个操作的复杂度，每次相当于删除一个区间 $[p,q]$，添加若干个小区间。

开始只有一个区间，最后的区间数不超过 $n$，中间只会删除最多 $n$ 次区间。

所以添加区间的总次数不会超过 $2n$ ，复杂度为 $O(n \log n)$。

然后考虑回答询问。

## 矩形交的面积

我们用四元组 $(top,bottom,left,right)$ 描述一个矩形 $\{(i,j):top \leq i \leq bottom,left \leq j \leq right\}$。

每次询问可以看作是询问矩形 $(l, r, l, r)$ 内 $A[i][j]=k$ 的个数。

那么由上面 $mex$ 的单调性可以发现，$A[i][j] = k$ 的点可以组成一个个连通块，每个连通块由若干个矩形构成**阶梯状**（矩形的 $left$ 相同，$right$ 递增）。 且前一个连通块的 $right$ 小于后一个连通块的 $left$。

问题转化为求这些矩形与询问矩形交的面积之和。

用 `std::vector` 存下每个 $k$ 的所有矩形，维护前缀面积和，二分出相交与非相交的临界点，对于完全包含的用前缀和搞定，对于相交却不包含的，由于是阶梯状，所以也可以 $O(1)$ 计算，细节有点多。

由上面的复杂度分析可知，所有矩形的数量不会超过 $2n$ 个，所以总复杂度 $O(n \log n)$。

```cpp
#include &lt;bits/stdc++.h&gt;
#ifdef LOCAL
#define dbg(args...) std::cerr &lt;&lt; &#34;\033[32;1m&#34; &lt;&lt; #args &lt;&lt; &#34; -&gt; &#34;, err(args)
#else
#define dbg(...)
#endif
inline void err() { std::cerr &lt;&lt; &#34;\033[0m\n&#34;; }
template&lt;class T, class... U&gt;
inline void err(const T &amp;x, const U &amp;... a) { std::cerr &lt;&lt; x &lt;&lt; &#39; &#39;; err(a...); }
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }

typedef long long LL;
typedef std::pair&lt;int, int&gt; PII;

constexpr int N(2e5 + 5);
int n;
struct Rect {
  int t, b, l, r; // top, bottem, left, right (closed intervals)
  Rect(int t, int b, int l, int r): t(t), b(b), l(l), r(r) {}
  inline Rect operator&amp;(const Rect &amp;rhs) const {
    return Rect(std::max(t, rhs.t), std::min(b, rhs.b), std::max(l, rhs.l), std::min(r, rhs.r));
  }
  inline LL area() const { return 1LL * std::max(0, b - t + 1) * std::max(0, r - l + 1); }
};
int pos[N];
std::vector&lt;Rect&gt; rect[N]; 
std::vector&lt;LL&gt; sum[N];

namespace SegTree {
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
int min[N &lt;&lt; 2];
void update(int o, int l, int r, int x, int y) {
  if (l == r) {
    min[o] = y; return;
  }
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? update(ls, l, m, x, y) : update(rs, m + 1, r, x, y);
  min[o] = std::min(min[ls], min[rs]);
}
int ask(int o, int l, int r, int x) {
  if (x &lt; l) return n;
  if (r &lt;= x) return min[o];
  int m = l + r &gt;&gt; 1;
  return std::min(ask(ls, l, m, x), ask(rs, m + 1, r, x));
}
}

bool vis[N];

std::set&lt;int&gt; s;
PII now[N]; // interval
int top[N];
void insert(int i, int v, int l, int r) {
  if (s.count(v)) {
    if (top[v] == i) {
      assert(l == now[v].second + 1);
      now[v].second = r;
      return;
    }
    l = now[v].first;
    rect[v].emplace_back(top[v], i - 1, now[v].first, now[v].second);
    sum[v].push_back(sum[v].back() + rect[v].back().area());
  } else {
    s.insert(v);
  }
  top[v] = i, now[v].first = l, now[v].second = r;
}
int main() {
  readInt(n);
  for (int i = 0; i &lt;= n; i++) rect[i].emplace_back(0, -1, 0, -1), sum[i].push_back(0);
  LL ans = 0;
  for (int i  = 1, mex = 0, x, l, r, k; i &lt;= n; i++) {
    readInt(x, l, r, k);
    x = (x + ans) % (n + 1);
    l = (l + ans) % i + 1;
    r = (r + ans) % i + 1;
    k = (k + ans) % (n + 1);
    if (l &gt; r) std::swap(l, r);
    dbg(x, l, r, k);
    // append x
    for (vis[x] = 1; vis[mex]; mex++) ;
    SegTree::update(1, 1, n, i, x);
    if (pos[x]) SegTree::update(1, 1, n, pos[x], n);
    pos[x] = i;
    auto it = s.find(x);
    if (it != s.end()) {
      s.erase(it);
      auto [p, q] = now[x];
      rect[x].emplace_back(top[x], i - 1, p, q);
      sum[x].push_back(sum[x].back() + rect[x].back().area());
      while (p &lt;= q) {
        int v = SegTree::ask(1, 1, n, q - 1), idx = smin(v, mex) ? 0 : pos[v];
        // dbg(v, pos[v]);
        insert(i, v, idx + 1, q);
        q = idx;
      }
    }
    insert(i, !x, i, i);
    // ask k
    auto &amp;a = rect[k];
    auto &amp;b = sum[k];
    auto qrect = Rect(l, r, l, r);
    ans = 0;
    // for (auto u: a) ans += (u &amp; qrect).area();
    int p = std::partition_point(a.begin(), a.end(), [&amp;](const Rect &amp;v) { return v.b &lt; l || v.r &lt; l; }) - a.begin();
    int mp = std::partition_point(a.begin(), a.end(), [&amp;](const Rect &amp;v) { return v.l &lt; l; }) - a.begin() - 1;
    int mq = std::partition_point(a.begin(), a.end(), [&amp;](const Rect &amp;v) { return v.l &lt;= r; }) - a.begin() - 1;
    int q = std::partition_point(a.begin(), a.end(), [&amp;](const Rect &amp;v) { return v.t &lt;= r &amp;&amp; v.l &lt;= r; }) - a.begin() - 1;
    
    if (p &gt; q) {
      ans = 0;
    } else if (p == q) {
      ans = (a[p] &amp; qrect).area();
    } else {
      ans = b[q] - b[p - 1];
      ans -= a[p].area() - (a[p] &amp; qrect).area();
      ans -= a[q].area() - (a[q] &amp; qrect).area();
      p++, q--;
      smin(mp, q), smax(mq, mp + 1);
      if (p &lt;= mp) assert(a[p].l == a[mp].l), ans -= Rect(a[p].t, a[mp].b, a[p].l, l - 1).area();
      if (mq &lt;= q) assert(a[mq].l == a[q].l), ans -= b[q] - b[mq - 1] - Rect(a[mq].t, a[q].b, a[q].l, r).area();
    }
    if (s.count(k)) ans += (Rect(top[k], i, now[k].first, now[k].second) &amp; qrect).area();
    printf(&#34;%lld\n&#34;, ans);
  }
  return 0;
}
```



## 可持久化线段树

接上矩阵的思路。

看作每个数维护一个二维数组，每次矩阵内的数 $+1$ ，然后询问一个矩阵的和。

这个可以用可持久化线段树维护。

可持久化线段树可以想象成一个矩阵 $a[i][j]$，第一维是时间，第二维是区间。

类似于树状数组的区间加区间和的方法，维护差分 $b[i][j] = a[i][j] - a[i - 1][j]$。

即每次修改时，在 $top$ 时间对区间 $(left,right)+1$，在 $bottom + 1$ 时间对区间 $(left, right)-1$ 

查询矩阵和（本题中时间和区间都是 $[l, r]$），即
$$
\begin{aligned}
  &amp;\sum_{i = l}^r\sum_{j = l}^r a[i][j]\\
= &amp;\sum_{i = l}^r \sum_{k = 1}^i \sum_{j = l}^rb[k][j]\\
= &amp;\sum_{k = 1}^r \sum_{i = k}^r \sum_{j = l}^rb[k][j]\\
= &amp;\sum_{k = 1}^r (r - k + 1) \left(\sum_{j = l}^rb[k][j]\right)\\
&amp;\{\text{note } s_k = \sum_{j = l}^rb[k][j]\}\\
= &amp;(r + 1)\sum_{k = 1}^rs_k - \sum_{k = 1}^rk\cdot s_k
\end{aligned}
$$
所以直接在线段树上维护两个值 $v, v \times time$ 就行了。

每个数都要维护可持久化线段树，要注意写法，容易爆内存（直接改上面的程序成功MLE了）。

```cpp
#include &lt;bits/stdc++.h&gt;
#ifdef LOCAL
#define dbg(args...) std::cerr &lt;&lt; &#34;\033[32;1m&#34; &lt;&lt; #args &lt;&lt; &#34; -&gt; &#34;, err(args)
#else
#define dbg(...)
#endif
inline void err() { std::cerr &lt;&lt; &#34;\033[0m\n&#34;; }
template&lt;class T, class... U&gt;
inline void err(const T &amp;x, const U &amp;... a) { std::cerr &lt;&lt; x &lt;&lt; &#39; &#39;; err(a...); }
template &lt;class T&gt;
inline void readInt(T &amp;w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == &#39;-&#39;;
  for (w = c &amp; 15; isdigit(c = getchar());) w = w * 10 + (c &amp; 15);
  if (p) w = -w;
}
template &lt;class T, class... U&gt;
inline void readInt(T &amp;w, U &amp;... a) { readInt(w), readInt(a...); }
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }

typedef long long LL;
typedef std::pair&lt;int, int&gt; PII;

constexpr int N(2e5 + 5);
int n, pos[N];
namespace SegTree {
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
int min[N &lt;&lt; 2];
void update(int o, int l, int r, int x, int y) {
  if (l == r) {
    min[o] = y; return;
  }
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? update(ls, l, m, x, y) : update(rs, m + 1, r, x, y);
  min[o] = std::min(min[ls], min[rs]);
}
int ask(int o, int l, int r, int x) {
  if (x &lt; l) return n;
  if (r &lt;= x) return min[o];
  int m = l + r &gt;&gt; 1;
  return std::min(ask(ls, l, m, x), ask(rs, m + 1, r, x));
}
#undef ls
#undef rs
}

struct Node {
  Node *ls, *rs;
  int v; LL vi;
  LL sumv, sumvi;
} t[N * 100], *null = t, *ptr = t + 1;

class PerSegTree {
 public:
  PerSegTree(): root() { root[0] = null; }
  void ins(int i, int l, int r, int v) {
    auto it = root.rbegin();
    assert(it-&gt;first &lt;= i);
    ins(root[i] = it-&gt;second, 1, n, l, r, v, i);
  }
  LL ask(int l, int r) {
    coef = r + 1;
    return ask((--root.upper_bound(r))-&gt;second, 1, n, l, r);
  }
 private:
  std::map&lt;int, Node*&gt; root;
  void ins(Node *&amp;o, int l, int r, int x, int y, int v, int i) {
    *ptr = *o, o = ptr++;
    o-&gt;sumv += 1LL * v * (y - x + 1);
    o-&gt;sumvi += 1LL * v * i * (y - x + 1);
    if (x == l &amp;&amp; r == y) {
      o-&gt;v += v, o-&gt;vi += 1LL * v * i;
      return;
    }
    int m = l + r &gt;&gt; 1;
    if (y &lt;= m)
      ins(o-&gt;ls, l, m, x, y, v, i);
    else if (x &gt; m)
      ins(o-&gt;rs, m + 1, r, x, y, v, i);
    else
      ins(o-&gt;ls, l, m, x, m, v, i), ins(o-&gt;rs, m + 1, r, m + 1, y, v, i);
  }
  int coef;
  LL ask(Node *o, int l, int r, int x, int y) {
    if (x == l &amp;&amp; r == y) return coef * o-&gt;sumv - o-&gt;sumvi;
    int m = l + r &gt;&gt; 1;
    LL ans = (1LL * coef * o-&gt;v - o-&gt;vi) * (y - x + 1);
    if (y &lt;= m)
      ans += ask(o-&gt;ls, l, m, x, y);
    else if (x &gt; m)
      ans += ask(o-&gt;rs, m + 1, r, x, y);
    else
      ans += ask(o-&gt;ls, l, m, x, m) + ask(o-&gt;rs, m + 1, r, m + 1, y);
    return ans;
  }
};

bool vis[N];
std::map&lt;int, PII&gt; s;
int main() {
  null-&gt;ls = null-&gt;rs = null;
  readInt(n);
  std::vector&lt;PerSegTree&gt; t(n + 1);
  LL ans = 0;
  for (int i = 1, mex = 0, x, l, r, k; i &lt;= n; i++) {
    readInt(x, l, r, k);
    x = (x + ans) % (n + 1);
    l = (l + ans) % i + 1;
    r = (r + ans) % i + 1;
    k = (k + ans) % (n + 1);
    if (l &gt; r) std::swap(l, r);
    dbg(x, l, r, k);
    for (vis[x] = 1; vis[mex]; mex++) ;
    SegTree::update(1, 1, n, i, x);
    if (pos[x]) SegTree::update(1, 1, n, pos[x], n);
    pos[x] = i;
    auto it = s.find(x);
    if (it != s.end()) {
      auto [p, q] = it-&gt;second;
      s.erase(it);
      t[x].ins(i, p, q, -1);
      while (p &lt;= q) {
        int v = SegTree::ask(1, 1, n, q - 1), idx = smin(v, mex) ? 0 : pos[v];
        t[v].ins(i, std::max(p, idx + 1), q, 1);
        s[v] = PII(idx + 1, q);
        q = idx;
      }
    }
    auto &amp;[p, q] = s[!x];
    p ? q = i : p = q = i;
    t[!x].ins(i, i, i, 1);
    ans = t[k].ask(l, r);
    printf(&#34;%lld\n&#34;, ans);
  }  
  return 0;
}
```

- https://blog.asukakyle.top/post/codeforces1148h-holy-diver/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces566C] Logistical Questions</title>
        <link>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</link>
        <pubDate>Mon, 07 Dec 2020 21:36:10 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codeforces566c-logistical-questions/ -
&gt; 一棵 $n$ 个节点的树，点有点权，边有边权。求这棵树的一个点 $r$ 使下面的式子最小：
&gt; $$
&gt; \sum_{i \in Tree} val_i \times dist(i, r)^{\frac32}
&gt; $$
&gt; $n \le 2 \times 10^5, val_i, dist(u, v) \ge 0$。

带权重心问题，有点妙。

设
$$
f(x) = \sum_{i \in Tree} val_i \times dist(i, x)^{\frac32}
$$
这里函数 $f$ 的定义域是整棵树（不仅包括原来的点，还包括边上的点 ）。

下面研究这个函数的性质。

树上的函数显然不太方便研究，所以考虑换一个 $\mathbf R$ 上的函数研究。

随便选择一条树上路径 $u \rightarrow v$ 作为 $x$ 轴，把 $u$ 当作原点，这样 $x$ 就是路径上的点到 $u$ 的距离。

![](1.png)

这里以 $0 \rightarrow 5$ 为例，节点 $6 \dots 11$ 分别代表其父亲的一些子树。

记 $d_i = dist(i, 0)$，路径上的点分别考虑贡献：
$$
f_i(x) =
\begin{cases}
\sum_{c \in subtree(i)} val_i\left (dist(i, c) + d_i - x\right)^\frac32 &amp; x \le d_i\\
\sum_{c \in subtree(i)} val_i\left(dist(i, c) + x - d_i\right)^\frac32 &amp; x &gt; d_i
\end{cases}\\
f(x) = f_0(x) + f_1(x) + f_2(x) + f_3(x) + f_4(x) + f_5(x)
$$
发现 $f_i(x)$ 可以写成下面这种形式（其中 $c_1-x \ge 0, c_2 + x \ge 0$）
$$
f_i(x) =
\begin{cases}
\sum v(c_1 - x)^\frac32 &amp; x \le d_i\\
\sum v(c_2 + x)^\frac32 &amp; x &gt; d_i
\end{cases}
$$


求导（这里分段函数的分界点处显然可导）
$$
f_i&#39;(x) =
\begin{cases}
-\frac32\sum v(c_1 - x)^\frac12 &amp; x \le d_i\\
\frac32\sum v(c_2 + x)^\frac12 &amp; x &gt; d_i
\end{cases}
\\
f_i&#39;&#39;(x) =
\begin{cases}
\frac34\sum v(c_1 - x)^{-\frac12} &amp; x \le d_i\\
\frac34\sum v(c_2 + x)^{-\frac12} &amp; x &gt; d_i
\end{cases}
$$
发现 $f&#39;&#39;_i(x) \ge 0$，所以 $f&#39;&#39;(x) = \sum_if&#39;&#39;_i(x) \ge 0$，所以 $f(x)$ 是个凸函数，至多一个最小值。

注意到对于树上任意路径这个结论都成立，所以固定起点 $u$，对于所有终点 $v$ 求一次最小值就可以得到答案。

下图中 $2, 3, 4$ 都代表子树，假设当前在 $1$ ，需要考虑 $1 \rightarrow 2, 3, 4 \rightarrow \dots$ 几种路径。

![](2.png)

对于路径 $1 \rightarrow i \rightarrow \dots$，有
$$
\begin{aligned}
f&#39;(0)_i &amp;= \frac32\left(\sum_{x\in 0} val_xdist(x, 1)^\frac12 - \sum_{x\in i}val_xdist(x, 1)^\frac12\right)\\
&amp;= \frac32\left(\sum_{x}val_xdist(x, 1)^\frac12 - 2\sum_{x\in i}val_xdist(x, 1)^\frac12\right)
\end{aligned}
$$
观察这个式子，发现最多只有一个 $i$ 会使导数小于零，就是使 $\sum_{x \in i}val_xdist(x, i)^{\frac12}$ 最大的那个。

所以我们只需要向导数小于零的那个方向走就可以了。

假如从根出发向叶子的方向走，最多走 $maxdep$ 次，每次需要花 $O(n)$ 时间计算答案和导数， 最坏是 $O(n^2)$ 的，考虑优化。

每次走到一个节点时，需要考虑的节点范围会缩小到当前节点的子树内，如果每次找到当前子树的重心，每次规模会减半，这样最多走 $\log n$ 次，最终复杂度 $O(n \log n)$。

```cpp
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; }
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ? x = y, 1 : 0; }

constexpr int N(2e5 + 5);
int n, a[N], head[N];
struct Edge {
  int v, w, next;
} e[N &lt;&lt; 1];
void addEdge(int x, int y, int z) {
  static int c = 0;
  e[++c] = { y, z, head[x] }, head[x] = c;
  e[++c] = { x, z, head[y] }, head[y] = c;
}
bool vis[N];
int rt, tSize, mSize, siz[N];
void getSize(int x, int fa) {
  siz[x] = 1;
  for (int i = head[x]; i; i = e[i].next) {
    int y = e[i].v;
    if (y == fa || vis[y])  continue;
    getSize(y, x);
    siz[x] += siz[y];
  }
}
void findrt(int x, int fa) {
  int max = tSize - siz[x];
  for (int i = head[x]; i; i = e[i].next) {
    int y = e[i].v;
    if (y == fa || vis[y]) continue;
    findrt(y, x);
    smax(max, siz[y]);
  }
  if (smin(mSize, max)) rt = x;
}
double ans = INFINITY, f, diff;
int pos;
void dfs(int x, int fa, int d) {
  f += a[x] * sqrt(d) * d, diff += a[x] * sqrt(d);
  for (int i = head[x]; i; i = e[i].next) {
    int y = e[i].v;
    if (y == fa) continue;
    dfs(y, x, d + e[i].w);
  }
}
void solve(int x) {
  if (vis[x]) return;
  vis[x] = 1;
  int p;
  double s = 0, m = 0;
  f = 0;
  for (int i = head[x]; i; i = e[i].next) {
    int y = e[i].v;
    diff = 0;
    dfs(y, x, e[i].w);
    if (smax(m, diff)) p = y;
    s += diff;
  }
  if (smin(ans, f)) pos = x;
  if (m * 2 &gt; s &amp;&amp; !vis[p]) {
    getSize(p, 0);
    tSize = mSize = siz[p];
    findrt(p, 0);
    solve(rt);
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n;
  for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i];
  for (int i = 1, x, y, z; i &lt; n; i++) {
    std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    addEdge(x, y, z);
  }
  getSize(1, 0), tSize = mSize = n, findrt(1, 0), solve(rt);
  printf(&#34;%d %.10f&#34;, pos, ans);
  return 0;
}

```- https://blog.asukakyle.top/post/codeforces566c-logistical-questions/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 