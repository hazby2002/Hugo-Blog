<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/</link>
    <description>Recent content on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 05 Aug 2022 23:16:50 +0800</lastBuildDate>
    
        <atom:link href="https://blog.asukakyle.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>2021牛客多校3</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder3/</link>
        <pubDate>Sat, 31 Jul 2021 11:28:53 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder3/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder3/ -| 题号 |                             标题                             | 团队的状态 |
| :--: | :----------------------------------------------------------: | :--------: |
|  A   | [Guess and lies](https://ac.nowcoder.com/acm/contest/11254/A) |    通过    |
|  B   | [Black and white](https://ac.nowcoder.com/acm/contest/11254/B) |    通过    |
|  C   | [Minimum grid](https://ac.nowcoder.com/acm/contest/11254/C)  |    通过    |
|  D   |     [Count](https://ac.nowcoder.com/acm/contest/11254/D)     |    通过    |
|  E   |     [Math](https://ac.nowcoder.com/acm/contest/11254/E)      |    通过    |
|  F   |    [24dian](https://ac.nowcoder.com/acm/contest/11254/F)     |    通过    |
|  G   | [Yu Ling(Ling YueZheng) and Colorful Tree](https://ac.nowcoder.com/acm/contest/11254/G) |    通过    |
|  H   | [Ling Qiu, Luna and Triple Backpack](https://ac.nowcoder.com/acm/contest/11254/H) |   未通过   |
|  I   | [Kuriyama Mirai and Exclusive Or](https://ac.nowcoder.com/acm/contest/11254/I) |    通过    |
|  J   | [Counting Triangles](https://ac.nowcoder.com/acm/contest/11254/J) |    通过    |


## [Guess and lies](https://ac.nowcoder.com/acm/contest/11254/A) 

## [Black and white](https://ac.nowcoder.com/acm/contest/11254/B) 

## [Minimum grid](https://ac.nowcoder.com/acm/contest/11254/C)  

## [Count](https://ac.nowcoder.com/acm/contest/11254/D)     

## [Math](https://ac.nowcoder.com/acm/contest/11254/E)      

## [24dian](https://ac.nowcoder.com/acm/contest/11254/F)     

## [Yu Ling(Ling YueZheng) and Colorful Tree](https://ac.nowcoder.com/acm/contest/11254/G) 
&gt; 一棵 $n$ 个点的树，1 是根。$q$ 次操作：
&gt;
&gt; - `0 u x` 令 $\mathrm{color}_u=x$。
&gt; - `1 u l r x` 询问离 $u$ 的最近祖先 $v$ 满足 $l \leq \mathrm{color}_v \leq r, x \mid \mathrm{color}_v$。
&gt;
&gt; $n, q \leq 1.1\times 10^5, 1 \leq x \leq n$，**染色操作的点和颜色都互不相同**。

跑一遍 dfs 序，祖先的限制转化为 $\mathrm{in}_v \leq \mathrm{in}_u \leq \mathrm{out}_v$。

离线，将染色 $x$ 和询问颜色 $x$ 的操作都存下来，分别处理。

对于颜色 $x$ 的询问，将 $l, r$ 离散化，然后枚举 $x$ 的倍数去掉 $x \mid \mathrm{color}_v$ 的限制。

剩下来是一个三维偏序问题：
$$
\begin{cases}
t_v &lt; t_u, \\
\mathrm{in}_v \leq \mathrm{in}_u \leq \mathrm{out}_v,\\
l \leq \mathrm{color}_v \leq r
\end{cases}
$$
可以树套树解决。

对于离散化后的颜色区间建立线段树，将询问和修改都挂在线段树上，去掉第三维。

然后对线段树的每个节点做一个二维偏序即可。

复杂度 $O(n \log^3 n)$。

```cpp
// Author:  HolyK
// Created: Sun Jul 25 14:59:29 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(1.1e5 + 5);
int n, m;
std::vector&lt;PII&gt; g[N];
LL d[N];
int in[N], out[N], cnt;
void dfs(int x, int p) {
  in[x] = cnt++;
  for (auto [y, z] : g[x]) {
    if (y == p) continue;
    d[y] = d[x] + z;
    dfs(y, x);
  }
  out[x] = cnt;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1, x, y, z; i &lt; n; i++) {
    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    x--, y--;
    g[x].emplace_back(y, z);
    g[y].emplace_back(x, z);
  }
  d[0] = 1;
  dfs(0, -1);
  std::vector&lt;PII&gt; a(n + 1, PII(-1, -1));
  using Qry = std::array&lt;int, 4&gt;;
  std::vector&lt;std::vector&lt;Qry&gt;&gt; q(n + 1);
  std::vector&lt;LL&gt; ans(m);
  for (int i = 0; i &lt; m; i++) {
    int opt, u, l, r, x;
    cin &gt;&gt; opt &gt;&gt; u;
    u--;
    if (opt == 0) {
      cin &gt;&gt; x;
      assert(a[x].first == -1);
      a[x] = {u, i};
      ans[i] = -1;
    } else {
      cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;
      l = (l + x - 1) / x * x;
      r = (r + x) / x * x;
      ans[i] = 1e18;
      if (l &lt; r) {
        q[x].push_back({u, l, r, i});
      }
    }
  }
  std::vector&lt;int&gt; p;
  std::vector&lt;Qry&gt; b;
  for (int x = 1; x &lt;= n; x++) {
    if (q[x].empty()) continue;
    p.clear();
    for (auto [u, l, r, id] : q[x]) {
      p.push_back(l);
      p.push_back(r);
    }
    std::sort(p.begin(), p.end());
    p.resize(std::unique(p.begin(), p.end()) - p.begin());
    b.clear();
#define low(x) int(std::lower_bound(p.begin(), p.end(), x) - p.begin())
#define upp(x) int(std::upper_bound(p.begin(), p.end(), x) - p.begin())
    for (int y = p[0]; y &lt; p.back(); y += x) {
      if (a[y].first == -1) continue;
      auto [u, id] = a[y];
      b.push_back({id, u, upp(y) - 1, -1});
    }
    for (auto [u, l, r, id] : q[x]) {
      b.push_back({id, u, low(l), low(r)});
    }
    std::sort(b.begin(), b.end());
    int s = 1 &lt;&lt; std::__lg(p.size() * 2 - 1);
    std::vector&lt;int&gt; len(2 * s);
    for (auto [id, u, l, r] : b) {
      if (r == -1) {
        for (l += s; l; l &gt;&gt;= 1) {
          len[l]++;
        }
      } else {
        for (l += s, r += s; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
          if (l &amp; 1) {
            len[l++]++;
          }
          if (r &amp; 1) {
            len[--r]++;
          }
        }
      }
    }
    std::vector&lt;std::vector&lt;PII&gt;&gt; t(2 * s);
    for (int i = 1; i &lt; 2 * s; i++) t.reserve(len[i]);
    
    for (auto [id, u, l, r] : b) {
      if (r == -1) {
        for (l += s; l; l &gt;&gt;= 1) {
          t[l].emplace_back(id, u);
        }
      } else {
        for (l += s, r += s; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
          if (l &amp; 1) {
            t[l++].emplace_back(id, u);
          }
          if (r &amp; 1) {
            t[--r].emplace_back(id, u);
          }
        }
      }
    }
    for (auto &amp;v : t) {
      if (v.empty()) continue;
      p.clear();
      for (auto [id, u] : v) {
        if (~ans[id]) p.push_back(in[u]);
      }
      std::sort(p.begin(), p.end());
      p.resize(std::unique(p.begin(), p.end()) - p.begin());
      int s = 1 &lt;&lt; std::__lg(p.size() * 2 - 1);
      std::vector&lt;LL&gt; max(2 * s);
      for (auto [id, u] : v) {
        if (ans[id] == -1) {
          for (int l = s + low(in[u]), r = s + low(out[u]); l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
            if (l &amp; 1) smax(max[l++], d[u]);
            if (r &amp; 1) smax(max[--r], d[u]);
          }
        } else {
          LL m = 0;
          for (int l = s + low(in[u]); l; l &gt;&gt;= 1) {
            smax(m, max[l]);
          }
          if (m) smin(ans[id], d[u] - m);
        }
      }
    }
  }
  for (int i = 0; i &lt; m; i++) {
    if (~ans[i]) {
      if (ans[i] &lt; 1e18) {
        std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
      } else {
        std::cout &lt;&lt; &#34;Impossible!\n&#34;;
      }
    }
  }
  return 0;
}
```

## [Ling Qiu, Luna and Triple Backpack](https://ac.nowcoder.com/acm/contest/11254/H)

## [Kuriyama Mirai and Exclusive Or](https://ac.nowcoder.com/acm/contest/11254/I) 

## [Counting Triangles](https://ac.nowcoder.com/acm/contest/11254/J) 

- https://blog.asukakyle.top/post/2021nowcoder3/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[NOI2021] 密码箱</title>
        <link>https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/</link>
        <pubDate>Fri, 30 Jul 2021 20:54:17 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/ -## 题面
![](statement.png)

## 题解
设向量 $\begin{pmatrix}x \\ y\end{pmatrix}$ 表示分数 $\dfrac x y$。

那么整数加分数的运算 $a+\dfrac x y = \dfrac{x + ay}{y}$ 可以表示为
$$
\begin{pmatrix}
1 &amp; a\\
0 &amp; 1
\end{pmatrix}
\begin{pmatrix}
x\\y
\end{pmatrix}
=
\begin{pmatrix}
x+ay\\
y
\end{pmatrix}
$$
设 $a_k = \dfrac{x}{y}$，则 $a_{k-1}&#39;=a_{k-1}+\dfrac y x$，写成矩阵形式为

$$
\begin{pmatrix}
a_{k-1} &amp; 1\\
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
x\\y
\end{pmatrix}
=
\begin{pmatrix}
a_{k-1}x+y\\
x
\end{pmatrix}
$$
记
$$
F =
\begin{pmatrix}
a_{0} &amp; 1\\
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
a_{1} &amp; 1\\
1 &amp; 0
\end{pmatrix}
\dots
\begin{pmatrix}
a_{k} &amp; 1\\
1 &amp; 0
\end{pmatrix}
$$
则
$$
f(a_0, a_1, \dots, a_n) = F_{0, 0}
$$
考虑维护矩阵 $F$。

操作`W`相当于右乘矩阵 $\begin{pmatrix}1 &amp; 0\\1 &amp; 1\end{pmatrix}$
$$
\begin{pmatrix}
a_{k} &amp; 1\\
1 &amp; 0
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0\\
1 &amp; 1
\end{pmatrix}
=
\begin{pmatrix}
a_{k} + 1 &amp; 1\\
1 &amp; 0
\end{pmatrix}
$$
操作`E`先考虑第二种情况，可以发现是右乘矩阵 $\begin{pmatrix}1 &amp; 0\\-1 &amp; 1\end{pmatrix}\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^2=\begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix}$
$$
\begin{pmatrix}a_{k} &amp; 1\\1 &amp; 0\end{pmatrix}
\begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix}
=
\begin{pmatrix}2a_{k}-1 &amp; a_k\\2 &amp; 1\end{pmatrix}
$$
验证 $a_k=1$ 时是否也符合题意：

一方面
$$
\begin{pmatrix}a_{k-1} &amp; 1\\1 &amp; 0\end{pmatrix}
\begin{pmatrix}2a_{k}-1 &amp; a_k\\2 &amp; 1\end{pmatrix}=
\begin{pmatrix}a_{k-1} &amp; 1\\1 &amp; 0\end{pmatrix}
\begin{pmatrix}1 &amp; 1\\2 &amp; 1\end{pmatrix}=
\begin{pmatrix}a_{k-1}+2 &amp; a_{k-1}+1\\1 &amp; 1\end{pmatrix}
$$
另一方面
$$
\begin{pmatrix}a_{k-1}+1 &amp; 1\\1 &amp; 0\end{pmatrix}
\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}=\begin{pmatrix}a_{k-1}+2 &amp; a_{k-1}+1\\1 &amp; 1\end{pmatrix}
$$
所以操作`E`就是右乘矩阵 $\begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix}$

平衡树维护即可。

```cpp
// Author:  HolyK
// Created: Fri Jul 30 19:13:22 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
using Matrix = std::array&lt;int, 4&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
inline int mod(LL x) { return x % P; }
Matrix operator*(Matrix a, Matrix b) {
  return {
    mod(1LL * a[0] * b[0] + 1LL * a[1] * b[2]),
    mod(1LL * a[0] * b[1] + 1LL * a[1] * b[3]),
    mod(1LL * a[2] * b[0] + 1LL * a[3] * b[2]),
    mod(1LL * a[2] * b[1] + 1LL * a[3] * b[3])
  };
}
constexpr Matrix M[2] = {Matrix({1, 0, 1, 1}), Matrix({2, 1, P - 1, 0})};
std::mt19937 rng(std::chrono::high_resolution_clock::now().time_since_epoch().count());
struct Node {
  Node *ch[2];
  bool rev, fl;
  int rnd, val, siz;
  Matrix sum[2][2];
  Node(int x) : rev(0), fl(0), rnd(rng()), val(x), siz(1) {
    ch[0] = ch[1] = nullptr;
    sum[0][0] = sum[1][0] = M[val];
    sum[0][1] = sum[1][1] = M[val ^ 1];
  }
  void reverse() {
    rev ^= 1;
    std::swap(ch[0], ch[1]);
    std::swap(sum[0][0], sum[1][0]);
    std::swap(sum[0][1], sum[1][1]);
  }
  void flip() {
    fl ^= 1;
    val ^= 1;
    std::swap(sum[0][0], sum[0][1]);
    std::swap(sum[1][0], sum[1][1]);
  }
  void pushdown() {
    if (rev) {
      if (ch[0]) ch[0]-&gt;reverse();
      if (ch[1]) ch[1]-&gt;reverse();
      rev = false;
    }
    if (fl) {
      if (ch[0]) ch[0]-&gt;flip();
      if (ch[1]) ch[1]-&gt;flip();
      fl = false;
    }
  }
  void pushup() {
    sum[0][0] = sum[1][0] = M[val];
    sum[0][1] = sum[1][1] = M[val ^ 1];
    siz = 1;
    if (ch[0]) {
      sum[0][0] = ch[0]-&gt;sum[0][0] * sum[0][0];
      sum[0][1] = ch[0]-&gt;sum[0][1] * sum[0][1];
      sum[1][0] = sum[1][0] * ch[0]-&gt;sum[1][0];
      sum[1][1] = sum[1][1] * ch[0]-&gt;sum[1][1];
      siz += ch[0]-&gt;siz;
    }
    if (ch[1]) {
      sum[0][0] = sum[0][0] * ch[1]-&gt;sum[0][0];
      sum[0][1] = sum[0][1] * ch[1]-&gt;sum[0][1];
      sum[1][0] = ch[1]-&gt;sum[1][0] * sum[1][0];
      sum[1][1] = ch[1]-&gt;sum[1][1] * sum[1][1];
      siz += ch[1]-&gt;siz;
    }
  }
  void *operator new(size_t);
};

void *Node::operator new(size_t s) {
  static char buf[200000 * sizeof(Node)], *p = std::end(buf);
  return p -= s;
}
void split(Node *o, int k, Node *&amp;x, Node *&amp;y) {
  if (!o) {
    x = y = nullptr;
    return;
  }
  o-&gt;pushdown();
  int s = o-&gt;ch[0] ? o-&gt;ch[0]-&gt;siz : 0;
  if (k &lt;= s) {
    split(o-&gt;ch[0], k, x, o-&gt;ch[0]);
    y = o;
  } else {
    split(o-&gt;ch[1], k - s - 1, o-&gt;ch[1], y);
    x = o;
  }
  o-&gt;pushup();
}
Node *merge(Node *x, Node *y) {
  if (!x) return y;
  if (!y) return x;
  x-&gt;pushdown();
  y-&gt;pushdown();
  return x-&gt;rnd &lt; y-&gt;rnd
    ? (x-&gt;ch[1] = merge(x-&gt;ch[1], y), x-&gt;pushup(), x)
    : (y-&gt;ch[0] = merge(x, y-&gt;ch[0]), y-&gt;pushup(), y);
}
void print(Matrix a) {
  std::cout &lt;&lt; a[0] &lt;&lt; &#34; &#34; &lt;&lt; (a[0] + a[2]) % P &lt;&lt; &#34;\n&#34;;
}
int main() {
  // freopen(&#34;code.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;code.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, q;
  std::string s;
  std::cin &gt;&gt; n &gt;&gt; q &gt;&gt; s;
  Node *root = nullptr;
  for (char c : s) root = merge(root, new Node(c == &#39;E&#39;));
  print(root-&gt;sum[0][0]);
  while (q--) {
    std::cin &gt;&gt; s;
    if (s[0] == &#39;A&#39;) {
      std::cin &gt;&gt; s;
      root = merge(root, new Node(s[0] == &#39;E&#39;));
    } else {
      Node *x, *y;
      int l, r;
      std::cin &gt;&gt; l &gt;&gt; r;
      split(root, r, x, y);
      split(x, l - 1, x, root);
      if (s[0] == &#39;R&#39;) {
        root-&gt;reverse();
      } else {
        root-&gt;flip();
      }
      root = merge(merge(x, root), y);
    }
    print(root-&gt;sum[0][0]);
  }
  return 0;
}
```

- https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>LGV 引理小记</title>
        <link>https://blog.asukakyle.top/post/lgv-lemma/</link>
        <pubDate>Fri, 30 Jul 2021 16:40:08 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/lgv-lemma/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/lgv-lemma/ -## LGV 引理

设 $G(V, E)$ 是一个 DAG，起点集 $A = \{a_1, \dots, a_n\} \subseteq V$，终点集 $B = \{b_1, \dots, b_n\} \subseteq V$ 。

记 $\omega_e$ 表示有向边 $e$ 的边权，$\omega_e$ 属于某个**交换环**。

对于有向路径 $P$，定义 $\omega(P)$ 表示路径上边权的乘积，即
$$
\omega(P) = \prod\limits_{e \in P} \omega_e
$$
对于任意两点 $a, b$，记 $e(a, b)$ 表示从 $a$ 到 $b$ 的所有路径的权值之和，即
$$
e(a, b) = \sum\limits_{P:a\to b}\omega(P)
$$
**特别地**，若 $\omega_e=1$ ，$e(a, b)$ 表示 从 $a$ 到 $b$ 的路径数。

记矩阵
$$
M =
\begin{pmatrix}
e(a_1, b_1) &amp; e(a_1, b_2) &amp; \cdots &amp; e(a_1, b_n)\\
e(a_2, b_1) &amp; e(a_2, b_2) &amp; \cdots &amp; e(a_2, b_n)\\
\vdots      &amp; \vdots      &amp; \ddots &amp; \vdots\\
e(a_n, b_1) &amp; e(a_n, b_2) &amp; \cdots &amp; e(a_n, b_n)\\
\end{pmatrix}
$$
定义从 $A$ 到 $B$ 的 $n$ 元不相交路径组表示 $G$ 中的 $n$ 条有向路径 $(P_1, \dots, P_n)$ 满足：

1. 存在 $\{1, 2, \dots, n\}$ 的排列 $\sigma$ 使得对于 $i = 1, 2, \dots, n,$ 路径 $P_i$ 是从 $a_i$ 到 $b_{\sigma_i}$ 的有向路径。
2. 对于任意 $i \neq j$，路径 $P_i, P_j$ 没有公共点。

记 $\sigma(P)$ 表示 1 中的排列 $\sigma$ 。

&gt; **Lindström–Gessel–Viennot lemma** 
&gt; $$
&gt; \det(M) = \sum\limits_{(P_1, P_2, \dots, P_n):A\to B} \operatorname{sgn}(\sigma(P))\prod_{i=1}^n\omega(P_i)
&gt; $$
&gt; 其中
&gt; $$
&gt; \operatorname{sgn}(\sigma(P)) = (-1)^{\pi(\sigma(P))}
&gt; $$
&gt; **特别地**，若 $\sigma(P)$ 只可能是 $\{1, 2, \dots, n\}$ ，令 $\omega_e=1$，此时 $\det(M)$ 等于 $A$ 到 $B$ 的不相交路径数。
&gt;
&gt; 证明略。

## 例题

NOI 2021Day1T2

```cpp
// Author:  HolyK
// Created: Fri Jul 30 16:09:21 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(998244353);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
int det(std::vector&lt;std::vector&lt;int&gt;&gt; a) {
  int n = a.size(), r = 1, sgn = 1;
  for (int i = 0; i &lt; n; i++) {
    int j = i;
    while (j &lt; n &amp;&amp; !a[j][i]) j++;
    if (j == n) return 0;
    if (i != j) std::swap(a[i], a[j]), sgn = -sgn;
    r = 1LL * r * a[i][i] % P;
    int inv = fpow(a[i][i]);
    for (j++; j &lt; n; j++) {
      if (!a[j][i]) continue;
      int c = 1LL * a[j][i] * inv % P;
      for (int k = i; k &lt; n; k++) {
        a[j][k] = (a[j][k] - 1LL * c * a[i][k]) % P;
      }
    }
  }
  return (P + r * sgn) % P;
}
void solve() {
  int n;
  std::cin &gt;&gt; n;
  std::vector&lt;int&gt; a(n + 1), b(n - 1);
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i + 1];  
  }
  for (int i = 1; i &lt;= n; i++) {
    a[i] += a[i - 1];
  }
  for (int i = 0; i &lt; n - 1; i++) {
    std::cin &gt;&gt; b[i];
  }
  std::vector&lt;int&gt; d(a.back());
  std::vector f(a[1], std::vector&lt;int&gt;(a[1]));
  for (int i = 0; i &lt; a[1]; i++) f[i][i] = 1;
  for (int i = 0; i &lt; n - 1; i++) {
    std::vector g(a[i + 2] - a[i + 1], std::vector&lt;int&gt;(a[1]));
    while (b[i]--) {
      int x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
      x--, y--;
      for (int j = 0; j &lt; a[1]; j++) {
        inc(g[y][j], f[x][j]);
      }
    }
    f.swap(g);
  }
  std::cout &lt;&lt; det(f) &lt;&lt; &#34;\n&#34;;
}
int main() {
  freopen(&#34;xpath.in&#34;, &#34;r&#34;, stdin);
  freopen(&#34;xpath.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    solve();
  }
  return 0;
}
```

- https://blog.asukakyle.top/post/lgv-lemma/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2021牛客多校2</title>
        <link>https://blog.asukakyle.top/post/2021nowcoder2/</link>
        <pubDate>Wed, 21 Jul 2021 13:31:31 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2021nowcoder2/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2021nowcoder2/ -
## 总览

| 题号 |                             标题                             | 团队的状态 |
| :--: | :----------------------------------------------------------: | :--------: |
|  A   | [Arithmetic Progression](https://ac.nowcoder.com/acm/contest/11253/A) |   通过   |
|  B   |    [Cannon](https://ac.nowcoder.com/acm/contest/11253/B)     |   通过   |
|  C   |  [Draw Grids](https://ac.nowcoder.com/acm/contest/11253/C)   |    通过    |
|  D   |  [Er Ba Game](https://ac.nowcoder.com/acm/contest/11253/D)   |    通过    |
|  E   |  [Gas Station](https://ac.nowcoder.com/acm/contest/11253/E)  |   通过   |
|  F   |  [Girlfriend](https://ac.nowcoder.com/acm/contest/11253/F)   |    通过    |
|  G   | [League of Legends](https://ac.nowcoder.com/acm/contest/11253/G) |    通过    |
|  H   |    [Olefin](https://ac.nowcoder.com/acm/contest/11253/H)     |   未通过   |
|  I   |   [Penguins](https://ac.nowcoder.com/acm/contest/11253/I)    |    通过    |
|  J   | [Product of GCDs](https://ac.nowcoder.com/acm/contest/11253/J) |    通过    |
|  K   |     [Stack](https://ac.nowcoder.com/acm/contest/11253/K)     |    通过    |
|  L   |  [WeChat Walk](https://ac.nowcoder.com/acm/contest/11253/L)  |    通过    |

## [Arithmetic Progression](https://ac.nowcoder.com/acm/contest/11253/A)

&gt; 给定每个**元素互不相同**的序列 $a_n$，求排序后能构成等差数列的区间个数。
&gt;
&gt; $1 \leq n \leq 10^5, 1 \leq a_i \leq 10^9$

&gt; **结论**：对于**元素互不相同**的序列 $b_n$，其排序后是公差为 $d$ 等差数列的**充要条件**是 $d=\gcd(|b_2-b_1|,|b_3-b_2|,\dots)$ 且 $\max b_i - \min b_i = (n-1)d$。
&gt;
&gt; **证明**：
&gt;
&gt; **必要性**：
&gt;
&gt; 设 $b_i = k_id + b_1$ 且 $b_n$ 排序后为等差数列，则 $k_i$ 是 $0, 1, \dots n-1$ 的一个排列，所以 $\max b_i - \min b_i= (n-1)d$。
&gt;
&gt; 根据辗转相减法：
&gt;
&gt; $\gcd(|b_2-b_1|,|b_3-b_2|,\dots)\ = \gcd(|b_2-b_1|, |b_3 - b_1|, \dots) = \gcd(d, 2d, \dots) = d$。
&gt;
&gt; **充分性**：
&gt;
&gt; 不妨设 $b_1 &lt; b_2 &lt;\dots &lt; b_n$，$\gcd(|b_2-b_1|,|b_3-b_2|,\dots)\ = \gcd(|b_2-b_1|, |b_3 - b_1|, \dots) = d = \frac{b_n - b_1}{n-1}$。
&gt;
&gt; 设 $b_i = k_id + b_1$，则 $k_1 = 0 &lt; k_2 \dots &lt; k_n = n - 1$，所以 $k_i = i - 1,b_i = (i-1)d+b_1$，为等差数列。

于是问题转化为求 $\max a_i - \min a_i = (r-l)\gcd(|a_{l+1}-a_l|, |a_{l+2} - a_{l+1}|, \dots)$ 的区间个数。 

由上面的证明不难发现 $\max a_i - \min a_i - (r-l)\gcd(|a_{l+1}-a_l|, |a_{l+2} - a_{l+1}|, \dots) \geq 0$，所以用线段树维护这个值的最小值以及最小值的个数。

每次移动右端点时，极差只需修改一个区间，但每个点的 $\gcd$ 都可能被修改。

考虑一个点作为左端点的区间 $\gcd$ 被修改的次数，发现每次修改至少会折半，所以最多修改 $\log$ 次，于是在线段树上暴力修改即可。

不需要 zkw 跑得也很快！

```cpp
// Author:  HolyK
// Created: Wed Jul 21 12:59:35 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
int n, a[N];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
LL min[N &lt;&lt; 2], tag[N &lt;&lt; 2];
int cnt[N &lt;&lt; 2], gcd[N &lt;&lt; 2];
void pushup(int o) {
  min[o] = std::min(min[ls], min[rs]);
  cnt[o] = (min[ls] == min[o] ? cnt[ls] : 0) + (min[rs] == min[o] ? cnt[rs] : 0);
  min[o] += tag[o];
  gcd[o] = gcd[ls] == gcd[rs] ? gcd[ls] : -1;
}
void update(int o, int l, int r, int x, int y, int z) {
  if (gcd[o] &gt; 0 &amp;&amp; z % gcd[o] == 0) {
    min[o] -= gcd[o];
    tag[o] -= gcd[o];
    return;
  }
  if (l == r) {
    int t = gcd[o];
    gcd[o] = std::gcd(gcd[o], z);
    min[o] -= LL(gcd[o] - t) * (y - l) + gcd[o];
    cnt[o] = 1;
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) update(ls, l, m, x, y, z);
  if (y &gt; m) update(rs, m + 1, r, x, y, z);
  pushup(o);
}
void add(int o, int l, int r, int x, int y, int z) {
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    min[o] += z;
    tag[o] += z;
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) add(ls, l, m, x, y, z);
  if (y &gt; m) add(rs, m + 1, r, x, y, z);
  pushup(o);
}
int ask(int o, int l, int r, int x, int y, int z) {
  if (y &lt; l || r &lt; x) return 0;
  if (x &lt;= l &amp;&amp; r &lt;= y) return min[o] + z == 0 ? cnt[o] : 0;
  int m = l + r &gt;&gt; 1;
  z += tag[o];
  return ask(ls, l, m, x, y, z) + ask(rs, m + 1, r, x, y, z);
}
int s1[N], s2[N], t1, t2; // min, max
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    std::cin &gt;&gt; n;
    memset(min, 0, n + 1 &lt;&lt; 5);
    memset(tag, 0, n + 1 &lt;&lt; 5);
    memset(cnt, 0, n + 1 &lt;&lt; 4);
    memset(gcd, 0, n + 1 &lt;&lt; 4);
    for (int i = 1; i &lt;= n; i++) {
      std::cin &gt;&gt; a[i];
    }
    LL ans = n;
    t1 = t2 = s1[1] = s2[1] = 1;
    for (int i = 2; i &lt;= n; i++) {
      while (t1 &amp;&amp; a[s1[t1]] &gt; a[i]) {
        add(1, 1, n, s1[t1 - 1] + 1, s1[t1], a[s1[t1]]);
        t1--;
      }
      while (t2 &amp;&amp; a[s2[t2]] &lt; a[i]) {
        add(1, 1, n, s2[t2 - 1] + 1, s2[t2], -a[s2[t2]]);
        t2--;
      }
      add(1, 1, n, s1[t1] + 1, i, -a[i]);
      add(1, 1, n, s2[t2] + 1, i, a[i]);
      s1[++t1] = s2[++t2] = i;
      update(1, 1, n, 1, i - 1, a[i] - a[i - 1]);
      ans += ask(1, 1, n, 1, i - 1, 0);
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [Cannon](https://ac.nowcoder.com/acm/contest/11253/B)    
&gt; 有一个 $2×10^{100}$ 的棋盘，第一行摆了 $a$ 个炮，第二行摆了 $b$ 个炮。
&gt; 
&gt; 依次求发生 $0, 1, 2, \dots, a + b - 2$ 个炮吃炮事件的方案数。
&gt; 
&gt; 有考虑两行之间的顺序和不考虑两行之间的顺序 两个子问题。
&gt; 
&gt; $1 \leq a, b \leq 5 \times 10^6$

一行 $n$ 个炮操作 $m$ 次的方案是 $2^m \dfrac{(n - 2)!}{(n - 2 - m)!}$。

设 $n = a - 2, m = b - 2$，问题即求
$$
\begin{aligned}
ans_1 &amp;= 2^k \sum_{i = 0}^k \binom{k}{i}\frac{n!}{(n - i)!}\frac{m!}{(m - k + i)!}\\
&amp;= 2^k k!\sum_{i = 0}^k \frac{n!}{(n - i)!i!}\frac{m!}{(m - k + i)!(k-i)!}\\
&amp;= 2^k k!\sum_{i = 0}^k \binom{n}{i}\binom{m}{k-i}\\
&amp;= 2^k k!\binom{n+m}{k}\\
ans_2 &amp;= 2^k \sum_{i = 0}^k \frac{n!}{(n - i)!}\frac{m!}{(m - k + i)!}\\
&amp;= 2^k \frac{n!m!}{(n + m - k)!}\sum_{i = 0}^k \frac{(n+m-k)!}{(n-i)!(m-k+i)!}\\
&amp;= 2^k \frac{n!m!}{(n + m - k)!}\sum_{i = 0}^k \binom{n+m-k}{n-i}\\
&amp;= 2^k \frac{n!m!}{(n + m - k)!}\sum_{i = n}^{n-k} \binom{n+m-k}{i}
\end{aligned}
$$

问题一直接递推，问题二维护一个组合数前缀和即可。

```cpp
// Author:  HolyK
// Created: Tue Jul 20 21:51:46 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int P(1e9 + 9);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
constexpr int N(1e7 + 5);
int n, m, fac[N], ifac[N];
int bin(int n, int m) {
  return m &gt;= 0 &amp;&amp; m &lt;= n ? 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P : 0;
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  n -= 2, m -= 2;
  fac[0] = ifac[0] = 1;
  int k = n + m;
  for (int i = 1; i &lt;= k; i++) fac[i] = 1LL * fac[i - 1] * i % P;
  ifac[k] = fpow(fac[k]);
  for (int i = k - 1; i; i--) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % P;
  int ans = 1;
  for (int i = 1, x = 1; i &lt;= k; i++) {
    x = 2LL * x * (k - i + 1) % P;
    ans ^= x;
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34; &#34;;
  ans = 1;
  int s1 = 0, s2;
  for (int i = 0; i &lt; n; i++) inc(s1, bin(k, i));
  inc(s2 = s1, bin(k, n));
  for (int i = 1, x = fpow(bin(k, n)); i &lt;= k; i++) {
    s1 = (s1 - bin(k - i, n - i) + P) * (P + 1LL &gt;&gt; 1) % P;
    s2 = (s2 + bin(k - i, n)) * (P + 1LL &gt;&gt; 1) % P;
    x = 2LL * x * (k - i + 1) % P;
    ans ^= 1LL * x * (s2 - s1 + P) % P;
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}

```

## [Draw Grids](https://ac.nowcoder.com/acm/contest/11253/C)   
队友切了。

## [Er Ba Game](https://ac.nowcoder.com/acm/contest/11253/D)   
签到题。

## [Gas Station](https://ac.nowcoder.com/acm/contest/11253/E) 

&gt; 给定一棵树，点权 $a_i$，边权 $w_i$，经过一个点能量加 $a_i$，经过一条边能量减 $w_i$，$q$ 次询问从点 $x_i$ 出发初始能量为 $d_i$ 中间能量不小于 0 且不能经过点 $p_i$，沿着最短路径能到达的点数。
&gt;
&gt; $1 \leq n,q \leq 10^5, 1 \leq a_i, w_i \leq 10^9, 0 \leq d_i \leq 10^{14}$

离线，然后是点分治基础题。

```cpp
// Author:  HolyK
// Created: Wed Jul 21 14:21:43 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5);
int n, m, a[N], ans[N];
std::vector&lt;PII&gt; g[N];
std::vector&lt;std::tuple&lt;LL, int, int&gt;&gt; q[N];
bool vis[N];
int root, tSize, mSize, siz[N];
void getSize(int x, int fa) {
  siz[x] = 1 + q[x].size();
  for (auto [y, z] : g[x]) {
    if (y == fa || vis[y]) continue;
    getSize(y, x);
    siz[x] += siz[y];
  }
}
void getRoot(int x, int fa) {
  int max = tSize - siz[x];
  for (auto [y, z] : g[x]) {
    if (y == fa || vis[y]) continue;
    getRoot(y, x);
    smax(max, siz[y]);
  }
  if (smin(mSize, max)) root = x;
}

LL up[N], dn[N], sum[N];
int in[N], out[N], id[N], cnt;
void pre(int x, int fa) {
  in[x] = ++cnt;
  id[cnt] = x;
  for (auto [y, z] : g[x]) {
    if (y == fa || vis[y]) continue;
    up[y] = std::max(0LL, up[x] + z - a[y]);
    dn[y] = std::max(dn[x], z - sum[x]);
    sum[y] = sum[x] + a[y] - z;
    pre(y, x);
  }
  out[x] = cnt;
}
struct Qry {
  LL d;
  int l, r, p, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return d &lt; rhs.d;
  }
} s[N];
int tot, p[N], c[N];
void add(int p, int x) {
  for (; p &lt;= cnt; p += p &amp; -p) c[p] += x;
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) r += c[p];
  return r;
}
void solve(int x) {
  getSize(x, 0), mSize = tSize = siz[x], getRoot(x, 0), x = root;
  // std::cerr &lt;&lt; &#34;solve! &#34; &lt;&lt; x &lt;&lt; &#34;\n&#34;;
  cnt = tot = 0;
  up[x] = dn[x] = 0;
  sum[x] = a[x];
  pre(x, 0);
  vis[x] = true;
  for (auto [d, p, id] : q[x]) {
    if (p == x) continue;
    int l = 0, r = 0;
    if (in[p]) l = in[p], r = out[p];
    s[++tot] = {d, l, r, 0, id};
  }
  for (auto [y, z] : g[x]) {
    if (vis[y]) continue;
    for (int i = in[y]; i &lt;= out[y]; i++) {
      int x = id[i];
      // std::cerr &lt;&lt; &#34;! &#34; &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; root &lt;&lt; &#34; &#34; &lt;&lt; up[x] &lt;&lt; &#34; &#34; &lt;&lt; dn[x] &lt;&lt; &#34;\n&#34;;
      for (auto [d, p, id] : q[x]) {
        if (d &lt; up[x] || in[p] &lt;= in[x] &amp;&amp; out[x] &lt;= out[p]) continue;
        
        int l = 0, r = 0;
        if (in[p] &amp;&amp; !(in[y] &lt;= in[p] &amp;&amp; out[p] &lt;= out[y])) l = in[p], r = out[p];
        s[++tot] = {d + sum[x] - a[root], l, r, y, id};
      }
    }
  }
  std::sort(s + 1, s + 1 + tot);
  for (int i = 1; i &lt;= cnt; i++) p[i] = id[i];
  std::sort(p + 1, p + 1 + cnt, [&amp;](int i, int j) {
    return dn[i] &lt; dn[j];
  });
  for (int i = 1; i &lt;= cnt; i++) c[i] = 0;
  for (int i = 1, j = 1; i &lt;= tot; i++) {
    for (; j &lt;= cnt &amp;&amp; dn[p[j]] &lt;= s[i].d; j++) {
      add(in[p[j]], 1);
    }
    ans[s[i].id] += j - 1;
    if (s[i].l) ans[s[i].id] -= ask(s[i].r) - ask(s[i].l - 1);
    if (s[i].p) ans[s[i].id] -= ask(out[s[i].p]) - ask(in[s[i].p] - 1);
    // std::cerr &lt;&lt; &#34;!! &#34; &lt;&lt; ans[s[i].id] &lt;&lt; &#34;\n&#34;;
  }
  for (int i = 1; i &lt;= cnt; i++) {
    in[id[i]] = out[id[i]] = 0;
  }
  
  for (auto [y, z] : g[x]) {
    if (vis[y]) continue;
    solve(y);
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1, x, y, z; i &lt; n; i++) {
    std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    g[x].push_back({y, z});
    g[y].push_back({x, z});
  }
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
  }
  for (int i = 1, x, p; i &lt;= m; i++) {
    LL d;
    std::cin &gt;&gt; x &gt;&gt; d &gt;&gt; p;
    q[x].push_back({d, p, i});
  }
  solve(1);
  for (int i = 1; i &lt;= m; i++) {
    std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [Girlfriend](https://ac.nowcoder.com/acm/contest/11253/F)   
求球的体积交。

我不会积分，我是傻逼，就这高数还考99。

```cpp
#include &lt;bits/stdc++.h&gt;
using DB = double;
#define double long double
struct P {
  double x, y, z;
  P operator+(P r) const {
    return {x + r.x, y + r.y, z + r.z};
  }
  P operator-(P r) const {
    return {x - r.x, y - r.y, z - r.z};
  }
  P operator*(double r) const {
    return {r * x, r * y, r * z};
  }
  P operator/(double r) const {
    return {x / r, y / r, z / r};
  }
  double dist2() const {
    return x * x + y * y + z * z;
  }
  double dist() const {
    return sqrt(dist2());
  }
} a[4];
void get(P a, P b, double k, P &amp;c, double &amp;r) {
  auto u = (b * k - a) / (k - 1), v = (b * k + a) / (k + 1);
  c = (u + v) / 2;
  r = (u - v).dist() / 2;
}
constexpr double EPS(1e-10);
const double PI(acos((double)-1.0));
double sqr(double r) { return r * r; }
double cal(double r) { return r * sqrt(r); }
int main() {
  int t;
  scanf(&#34;%d&#34;, &amp;t);
  while (t--) {
    for (auto &amp;[x, y, z] : a) {
      DB a, b, c;
      scanf(&#34;%lf%lf%lf&#34;, &amp;a, &amp;b, &amp;c);
      x = a, y = b, z = c;
    }
    int k1, k2;
    scanf(&#34;%d%d&#34;, &amp;k1, &amp;k2);
    P c1, c2;
    double r1, r2;
    get(a[0], a[1], k1, c1, r1);
    get(a[2], a[3], k2, c2, r2);
    double d = (c1 - c2).dist();
    if (d &gt;= r1 + r2) {
      puts(&#34;0&#34;);
      continue;
    }
    if (r1 &lt; r2) std::swap(r1, r2);
    if (d &lt;= r1 - r2) {
      printf(&#34;%.10f\n&#34;, DB(4.0 / 3 * PI * r2 * r2 * r2));
      continue;
    }
    // printf(&#34;%f %f %f\n&#34;, r1, r2, d);
    double z = (r1 * r1 - r2 * r2 + d * d) / (2 * d), ans;
    if (z &lt; d) {
      z = r1 * r1 - z * z;
      ans = 2.0 / 3 * (r1 * r1 * r1 + r2 * r2 * r2 - cal(r1 * r1 - z) - cal(r2 * r2 - z)) - d * z;
    } else {
      z = r1 * r1 - z * z;
      ans = 2.0 / 3 * (-r1 * r1 * r1 + r2 * r2 * r2 + cal(r1 * r1 - z) - cal(r2 * r2 - z)) + d * z;
      ans = 4.0 / 3 * r2 * r2 * r2 - ans;
    }
    ans *= PI;
    printf(&#34;%.10f\n&#34;, DB(ans));
  }
  return 0;
}
```

## [League of Legends](https://ac.nowcoder.com/acm/contest/11253/G) 
&gt; $n$ 个区间 $[l_i, r_i)$ 划分成 $k$ 个集合，要求每个集合的区间交不为空， 求 $\sum r - l$ 最大值。
&gt; 
&gt; $1 \leq k \leq n \leq 5000$

**如果一个区间包含了另一个小区间，那么这个区间要么单独成一个集合，要么和这个小区间在一个集合**。

看出这个之后就好做了。

把大区间都拿走后，剩下的就是不存在包含关系的小区间，按左端点排序后，显然选连续的一段更优，于是可以DP，最后再算上大区间的贡献。

由于没有包含关系，右端点也是递增的，可以用单调队列优化成 $O(nk)$。

```cpp
// Author:  HolyK
// Created: Mon Jul 19 19:26:36 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
#define int LL
using PII = std::pair&lt;int, int&gt;;
signed main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, k;
  std::cin &gt;&gt; n &gt;&gt; k;
  std::vector&lt;PII&gt; a(n), b;
  std::vector&lt;int&gt; c;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
  }
  std::sort(a.begin(), a.end());
  b.push_back(a.back());
  for (int i = n - 2, m = a.back().second; i &gt;= 0; i--) {
    if (a[i].second &gt;= m) {
      c.push_back(a[i].second - a[i].first);
    } else {
      b.push_back(a[i]);
      m = a[i].second;
    }
  }
  std::reverse(b.begin(), b.end());

  std::vector f(k + 1, std::vector&lt;int&gt;(n = b.size(), -1e18));
  
  for (int i = 0; i &lt; n; i++) {
    if (b[0].second &gt; b[i].first) {
      f[1][i] =  b[0].second - b[i].first;
    }
  }
  // std::cerr &lt;&lt; f[1].back() &lt;&lt; &#34; &#34;;
  for (int i = 2; i &lt;= k &amp;&amp; i &lt;= n; i++) {
    std::vector&lt;PII&gt; q;
    int s = 0;
    for (int j = i - 1; j &lt; n; j++) {
      while (s &lt; q.size() &amp;&amp; q[s].second &lt;= b[j].first) s++;
      PII v = {b[j].second + f[i - 1][j - 1], b[j].second};
      while (s &lt; q.size() &amp;&amp; q.back() &lt;= v) q.pop_back();
      q.push_back(v);
      f[i][j] = q[s].first - b[j].first;
    }
  }
  // std::cerr &lt;&lt; &#34;!! &#34; &lt;&lt; n &lt;&lt; &#34;\n&#34;;
  int ans = f[k].back();
  std::sort(c.rbegin(), c.rend());
  for (int i = 0, s = 0; i &lt; c.size() &amp;&amp; i &lt; k; i++) {
    s += c[i];
    smax(ans, s + f[k - i - 1].back());
  }
  smax(ans, 0);
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## [Olefin](https://ac.nowcoder.com/acm/contest/11253/H)    

## [Penguins](https://ac.nowcoder.com/acm/contest/11253/I)    
队友切了。

## [Product of GCDs](https://ac.nowcoder.com/acm/contest/11253/J) 
&gt; 给定 $n$ 个数 $x_1, x_2, \dots, x_n$，从中选出 $k$ 个数求 $\gcd$，求所有方案 $\gcd$ 之积，答案 $\bmod P$。
&gt; 
&gt; $T \leq 60, n \leq 4 \times 10^4, 1 \leq x_i \leq 8 \times 10^4, k \leq 30, 10^6 \leq P \leq 10^{14}$。

枚举 $\gcd$ 的质因子和指数，用组合数计算贡献。

$P$ 不是质数，但 $k$ 只有30，可以递推求组合数。

指数贡献需要欧拉降幂，由于 $P \geq 10^6 &gt; 8 \times 10^4$，不需要用到拓展欧拉定理。

求 $\varphi(P)$ 要筛素数或者直接 Pollard-rho。

```cpp
// Author:  HolyK
// Created: Mon Jul 19 21:21:30 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
#define gcd __gcd
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
using LLL = __int128_t;
LL fpow(LL x, LL k, LL p) {
  LL r = 1;
  for (; k; k &gt;&gt;= 1, x = (LLL)x * x % p) {
    if (k &amp; 1) r = (LLL)r * x % p;
  }
  return r;
}
bool isPrime(LL p) {
  if (p &lt; 2) return false;
  if (p == 2 || p == 3) return true;
  LL d = p - 1, r = 0;
  static std::mt19937 rnd(19260817);
  for (; d &amp; 1 ^ 1; d &gt;&gt;= 1) r++;
  for (LL k = 0; k &lt; 10; k++) {
    LL a = rnd() % (p - 2) + 2, x = fpow(a, d, p);
    if (x == 1 || x == p - 1) continue;
    for (int i = 0; i &lt; r - 1 &amp;&amp; x != p - 1; i++) {
      x = (LLL)x * x % p;
    }
    if (x != p - 1) return false;
  }
  return true;
}
LL pr(LL n) {
  auto f = [&amp;](LL x) { return (LLL)x * x % n + 1; };
  LL p = 2, q;
  for (LL i = 1, x = 0, y = 0, t = 30; t++ % 40 || std::gcd(p, n) == 1; x = f(x), y = f(f(y))) {
    if (x == y) x = ++i, y = f(x);
    q = (LLL)p * (x - y &gt; 0 ? x - y : y - x) % n;
    if (q) p = q;
  }
  return std::gcd(p, n);
}
std::vector&lt;LL&gt; factor(LL n) {
  if (n == 1) return {};
  if (isPrime(n)) return {n};
  LL x = pr(n);
  auto l = factor(x), r = factor(n / x);
  l.insert(l.end(), r.begin(), r.end());
  return l;
}

std::vector&lt;int&gt; primes;
bool np[80004];
void sieve(int n) {
  for (int i = 2; i &lt;= n; i++) {
    if (!np[i]) primes.push_back(i);
    for (int j : primes) {
      if (1LL * i * j &gt; n) break;
      np[i * j] = true;
      if (i % j == 0) break;
    }
  }
}
LL getPhi(LL x) {
  auto v = factor(x);
  for (auto u : v) x -= x / u;
  return x;
  // LL r = x;
  // for (int i : primes) {
  //   if (i &gt; x / i) break;
  //   if (x % i) continue;
  //   do x /= i; while (x % i == 0);
  //   r -= r / i;
  // }
  // if (x &gt; 1) r -= r / x;
  // return r;
}
LL bin[40004][33];
int cnt[80005];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  sieve(8e4);
  // sieve(1e7);
  int t, n, k;
  LL p, phi;
  std::cin &gt;&gt; t;
  while (t--) {
    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;
    phi = getPhi(p);
    for (int i = 0; i &lt;= n; i++) {
      bin[i][0] = 1;
      for (int j = 1; j &lt;= i &amp;&amp; j &lt;= k; j++) {
        bin[i][j] = bin[i - 1][j] + bin[i - 1][j - 1];
        if (bin[i][j] &gt;= phi) bin[i][j] -= phi;
      }
    }
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i &lt;= n; i++) {
      int x;
      std::cin &gt;&gt; x;
      cnt[x]++;
    }
    LL ans = 1;
    for (int x : primes) {
      LL sum = 0;
      for (LL y = x; y &lt;= 8e4; y *= x) {
        int c = 0;
        for (int k = y; k &lt;= 8e4; k += y) c += cnt[k];
        sum += bin[c][k];
        if (sum &gt;= p) sum -= phi;
      }
      if (sum) {
        ans = (LLL)ans * fpow(x, sum, p) % p;
      }
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## [Stack](https://ac.nowcoder.com/acm/contest/11253/K)     
&gt; 排列 $a_i$ 求单调栈时 $b_i$ 为插入 $a_i$ 后单调栈的大小。给出 $b_i$ 的一些位置的值，还原一个合法的 $a_i$。
&gt;
&gt; $n \leq 10^5$

队友给了一个构造方法，倒着枚举 $b_i$，每次取剩余数中最小的 $b_i$ 个从大往小填，遇到不为零的 $b_j$ 为止。

直接维护是 $O(n^2)$ 的，我拿树状数组维护这个过程，复杂度 $O(n \log n)$。

标解是拓扑或者链表，还没写，好像是洛谷原题。

```cpp
#include &lt;bits/stdc++.h&gt;

std::vector&lt;int&gt; solve(std::vector&lt;int&gt; a) {
  int n = a.size();
  std::vector&lt;int&gt; b, c;
  for (int i = 0; i &lt; a.size(); i++) {
    while (!b.empty() &amp;&amp; b.back() &gt; a[i]) b.pop_back();
    b.push_back(a[i]);
    c.push_back(b.size());
  }
  return c;
}
constexpr int N(1e6 + 5);
int n, a[N], b[N], c[N], s[N];
void add(int p, int x) {
  for (; p &lt;= n; p += p &amp; -p) c[p] += x;
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) r += c[p];
  return r;
}
int get(int x) {
  int p = 0;
  for (int k = 1 &lt;&lt; std::__lg(n); k; k &gt;&gt;= 1) {
    if (p + k &lt;= n &amp;&amp; c[p + k] + k &lt; x) {
      x -= c[p += k] + k;
    }
  }
  return p + 1;
}
int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  int k;
  std::cin &gt;&gt; n &gt;&gt; k;
  while (k--) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    b[x] = y;
    if (y &gt; x) {
      return puts(&#34;-1&#34;), 0;
    }
  }
  std::vector&lt;int&gt; tmp(b + 1, b + 1 + n);
  
  int tot = n;
  for (int i = n; i; i--) {
    if (!b[i]) continue;
    if (tot &lt; b[i]) {
      return puts(&#34;-1&#34;), 0;
    }
    int x = b[i];
    b[i] = 0;
    for (int j = i; j &amp;&amp; !b[j] &amp;&amp; x; j--) {
      a[j] = get(x--);
      add(a[j], -1);
      tot--;
    }
  }
  for (int i = n; i; i--) {
    if (!a[i]) {
      if (tot &lt; 1) {
	return puts(&#34;-1&#34;), 0;
      }
      a[i] = get(1), tot--;
      add(a[i], -1);
    }
  }
  auto tmp2 = solve(std::vector&lt;int&gt;(a + 1, a + 1 + n));
  for (int i = 0; i &lt; n; i++) {
    if (tmp[i] &amp;&amp; tmp[i] != tmp2[i]) {
      return puts(&#34;-1&#34;), 0;
    }
  }
  for (int i = 1; i &lt;= n; i++) std::cout &lt;&lt; a[i] &lt;&lt; &#34; \n&#34;[i == n];
  return 0;
}

```

## [WeChat Walk](https://ac.nowcoder.com/acm/contest/11253/L)
&gt; 给定 $n$ 个点 $m$ 条边的无向图，初始点权 0。$q$ 天，每天增加一个点的点权，求每个点点权比周围的点都大的天数。
&gt; 
&gt; $n, m, q \leq 2 \times 10^5$，点权始终不会超过 $10000$

按照度数分类，度数大于 $\sqrt{m}$ 的为大点，其余为小点。

大点不会超过 $\sqrt m$ 个。

修改点权时，如果是小点，可以暴力更新周围点的情况。

如果是大点，分类讨论：

1. 周围的大点，不会超过 $\sqrt{m}$ 个，暴力更新。
2. 周围的小点，不能暴力更新。
   
   维护 $max_i$ 表示大点周围小点权值的最大值，小点更新权值时更新。

   观察数据范围，发现点权只有 $10000$，可以存下大点周围权值为 $w$ 的有哪些小点是冠军。每次增加点权时暴力扫描权值更新小点。

   容易发现每个大点最多扫描 $q + w$ 次。

```cpp
// Author:  HolyK
// Created: Tue Jul 20 10:22:54 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2e5 + 5), T(512);
std::vector&lt;int&gt; g[N], big[N], small[N / 512][10001];

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, q;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  while (m--) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    x--, y--;
    g[x].push_back(y);
    g[y].push_back(x);
  }
  std::vector&lt;int&gt; id(n), b;
  for (int i = 0; i &lt; n; i++) {
    if (g[i].size() &gt; T) {
      id[i] = b.size();
      b.push_back(i);
      for (int j : g[i]) {
        big[j].push_back(id[i]);
      }
    }
  }
  std::vector&lt;int&gt; w(n), s(n), max(b.size()), ans(n);
  for (int t = 1; t &lt;= q; t++) {
    int x, y;
    std::cin &gt;&gt; x &gt;&gt; y;
    x--;
    if (g[x].size() &lt;= T) {
      if (!s[x]) {
        int max = 0;
        for (int i : g[x]) {
          smax(max, w[i]);
          if (s[i] &amp;&amp; w[x] + y &gt;= w[i]) {
            ans[i] += t - s[i];
            s[i] = 0;
          }
        }
        if (w[x] + y &gt; max) {
          s[x] = t;
        }
      }
      for (int i : big[x]) {
        if (s[x]) small[i][w[x] + y].push_back(x);
        smax(max[i], w[x] + y);
      }
    } else {
      if (!s[x]) {
        int m = max[id[x]];
        for (int v : big[x]) {
          int i = b[v];
          smax(m, w[i]);
          if (s[i] &amp;&amp; w[x] + y &gt;= w[i]) {
            ans[i] += t - s[i];
            s[i] = 0;
          }
        }
        if (w[x] + y &gt; m) s[x] = t;
        for (int i = w[x] + y; i &gt; w[x]; i--) {
          for (int j : small[id[x]][i]) {
            if (s[j] &amp;&amp; i == w[j]) {
              ans[j] += t - s[j];
              s[j] = 0;
            }
          }
        }
      }
    }
    w[x] += y;
  }
  for (int i = 0; i &lt; n; i++) {
    if (s[i]) {
      ans[i] += q - s[i];
    }
  }
  for (int x : ans) {
    std::cout &lt;&lt; x &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```- https://blog.asukakyle.top/post/2021nowcoder2/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>回文树小记</title>
        <link>https://blog.asukakyle.top/post/pam/</link>
        <pubDate>Wed, 14 Jul 2021 17:02:30 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/pam/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/pam/ -
## 基本元素

节点：原串的**一个**本质不同的回文子串。

长度 `len[o]`：回文子串长度。

转移边 `ch[o][x]`：两边同时加字符 $x$。

失配边 `fa[o]`：最长回文后缀。到根的路径是所有回文后缀。

有两个根，奇根`1` 和 偶根`0`，`fa[0] = 1, len[1] = -1`。

常用的构造方法是均摊 $O(n)$ 的，证明很简单，略。

代码：
```cpp
char s[N], *now = s;
std::array&lt;int, 26&gt; ch[N];
int fa[N], len[N], cnt, dep[N];
int jmp(int x) {
  for (; now[~len[x]] != *now; x = fa[x]) ;
  return x; 
}
int ins(int x) {
  static int p, q;
  now++;
  if (!ch[p = jmp(p)][x]) {
    len[q = ++cnt] = len[p] + 2;
    fa[q] = ch[jmp(fa[p])][x];
    ch[p][x] = q;
    dep[q] = dep[fa[q]] + 1;
  }
  return p = ch[p][x];
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; s + 1;
  int n = strlen(s + 1), k = 0;
  fa[0] = 1;
  len[1] = -1;
  cnt = 1;
  for (int i = 1; i &lt;= n; i++) {
    s[i] = (s[i] - &#39;a&#39; + k) % 26 + &#39;a&#39;;
    k = dep[ins(s[i] - &#39;a&#39;)];
    std::cout &lt;&lt; k &lt;&lt; &#34; &#34;;
  }
  return 0;
}
```

## 性质

1. 本质不同回文子串数：除根以外的点数。

2. 回文子串出现次数：失配树上对应节点子树大小 `siz[o]`。

3. 奇偶性：回文树边两端点 `len` 奇偶性相同，但失配树边不是。

4. 不超过一半的最长回文后缀对应节点 `f[o]`：
   
```cpp
if (len[q] &lt;= 2) {
  f[q] = fa[q];
} else {
  for (int &amp;i = f[q] = f[p]; now[~len[i]] != *now || (len[i] + 2 &lt;&lt; 1) &gt; len[q]; i = fa[i]) ;
  f[q] = ch[f[q]][x];
}
```

5. 回文串的回文后(前)缀与其 $\rm Border$ 一一对应。某个串的回文后(前)缀长度可以拆分为 $O(\log n)$ 个等差数列。

6. 设 $v$ 为回文串 $u$ 的最长回文严格前(后)缀，若 $2|v|\geq |u|$，那么 $v$ 只会在 $u$ 中恰好匹配两次，分别作为前缀和后缀。

根据性质5，用 `slink[o]` 来表示上一个等差数列的开头，一直跳 `slink` 最多会跳 `log` 次，可以将插入复杂度变为单次最坏 $O(\log n)$，在回溯操作时保证了复杂度最坏 $O(n \log n)$（ICPC2020昆明F）。

```cpp
int jmp(int x) {
  for (; now[~len[x]] != *now; x = now[~len[fa[x]]] == *now ? fa[x] : slink[x]) ;
  return x;
}
diff[q] = len[q] - len[fa[q]];
slink[q] = diff[q] == diff[fa[q]] ? slink[fa[q]] : fa[q];
```

性质 5, 6 结合 $\rm Border$ 的性质十分有用，回文树的大部分解题思路也都是基于这些性质的。

## 其他技巧

1. 有一个非均摊复杂度的插入方法是记录 `fch[o][x]` 表示要插入 `x` 应该跳到哪个祖先，每次要复制 `fch[o]` 数组，所以复杂度是 $O(n \Sigma)$。

2. 回文树支持双端插入，只要记录前后端的 `p` 即可。整个串变成回文串时，要同时更新前后端的 `p`。

3. 相等问题转化为回文问题：
   1. ([CF932G](http://codeforces.com/problemset/problem/932/G)) 把一个串 $S$ 分割成偶数段 $s_1, s_2, \dots, s_k$，且 $s_i = s_{k-i+1}$，求方案数。
   
      设 $S&#39; = S_1S_nS_2S_{n-1}\dots$ 问题转化为求 $S&#39;$ 偶回文划分的方案数。

   2. ([CF906E](http://codeforces.com/problemset/problem/906/E)) 给定两个串 S 和 T，翻转 S 中最少的区间使得两串相等。
   
      设 $S&#39; = S_1T_1S_2T_2\dots$ 转化为 $S&#39;$ 的最少偶回文划分。

      坑：不需要翻转的情况转移代价为0，此时这个段本身为回文串，周期一定小于等于2。
- https://blog.asukakyle.top/post/pam/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>莫队小记</title>
        <link>https://blog.asukakyle.top/post/%E8%8E%AB%E9%98%9F/</link>
        <pubDate>Mon, 12 Jul 2021 15:21:22 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E8%8E%AB%E9%98%9F/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E8%8E%AB%E9%98%9F/ -
## 莫队二次离线

从 $[x, y]$ 移动到 $[l, r]$。

- $x \to l$

  查询 $a_i$ 在区间 $[i+1, y]$ 的贡献，拆成两个前缀 $i, y$，预处理 $a_{i-1}$ 对前缀 $i-1$ 的贡献，设贡献的前缀和为 $pre_1[i]$。

  1. $x&lt;l$

     删除 $a_{x} \dots a_{l-1}$。

     减前缀 $y$ 的贡献、加前缀 $i$ 的贡献。

     离线 $\{y, x, l-1,-1\}, \Delta ans= pre_1[l] - pre_1[x]$。
     
  2. $x&gt;l$

     加入 $a_l\dots a_{x-1}$。

     加前缀 $y$ 的贡献、减前缀 $i$ 的贡献。

     离线 $\{y, l, x-1,+1\}, \Delta ans= pre_1[l] - pre_1[x]$。

- $y\to r$
  
  查询 $a_i$ 在区间 $[x, i-1]$ 的贡献，拆成两个前缀 $x-1, i-1$，预处理 $a_{i}$ 对前缀 $i-1$ 的贡献，设贡献的前缀和为 $pre_2[i]$。

  1. $y&lt;r$

     加入 $a_{y+1}\dots a_r$。

     减前缀 $x-1$ 的贡献、加前缀 $i-1$ 的贡献。

     离线 $\{x-1, y+1, r, -1\}, \Delta ans = pre_2[r] - pre_2[y]$。

  2. $y&gt;r$

     删除 $a_{r+1}\dots a_y$

     加前缀 $x-1$ 的贡献、减前缀 $i-1$ 的贡献。

     离线 $\{x-1, r+1, y, +1\}, \Delta ans = pre_2[r] - pre_2[y]$。

离线形式 $\{i, x, y, z\}$ 表示查询 $a_x\dots a_y$ 对前缀 $i$ 的贡献乘以系数 $z$。

计算方法和预处理方法一般是相同的，注意平衡复杂度，一般是 $O(\sqrt n)$ 修改，$O(1)$ 查询。

关键部分代码：
```cpp
std::vector&lt;LL&gt; pre1(n + 1), pre2(n + 1);
for (int i = 0; i &lt; n; i++) {
  update(a[i]);
  pre1[i + 1] = pre1[i] + ask(a[i]);
  pre2[i + 1] = pre2[i] + ask(a[i + 1]);
}
std::sort(q.begin(), q.end());
std::vector&lt;LL&gt; ans(m), out(m);
std::vector&lt;std::vector&lt;std::array&lt;int, 4&gt;&gt;&gt; g(n + 1);
int x = 1, y = 0;
for (int i = 0; i &lt; m; i++) {
  auto [l, r, id] = q[i];
  if (x &lt; l) {
    g[y].push_back({x, l - 1, -1, i});
  }
  if (x &gt; l) {
    g[y].push_back({l, x - 1, 1, i});
  }
  ans[i] += pre1[l] - pre1[x];
  x = l;
  if (x) {
    if (y &lt; r) {
      g[x - 1].push_back({y + 1, r, -1, i});
    }
    if (y &gt; r) {
      g[x - 1].push_back({r + 1, y, 1, i});
    }
  }
  ans[i] += pre2[r] - pre2[y];
  y = r;
}
for (int i = 0; i &lt;= n; i++) {
  update(a[i]);
  for (auto [x, y, z, id] : g[i]) {
    for (int j = x; j &lt;= y; j++) {
      ans[id] += ask(a[j]) * z;
    }
  }
}
for (int i = 1; i &lt; m; i++) ans[i] += ans[i - 1];
for (int i = 0; i &lt; m; i++) out[q[i].id] = ans[i];
for (auto x : out) std::cout &lt;&lt; x &lt;&lt; &#34;\n&#34;;
```

## 回滚莫队
维护信息支持加入和回滚时使用。

同块右端点从小到大排序，右端点直接移动，左端点每次从块边界暴力移动，做完后回滚。

维护块左端点 $now$，然后循环开头加一句：

```cpp
if (l &gt; now) {
  // 清空 for (int i = now; i &lt;= y; i++) max[a[i]] = -1, min[a[i]] = n; 
  now = l / T * T + T - 1;
  y = now - 1;
  ans = 0;
}
```

回滚操作，开个记录修改的栈即可。

```cpp
std::vector&lt;std::pair&lt;int*, int&gt;&gt; p;
auto record = [&amp;](int &amp;x) { p.push_back({&amp;x, x}); };
std::reverse(p.begin(), p.end());
for (auto &amp;[u, v] : p) *u = v;
p.clear();
```- https://blog.asukakyle.top/post/%E8%8E%AB%E9%98%9F/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[UOJ91]最大异或和</title>
        <link>https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</link>
        <pubDate>Mon, 12 Jul 2021 08:17:49 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/ -
&gt; 有一个数列 $a_1,a_2,\dots,a_n$，每个 $a_i$ 都是小于 $2^m$ 的非负整数。
&gt;
&gt; 现在需要实现三种操作，格式说明如下：
&gt;
&gt; - 1 *x* *y* *w*：对于所有 $x≤i≤y$，将 $a_i$ 修改为 $a_i\oplus w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。
&gt; - 2 *x* *y* *w*：对于所有 $x≤i≤y$，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。
&gt; - 3：从 $a_1,a_2,⋯,a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。
&gt;
&gt; 这里 $\oplus$ 表示按位异或运算，$x_1,x_2,⋯,x_l$ 的异或和是指 $x_1\oplus x_2\oplus \cdots\oplus x_l$。
&gt; 
&gt; $n,m,q≤2000$。


将原序列差分，线性基不变。

然后每次操作就是单点插入和删除，下面给出两种可删除线性基的写法。

## 离线

记录存活时间，贪心。

```cpp
using BS = std::bitset&lt;2000&gt;;
using PBI = std::pair&lt;BS, int&gt;;
PBI base[2000];
void ins(PBI x) {
  for (int i = 1999; i &gt;= 0; i--) {
    if (!x.first[i]) continue;
    if (x.second &gt; base[i].second) {
      std::swap(x, base[i]);
      if (!x.second) break;
    }
    x.first ^= base[i].first;
  }
}
```

## 在线


$$
PV=B
$$

$$
\det(P)\neq 0,
V = 
\begin{pmatrix}
v_1\\
v_2\\
\vdots\\
v_n
\end{pmatrix},
B=
\begin{pmatrix}
base_1\\
\vdots\\
0\\
\vdots\\
base_m\\
\vdots\\
0\\
\vdots
\end{pmatrix}
$$

记录可逆矩阵 $P$，修改 $v_i$ 时，要将 $P$ 的第 $i$ 列全部变成0。

为了尽量在不影响 $B$ 的情况下消元，首先找 $j$ 满足 $P_{i,j}=1,i\neq j, base_j=0$。

如果找到这样的 $j$ 那么直接消元，$B$ 不会有任何变化。

如果没有找到，那么需要找最小的 $base_k$ 使得 $base_k$ 包含 $v_i$，然后用 $base_k$ 消去其他包含 $v_i$ 的 $base$。


## Code
### 离线
```cpp
// Author:  HolyK
// Created: Mon Jul  5 14:24:21 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
using BS = std::bitset&lt;2000&gt;;
using PBI = std::pair&lt;BS, int&gt;;
int n, m, q;
PBI base[2000];
void ins(PBI x) {
  for (int i = m - 1; i &gt;= 0; i--) {
    if (!x.first[i]) continue;
    if (x.second &gt; base[i].second) {
      std::swap(x, base[i]);
      if (!x.second) break;
    }
    x.first ^= base[i].first;
  }

}
BS a[2005];
std::vector&lt;PBI&gt; g[2005];
int t[2005];
bool ask[2005];
char tmp[2005];
int main() {
  scanf(&#34;%d%d%d&#34;, &amp;n, &amp;m, &amp;q);
  for (int i = 1; i &lt;= n; i++) {
    scanf(&#34;%s&#34;, tmp);
    for (int j = 0; j &lt; m; j++) a[i][j] = tmp[m - 1- j] ^ &#39;0&#39;;
  }
  for (int i = 1; i &lt;= q; i++) {
    int opt;
    scanf(&#34;%d&#34;, &amp;opt);
    if (opt == 3) {
      ask[i] = true;
    } else {
      int x, y;
      BS z;
      scanf(&#34;%d%d&#34;, &amp;x, &amp;y);
      scanf(&#34;%s&#34;, tmp);
      for (int j = 0; j &lt; m; j++) z[j] = tmp[m - 1- j] ^ &#39;0&#39;;
      y++;
      if (opt == 1) {
	if (t[x] != -1) g[t[x]].emplace_back(a[x] ^ a[x - 1], i - 1);
	if (t[y] != -1) g[t[y]].emplace_back(a[y] ^ a[y - 1], i - 1);
	for (int j = x; j &lt; y; j++) a[j] ^= z;
	t[x] = t[y] = i;
      } else {
	for (int j = x; j &lt;= y &amp;&amp; j &lt;= n; j++) {
	  if (t[j] != -1) g[t[j]].emplace_back(a[j] ^ a[j - 1], i - 1);
	  t[j] = -1;
	}
	for (int j = x; j &lt; y; j++) a[j] = z;
	t[x] = t[y] = i;
      }
    }
  }
  for (int i = 1; i &lt;= n; i++) if (t[i] != -1) g[t[i]].emplace_back(a[i] ^ a[i - 1], q);
  for (int i = 0; i &lt;= q; i++) {
    for (auto &amp;v : g[i]) ins(v);
    if (!ask[i]) continue;
    BS ans;
    for (int j = m - 1; j &gt;= 0; j--) {
      if (base[j].second &gt;= i &amp;&amp; !ans[j]) ans ^= base[j].first;
    }
    for (int j = m - 1; j &gt;= 0; j--) putchar(&#34;01&#34;[ans[j]]);
    puts(&#34;&#34;);
  }
  return 0;
}
```
### 在线
```cpp
// Author:  HolyK
// Created: Mon Jul  5 15:29:33 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2005);
using BS = std::bitset&lt;N&gt;;
int n, m, q;
int base[N];
BS a[N], v[N], p[N];
void ins(int id) {
  for (int i = m - 1; i &gt;= 0; i--) {
    if (!v[id][i]) continue;
    if (!base[i]) {
      base[i] = id;
      return;
    }
    v[id] ^= v[base[i]];
    p[id] ^= p[base[i]];
  }
}
void update(int id, const BS &amp;z) {
  if (z.none()) return;
  int j = 0;
  for (int i = 1; i &lt;= n; i++) {
    if (v[i].any() || !p[i][id]) continue;
    j = i;
    break;
  }
  if (!j) {
    for (int i = 0; i &lt; m; i++) {
      if (!base[i] || !p[base[i]][id]) continue;
      j = base[i];
      base[i] = 0;
      break;
    }
  }
  assert(j);
  for (int i = 1; i &lt;= n; i++) {
    if (i == j || !p[i][id]) continue;
    v[i] ^= v[j];
    p[i] ^= p[j];
  }
  v[j] ^= z;
  ins(j);
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    v[i] = a[i] ^ a[i - 1];
    p[i].set(i);
    ins(i);
  }
  while (q--) {
    int opt, x, y;
    BS z;
    std::cin &gt;&gt; opt;
    if (opt == 1) {
      std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
      update(x, z);
      if (y &lt; n) update(y + 1, z);
      for (int i = x; i &lt;= y; i++) a[i] ^= z;
    } else if (opt == 2) {
      std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
      update(x, a[x] ^ z);
      if (y &lt; n) update(y + 1, a[y] ^ z);
      for (int i = x; i &lt; y; i++) update(i + 1, a[i] ^ a[i + 1]);
      for (int i = x; i &lt;= y; i++) a[i] = z;
    } else {
      z.reset();
      for (int i = m - 1; i &gt;= 0; std::cout &lt;&lt; z[i--]) {
	if (base[i] &amp;&amp; !z[i]) z ^= v[base[i]];
      }
      std::cout &lt;&lt; &#34;\n&#34;;
    }
  }
  return 0;
}
```- https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[ICPC2014 WF]Pachinko</title>
        <link>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</link>
        <pubDate>Mon, 12 Jul 2021 08:12:01 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/icpc2014-wfpachinko/ -

&gt; 有一个 $h×w$ 的方格表，有些格子是墙，有些格子是终点，剩下的格子是空地。
&gt;
&gt; 你现在要在这里进行随机游走，其中，每一轮向上、下、左、右的概率分别为 $u\%,d\%,l\%,r\%$，如果移动后超过方格表或到达墙，则这次移动失效，保持原地不动。
&gt;
&gt; 当你到达终点时，游戏就结束了。现在，在**方格表第一行**的所有空地中均匀随机一个作为起点，求你就进入每个终点的概率。
&gt; 
&gt; $1≤w≤20, 2≤h≤10000$。

设其中一个终点为 $t$，$f_{i, j}$ 表示 $(i, j)$ 走到 $t$ 的概率。
$$
f_{i, j} = uf_{i-1, j}+df_{i+1, j}+lf_{i, j-1}+rf_{i, j+1}
$$

$$
f_{i, j} - uf_{i-1, j} - df_{i+1, j} - lf_{i, j-1} - rf_{i, j+1}=0
$$

$$
f_t=1
$$


$$
P\cdot\mathbf{f}=\mathbf{e}
$$

$P$ 是 $wh \times wh$ 的方阵，$\mathbf{f},\mathbf{e}$ 是列向量。其中 $e_i=[i=t]$。
$$
\mathbf{f}=P^{-1}\mathbf{f}
$$
设 $1\dots s$ 为起点 ，答案为 
$$
ans = \frac1s \sum_{i=1}^sf_i
$$
写成矩阵的形式，设行向量 $\mathbf{v}^T=\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots \end{pmatrix}$，前面有 $s$ 个1，其他都是0。
$$
\begin{aligned}
ans &amp;= \frac1s \mathbf{v}^T\mathbf{f}\\
&amp;= \frac1s\mathbf{v}^TP^{-1}\mathbf{e}\\
\end{aligned}
$$
相当于求行向量 $\alpha^T = \dfrac1s\mathbf{v}^TP^{-1}$ 第 $t$ 维的值，所以只要求出这个行向量即可。
$$
\alpha^T P = \frac1s\mathbf{v}
$$

$$
P^T\alpha=\frac1s\mathbf{v}^T
$$



解这个线性方程组，直接高斯消元显然不行。

如果按照从上到下从左到右的顺序标号，$P^T$ 是一个带状矩阵，每行只需存储 $2w+1$ 个元素。

~~然后消元即可。~~

**这还有个小问题没解决，留坑！**

```cpp
// Author:  HolyK
// Created: Mon Jul  5 11:36:58 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int dx[] = {-1, 1, 0, 0}, dy[] = {0, 0, -1, 1};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, tot;
  double p[4];
  std::cin &gt;&gt; m &gt;&gt; n;
  tot = n * m;
  for (int i = 0; i &lt; 4; i++) std::cin &gt;&gt; p[i], p[i] /= 100;
  std::vector&lt;std::string&gt; s(n);
  for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; s[i];
  
  std::vector&lt;std::vector&lt;double&gt;&gt; a(tot, std::vector&lt;double&gt;(m * 2 + 1));
  for (int i = 0, o = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++, o++) {
      a[o][m] = 1;
      if (s[i][j] != &#39;.&#39;) continue;
      for (int d = 0; d &lt; 4; d++) {
	int x = i + dx[d], y = j + dy[d];
	if (x &lt; 0 || y &lt; 0 || x &gt;= n || y &gt;= m || s[x][y] == &#39;X&#39;) {
	  a[o][m] -= p[d];
	} else {
	  // a[o][m + dx[d] * m + dy[d]] -= p[d ^ 1];
	  a[x * m + y][m + o - (x * m + y)] -= p[d];
	}
      }
    }
  }
  // for (int i = 0; i &lt; tot; i++) {
  //   for (int j = 0; j &lt; m * 2 + 1; j++) std::cout &lt;&lt; a[i][j] &lt;&lt; &#34; \n&#34;[j == 2 * m];
  // }
  int cnt = 0;
  for (int i = 0; i &lt; m; i++) cnt += s[0][i] == &#39;.&#39;;
  std::vector&lt;double&gt; b(tot);
  for (int i = 0; i &lt; m; i++) b[i] = 1.0 / cnt;
  for (int i = 0; i &lt; tot; i++) {
    if (fabs(a[i][m]) &lt; 1e-12) {
      b[i] = 0;
      continue;
    }
    for (int j = i + 1; j &lt; tot &amp;&amp; j &lt;= i + m; j++) {
      double c = a[j][m + i - j] / a[i][m];
      for (int k = 0; k &lt;= m; k++) a[j][m + k + i - j] -= a[i][m + k] * c;
      b[j] -= b[i] * c;
    }
  }
  for (int i = tot - 1; i &gt;= 0; i--) {
    if (fabs(a[i][m]) &lt; 1e-12) continue;
    for (int j = i + 1; j &lt; tot &amp;&amp; j &lt;= i + m; j++) {
      b[i] -= b[j] * a[i][m + j - i];
    }
    b[i] /= a[i][m];
  }
  for (int i = 0; i &lt; n; i++)
    for (int j = 0; j &lt; m; j++)
      if (s[i][j] == &#39;T&#39;)
	printf(&#34;%.9f\n&#34;, b[i * m + j]);
  return 0;
}
```- https://blog.asukakyle.top/post/icpc2014-wfpachinko/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces938G]Shortest Path Queries</title>
        <link>https://blog.asukakyle.top/post/cf938g/</link>
        <pubDate>Thu, 15 Apr 2021 17:26:44 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/cf938g/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/cf938g/ -
&gt; 给定一个带权无向图，实现三种操作：加边，删边，询问两点间的异或最短路。
&gt; 
&gt; $n, m, q \leq 2\times 10^5$。

类似最大 xor 和路径，用线性基可以求解异或最短路。

因为线性基删除很麻烦，所以直接离线用线段树分治。

图可能不连通，需要用并查集维护连通性，然后记录每个点到当前根的异或和 $d_x$。

加边时设 $val = d_x\oplus d_y \oplus w$，如果 $x, y$ 已经联通则将 $val$ 加入当前联通块的线性基，如果不在一个并查集，连接两个根，边权为 $val$。

```cpp
#include &lt;bits/stdc++.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(2e5 + 5);
PII query[N];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
std::vector&lt;std::array&lt;int, 3&gt;&gt; g[N &lt;&lt; 2];
void update(int o, int l, int r, int x, int y, int u, int v, int w) {
  if (r &lt; x || l &gt; y) return;
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    g[o].push_back({u, v, w});
    return;
  }
  int m = l + r &gt;&gt; 1;
  update(ls, l, m, x, y, u, v, w), update(rs, m + 1, r, x, y, u, v, w);
}
std::vector&lt;std::pair&lt;int*, int&gt;&gt; changes;
void record(int &amp;x) { changes.emplace_back(&amp;x, x); }
void rollBack(size_t t) {
  while (changes.size() &gt; t) {
    *changes.back().first = changes.back().second;
    changes.pop_back();
  }
} 

int fa[N], siz[N], val[N];
int find(int &amp;x) {
  int r = val[x];
  while (x != fa[x]) r ^= val[x = fa[x]];
  return r;
}
void ins(int *p, int x) {
  if (!x) return;
  for (int i = 29; i &gt;= 0; i--) {
    if (x &gt;&gt; i &amp; 1 ^ 1) continue;
    if (!p[i]) {
      record(p[i]);
      p[i] = x;
      break;
    }
    x ^= p[i];
  }
}
int p[N][30];
void solve(int o, int l, int r) {
  size_t now = changes.size();
  for (auto [x, y, z] : g[o]) {
    int r = find(x) ^ find(y) ^ z;
    if (x == y) {
      ins(p[x], r);
    } else {
      if (siz[x] &gt; siz[y]) std::swap(x, y);
      record(fa[x]), record(siz[y]), record(val[x]);
      fa[x] = y, siz[y] += siz[x], val[x] ^= r;
      for (int i = 0; i &lt; 30; i++) ins(p[y], p[x][i]);
    }
  }
  if (l == r) {
    auto [x, y] = query[l];
    if (x) {
      int ans = find(x) ^ find(y);
      assert(x == y);
      for (int i = 29; i &gt;= 0; i--) smin(ans, ans ^ p[x][i]);
      std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    }
    rollBack(now);
    return;
  }
  int m = l + r &gt;&gt; 1;
  solve(ls, l, m), solve(rs, m + 1, r);
  rollBack(now);
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m;
  std::cin &gt;&gt; n &gt;&gt; m;
  std::map&lt;PII, PII&gt; t;
  while (m--) {
    int x, y, z;
    std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    t[PII(x, y)] = {0, z};
  }
  std::cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; i++) {
    int opt, x, y;
    std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    if (opt == 1) {
      int z;
      std::cin &gt;&gt; z;
      t[PII(x, y)] = {i, z};
    } else if (opt == 2) {
      auto [l, w] = t[PII(x, y)];
      update(1, 1, m, l, i - 1, x, y, w);
      t.erase(PII(x, y));
    } else {
      query[i] = {x, y};
    }
  }
  for (auto &amp;[u, v] : t) {
    auto &amp;[x, y] = u;
    auto &amp;[l, w] = v;
    update(1, 1, m, l, m, x, y, w);
  }
  std::iota(fa, fa + 1 + n, 0);
  std::fill(siz, siz + 1 + n, 1);
  solve(1, 1, m);
  return 0;
}
```
- https://blog.asukakyle.top/post/cf938g/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Gym102994</title>
        <link>https://blog.asukakyle.top/post/gym102994/</link>
        <pubDate>Thu, 15 Apr 2021 09:03:20 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/gym102994/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/gym102994/ -## 总览
|   题号   | A | B | C | D | E | F | G | H | I | J | K | L | M |
|:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|---|---|
| 完成情况 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 |

## A. Everyone Loves Playing Games
&gt; A 有 $N$ 对数， B 有 $M$ 对数，A 从 $N$ 对数中分别选一个数得到异或和 $X$，然后 B 从 $N$ 对数得到一个异或和 $Y$，$A$ 希望 $X \oplus Y$ 最大，$B$ 希望 $X \oplus Y$ 最小，求最后的结果。
&gt; 
&gt; $N, M \leq 10000, 0 \leq x \leq 10^{18}$。

设每对数为 $(x_i, y_i)$，先都选上 $x_i$，然后变成选或不选 $x_i \oplus y_i$ 的问题。

A 和 B 分别建出线性基，然后从高位向低位考虑。

只需要考虑某一位 A 和 B 都有影响的情况，这位如果为 1 那么 A B 只会选一个，如果为 0 则要么都选，要么都不选，不管哪种情况两种状态都可以通过异或 $A_i \oplus B_i$ 来相互转换，所以这种情况将 $A_i \oplus B_i$ 插入 $A$ 的线性基来提供“反悔”的机会。

```cpp
#include &lt;bits/stdc++.h&gt;
#include &lt;string.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

struct LinearBasis {
  LL p[61];
  LinearBasis() {
    memset(p, 0, sizeof p);
  }
  void ins(LL x) {
    for (int i = 60; i &gt;= 0; i--) {
      if (x &gt;&gt; i &amp; 1 ^ 1) continue;
      if (!p[i]) {
        p[i] = x;
        break;
      }
      x ^= p[i];
    }
  }
};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int n, m;
    std::cin &gt;&gt; n &gt;&gt; m;
    LinearBasis p, q;
    LL ans = 0;
    for (int i = 0; i &lt; n; i++) {
      LL x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
      ans ^= x;
      p.ins(x ^ y);
    }
    for (int i = 0; i &lt; m; i++) {
      LL x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
      ans ^= x;
      q.ins(x ^ y);
    }
    for (int i = 60; i &gt;= 0; i--) {
      auto a = p.p[i], b = q.p[i];
      ans = std::max(std::min(ans ^ a, ans ^ a ^ b), std::min(ans, ans ^ b));
      if ((a &amp; b) &gt;&gt; i &amp; 1) p.ins(a ^ b);
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## B. Gifted Composer
&gt; 有一个空字符串，每次操作在开头或结尾加一个字符，然后求当前字符串的循环节个数。
&gt; 
&gt; $n \leq 10^6$。

长度为 $x$ 的循环节一定在第 $x$ 次操作后出现，然后在某一时间消失，后面不会再出现。

枚举 $x$ 然后二分这个消失的时间，判断循环节可以通过判断是否存在长度 $n - x$ 的 Border 来实现。

复杂度 $O(n \log n)$。

```cpp
#include &lt;bits/stdc++.h&gt;

constexpr uint32_t P(1e9 + 7);
using Hash = std::pair&lt;uint64_t, uint64_t&gt;;
inline Hash operator+(Hash a, Hash b) {
  return {a.first + b.first, (a.second + b.second) % P}; 
}
inline Hash operator-(Hash a, Hash b) {
  return {a.first - b.first, (a.second + P - b.second) % P}; 
}
inline Hash operator*(Hash a, Hash b) {
  return {a.first * b.first, a.second * b.second % P};
}
constexpr Hash Base(131, 31);
constexpr int N(1e6 + 5);
Hash pw[N];
int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  int n;
  std::cin &gt;&gt; n;
  int l = 0;
  std::deque&lt;char&gt; s;
  std::string opt;
  for (int i = 0; i &lt; n; i++) {
    std::string a, b;
    std::cin &gt;&gt; a &gt;&gt; b;
    opt += a;
    if (a[0] == &#39;p&#39;) {
      l++, s.push_front(b[0] + (b[1] == &#39;i&#39;));
    } else {
      s.push_back(b[0] + (b[1] == &#39;i&#39;));
    }
  }
  pw[0] = {1, 1};
  for (int i = 1; i &lt;= n; i++) pw[i] = pw[i - 1] * Base;
  std::vector&lt;Hash&gt; h(n); h[0] = {s[0], s[0]};
  for (int i = 1; i &lt; n; i++) h[i] = h[i - 1] * Base + Hash(s[i], s[i]);
  std::vector&lt;std::pair&lt;int, int&gt;&gt; interval;
  interval.reserve(n);
  int r = l - 1;
  for (char c : opt) {
    if (c == &#39;p&#39;) {
      l--;
    } else {
      r++;
    }
    interval.emplace_back(l, r);
  }
  assert(interval.size() == n);
  std::vector&lt;int&gt; ans(n + 1);
  auto get = [&amp;](int l, int r) {
    return l &lt;= r ? h[r] - (l ? h[l - 1] * pw[r - l + 1] : Hash()) : Hash();
  };
  for (int i = 0; i &lt; n; i++) {
    l = i, r = n;
    while (l &lt; r) {
      int m = l + r &gt;&gt; 1;
      auto [x, y] = interval[m];
      if (get(x, y - i - 1) == get(x + i + 1, y)) {
        l = m + 1;
      } else {
        r = m;
      }
    }
    ans[i]++, ans[l]--;
  }
  for (int i = 1; i &lt;= n; i++) ans[i] += ans[i - 1], std::cout &lt;&lt; ans[i - 1] &lt;&lt; &#34;\n&#34;;
  
  return 0;
}
```

## C. An Unsure Catch


## D. String Theory
&gt; 给定一个字符串 $S$，和整数 $k$，求形如 $AAA\dots A$ （$k$ 个 $A$）的子串的个数，其中 $A$ 是任意非空字符串。
&gt; 
&gt; $n \leq 3 \times 10^5, 1 \leq k \leq 20$。

枚举循环节长度 $i$，枚举左端点 $l$，右端点 $r$ 可以二分得出，然后这个贡献是 $r - l + 1 - ki + 1$，发现下一个左端点一定在区间 $[r - k + 1, r + 1]$，总枚举次数是调和级数。

复杂度 $O(n \log^2 n)$。

$k \leq 20$ 的条件实际上是没用的。

```cpp
#include &lt;bits/stdc++.h&gt;
constexpr uint32_t P(1e9 + 7);
using Hash = std::pair&lt;uint64_t, uint64_t&gt;;
inline Hash operator+(Hash a, Hash b) {
  return {a.first + b.first, (a.second + b.second) % P}; 
}
inline Hash operator-(Hash a, Hash b) {
  return {a.first - b.first, (a.second + P - b.second) % P}; 
}
inline Hash operator*(Hash a, Hash b) {
  return {a.first * b.first, a.second * b.second % P};
}
constexpr Hash Base(131, 31);
constexpr int N(3e5 + 5);
Hash pw[N];
int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  int t, k = 3e5;
  pw[0] = {1, 1};
  for (int i = 1; i &lt;= k; i++) pw[i] = pw[i - 1] * Base;
  std::cin &gt;&gt; t;
  while (t--) {
    std::string s;
    std::cin &gt;&gt; k &gt;&gt; s;
    int n = s.length();
    if (k == 1) {
      std::cout &lt;&lt; 1LL * n * (n + 1) / 2 &lt;&lt; &#34;\n&#34;;
      continue;
    }
    std::vector&lt;Hash&gt; h(n);
    h[0] = {s[0], s[0]};
    for (int i = 1; i &lt; n; i++) h[i] = h[i - 1] * Base + Hash(s[i], s[i]);
    auto get = [&amp;](int l, int r) {
      return l &lt;= r ? h[r] - (l ? h[l - 1] * pw[r - l + 1] : Hash()) : Hash();
    };
    auto check = [&amp;](int l, int r, int x) {
      return get(l, r - x) == get(l + x, r);
    };
    long long ans = 0;
    for (int i = 1, l, r; i &lt;= n; i++) {
      for (int j = 0; j &lt;= n - i; j = r + 1) {
        l = std::max(0, j - i + 1), r = j;
        while (l &lt; r) {
          int m = l + r &gt;&gt; 1;
          if (check(m, j + i - 1, i)) {
            r = m;
          } else {
            l = m + 1;
          }
        }
        r = j;
        if (n - 1 &gt; r) {
          for (int k = 1 &lt;&lt; std::__lg(n - 1 - r); k; k &gt;&gt;= 1) {
            if (r + k &lt; n &amp;&amp; check(l, r + k, i)) r += k;
          }
        }
        assert(r &gt;= j + i - 1);
        ans += std::max(0, r - l + 1 - k * i + 1);
      }
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## E. Road Construction

## F. Girlfriend
&gt; 给定一个无向图，q 次询问 $s$ 到 $t$ 的次大边权的最小值。
&gt; 
&gt; $n, q \leq 10^5, m \leq 2 \times 10^5$。

二分答案 $ans$，问题转化为判断是否存在一条边连接两个联通块（$s$ 和 $t$ 只走小于等于 $ans$ 的边形成的联通块）。

建出 kruskal 重构树倍增即可求出这两个联通块。

然后判断是否存在连接两个子树的边，转换成 dfs 序后用一个二维偏序的数据结构解决即可。

复杂度 $O(n \log^2 n)$。


```cpp
#include &lt;bits/stdc++.h&gt;

    constexpr int N(2e5 + 5);
int up[20][N], fa[N], in[N], out[N], cnt, val[N];
int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
};
std::vector&lt;int&gt; g[N];
void dfs(int x) {
  in[x] = ++cnt;
  for (int y : g[x]) {
    // assert(!in[y]);
    dfs(y);
  }
  out[x] = cnt;
}

struct Node {
  int ls, rs, w;
} t[N * 50];
int pt;
void ins(int &amp;o, int l, int r, int x) {
  t[++pt] = t[o], o = pt, t[o].w++;
  if (l == r) return;
  int m = l + r &gt;&gt; 1;
  x &lt;= m ? ins(t[o].ls, l, m, x) : ins(t[o].rs, m + 1, r, x);
}
int ask(int u, int v, int l, int r, int x, int y) {
  if (x &lt;= l &amp;&amp; r &lt;= y) return t[v].w - t[u].w;
  int m = l + r &gt;&gt; 1, ans = 0;
  if (x &lt;= m) ans += ask(t[u].ls, t[v].ls, l, m, x, y);
  if (y &gt; m) ans += ask(t[u].rs, t[v].rs, m + 1, r, x, y);
  return ans;
}
int root[N];
bool check(int x, int y, int z) {
  for (int i = 18; i &gt;= 0; i--) {
    if (up[i][x] &amp;&amp; val[up[i][x]] &lt;= z) x = up[i][x];
  }
  for (int i = 18; i &gt;= 0; i--) {
    if (up[i][y] &amp;&amp; val[up[i][y]] &lt;= z) y = up[i][y];
  }
  return ask(root[in[x] - 1], root[out[x]], 1, cnt, in[y], out[y]) &gt; 0;
}

int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int n, m, q;
    cnt = pt = 0;
    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;
    std::iota(fa + 1, fa + 1 + 2 * n, 1);
    for (int i = 1; i &lt;= n + n; i++) g[i].clear();
    std::vector&lt;std::array&lt;int, 3&gt;&gt; e(m);
    for (auto &amp;[z, x, y] : e) std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    std::sort(e.begin(), e.end());
    int id = n;
    for (auto [z, x, y] : e) {
      x = find(x), y = find(y);
      if (x == y) continue;
      fa[x] = fa[y] = ++id;
      g[id].push_back(x);
      g[id].push_back(y);
      up[0][x] = up[0][y] = id;
      val[id] = z;
      up[0][id] = 0;
    }

    for (int i = 1; i &lt;= 18; i++)
      for (int j = 1; j &lt;= id; j++) {
        up[i][j] = up[i - 1][up[i - 1][j]];
      }
    for (int i = n + 1; i &lt;= id; i++) {
      if (!up[0][i]) dfs(i);
    }
    std::vector&lt;std::vector&lt;int&gt;&gt; h(id + 1);
    for (auto [z, x, y] : e) {
      h[in[x]].push_back(in[y]);
      h[in[y]].push_back(in[x]);
    }
    for (int i = 1; i &lt;= cnt; i++) {
      root[i] = root[i - 1];
      for (auto j : h[i]) ins(root[i], 1, cnt, j);
    }
    while (q--) {
      int x, y;
      std::cin &gt;&gt; x &gt;&gt; y;
      if (find(x) != find(y)) {
        std::cout &lt;&lt; &#34;-1\n&#34;;
        continue;
      }
      int l = 0, r = 1e9;
      while (l &lt; r) {
        int m = l + r &gt;&gt; 1;
        if (check(x, y, m)) {
          r = m;
        } else {
          l = m + 1;
        }
      }
      std::cout &lt;&lt; l &lt;&lt; &#34;\n&#34;;
    }
  }
  return 0;
}
```

## G. Blackjack
&gt; 有 $n$ 个物品，权值为 $v_i$，每轮随机拿走一个，然后你可以选择是否进行下一轮，求最优策略下，最后拿走物品的权值和在 $(a, b]$ 区间内的概率。
&gt; $n, v_i, a, b \leq 500$。

最优策略显然就是一直拿直到落到 $(a, b]$ 上，或者超过了 $b$ 游戏结束。

问题转化成随机拿若干个物品，最后落在 $(a, b]$，且倒数第二步没有落在 $(a, b]$ 的概率。

这是个背包问题，先求出整个背包，然后枚举最后一个拿的物品退背包即可。

复杂度 $O(n^2b)$。

```cpp
#include &lt;bits/stdc++.h&gt;
#define perr(a...) fprintf(stderr, a)
#define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, a, b;
  std::cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
  std::vector&lt;std::vector&lt;double&gt;&gt; f(1, std::vector&lt;double&gt;(b + 1)), g;
  f[0][0] = 1;
  std::vector&lt;int&gt; v(n);
  for (auto &amp;x : v) {
    std::cin &gt;&gt; x;
    f.emplace_back(b + 1);
    for (int i = f.size() - 1; i; i--) {
      for (int j = b; j &gt;= x; j--) {
        f[i][j] += f[i - 1][j - x] / (n - i + 1) * i;
      }
    }
  }
  double ans = 0;
  for (auto x : v) {
    g = f;
    for (int i = 1; i &lt;= n; i++)
      for (int j = x; j &lt;= b; j++) {
        g[i][j] -= g[i - 1][j - x] / (n - i + 1) * i;
      }
    for (int i = 0; i &lt; n; i++) {
      for (int j = std::max(a + 1, x); j - x &lt;= a &amp;&amp; j &lt;= b; j++) {
        ans += g[i][j - x] / (n - i);
      }
    }
  }
  printf(&#34;%.10f\n&#34;, ans);
  return 0;
}
```

## H. Yet Another Geometry Problem


## I. A Math Problem


## J. Gaokao
签到题。

## K. Data Structure
&gt; 给定一棵树，$q$ 次操作，第一种操作为 $a, x, y, z$ 表示 $a$ 的子树中距离 $a$ 模 $x$ 余 $y$ 的点权值加 $z$，第二种操作为询问 $a$ 的权值。
&gt; 
&gt; $n, q \leq 3\times 10^5$。

如果暴力修改的话一种思路是按深度将点分类，直接 $\frac n x$ 次区间修改，然后单点查询。

另一种思路是每个模数用dfs序维护子树，每次区间修改 $[in_a, out_a]$，查询时枚举模数单点查询。

按 $x$ 分类，大于 $X$ 的用第一种，小于 $X$ 的用第二种。

设两种单次修改时间分别为 $C_1(n), C_2(n)$，单次查询时间分别为 $Q_1(n), Q_2(n)$，则总复杂度为

$$
O\left(q\left[\frac{n}{X} C_1(n) + C_2(n) + Q_1(n) + XQ_2(n)\right]\right)
$$

取 $X = \sqrt\frac{nC_1(n)}{Q_2(n)}$，最优复杂度为
$$
O\left(q\left[\sqrt{nC_1(n)Q_2(n)} + C_2(n) + Q_1(n)\right]\right)
$$

如果 $C_1(n) = Q_2(n) = O(1), C_2(n) = Q_1(n) = O(\sqrt n)$，可以做到 $O(q \sqrt n)$。

这题我现场写了树状数组和线段树，$O(q \sqrt n \log n)$，也跑过了。

```cpp
#include &lt;bits/stdc++.h&gt;

constexpr int N(3e5 + 5), T(233);

std::vector&lt;int&gt; g[N], h[N];
int in[N], out[N], dep[N], id[N], max_dep;
void dfs(int x) {
  max_dep = std::max(max_dep, dep[x]);
  in[x] = ++in[0];
  id[x] = h[dep[x]].size();
  h[dep[x]].push_back(in[x]);
  for (int y : g[x]) {
    dep[y] = dep[x] + 1;
    dfs(y);
  }
  out[x] = in[0];
}
struct FenwickTree {
  std::vector&lt;int&gt; c;
  FenwickTree(int n = -1) : c(n + 1) {}
  void add(int p, int x) {
    for (p++; p &lt; c.size(); p += p &amp; -p) c[p] += x;
  }
  int ask(int p) {
    int r = 0;
    for (p++; p; p -= p &amp; -p) r += c[p];
    return r;
  }
} bit[N];

struct Node {
  int ls, rs, w;
} t[N * 100];
int cnt;
void ins(int &amp;o, int l, int r, int x, int y, int z) {
  if (!o) t[o = ++cnt] = {0, 0, 0};
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    t[o].w += z;
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) ins(t[o].ls, l, m, x, y, z);
  if (y &gt; m) ins(t[o].rs, m + 1, r, x, y, z);
}
int ask(int o, int l, int r, int x) {
  if (!o) return 0;
  if (l == r) return t[o].w;
  int m = l + r &gt;&gt; 1;
  return t[o].w + (x &lt;= m ? ask(t[o].ls, l, m, x) : ask(t[o].rs, m + 1, r, x));
}
int n, root[T][T];
int ask(int a) {
  int ans = bit[dep[a]].ask(id[a]);
  for (int i = 1; i &lt; T; i++) {
    ans += ask(root[i][dep[a] % i], 1, n, in[a]);
  }
  return ans;
}
int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  int t;
  std::cin &gt;&gt; t;
  while (t--) {
    int m;
    std::cin &gt;&gt; n &gt;&gt; m;
    for (int i = 1; i &lt;= n; i++) g[i].clear(), h[i].clear();
    for (int i = 2, x; i &lt;= n; i++) {
      std::cin &gt;&gt; x;
      g[x].push_back(i);
    }
    in[0] = 0;
    max_dep = 0;
    dfs(1);
    for (int i = 0; i &lt;= max_dep; i++) bit[i] = FenwickTree(h[i].size());
    cnt = 0;
    for (int i = 0; i &lt; T; i++)
      for (int j = 0; j &lt; i; j++) root[i][j] = 0;
    while (m--) {
      int opt, a;
      std::cin &gt;&gt; opt &gt;&gt; a;
      if (opt == 1) {
        int x, y, z;
        std::cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
        if (x &gt;= T) {
          for (int i = dep[a] + y; i &lt;= max_dep; i += x) {
            int l = std::lower_bound(h[i].begin(), h[i].end(), in[a]) -
                    h[i].begin();
            int r = std::upper_bound(h[i].begin(), h[i].end(), out[a]) -
                    h[i].begin();
            bit[i].add(l, z), bit[i].add(r, -z);
          }
        } else {
          ins(root[x][(y + dep[a]) % x], 1, n, in[a], out[a], z);
        }
      } else {
        std::cout &lt;&lt; ask(a) &lt;&lt; &#34;\n&#34;;
      }
    }
  }
  return 0;
}
```

## L. Landlord
签到题。

## M. Travel Dream

- https://blog.asukakyle.top/post/gym102994/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 