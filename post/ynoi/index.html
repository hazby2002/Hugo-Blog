<!DOCTYPE html>
<html><head>
<title>Ynoi 等 lxl 题做题记录</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">











<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">


  






<link rel="stylesheet" href="/scss/journal.min.8e28ea12f6e17fa31de20b68201547b6843cb5deca28115ad2f58c2a899823e3.css" integrity="sha256-jijqEvbhf6Md4gtoIBVHtoQ8td7KKBFa0vWMKomYI&#43;M=" media="screen">



<script src="/vendor/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>




















<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]], [["\\(", "\\)"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\\[", "\\]"],
    ],
    svg: {
      fontCache: "global",
    },
    options: {
    enableMenu: true,          
    menuOptions: {
      settings: {
        texHints: true,        
        semantics: false,      
        zoom: 'NoZoom',        
        zscale: '200%',        
        renderer: 'CHTML',     
        alt: false,            
        cmd: false,            
        ctrl: false,           
        shift: false,          
        scale: 1,              
        inTabOrder: true,      

        assistiveMml: true,    
        collapsible: false,    
        explorer: false,       
      },
      annotationTypes: {
        TeX: ['TeX', 'LaTeX', 'application/x-tex'],
        StarMath: ['StarMath 5.0'],
        Maple: ['Maple'],
        ContentMathML: ['MathML-Content', 'application/mathml-content+xml'],
        OpenMath: ['OpenMath']
      }
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js">
    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>

<link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.initLineNumbersOnLoad();</script>

</head>
<body>
    	<div id="app"><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://blog.asukakyle.top">
    
        <div class="nav-title">
            HolyK&#39;s Blog
        </div>
        
        <div class="nav-subtitle">
            明日は明日の風が吹く
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                About
            </a>
            
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/post">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/friend">
                Friends
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS Feed
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    About
                </a>
                
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/post">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/friend">
                    Friends
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS Feed
                </a>
                
            
            
            <div class="toc">


</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://blog.asukakyle.top">
            HolyK&#39;s Blog
        </a>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://blog.asukakyle.top">
        <div class="single-column-header-title">HolyK&#39;s Blog</div>
        
        <div class="single-column-header-subtitle">明日は明日の風が吹く</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper"
                
                    style="background-image: url('http://www.dmoe.cc/random.php')"
                
            >
                <div class="post-title">
                    Ynoi 等 lxl 题做题记录
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2022-04-01 12:59
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/%E9%A2%98%E8%A7%A3">题解</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    ## 前言
题目是乱序的。因为太菜了不会卡常，所以很多题是九十几分。

**UPD. 2022.04.27**

发现很多以前写的懒得写题解，感觉又都不太会了，后面还是做一题写一题比较好。

发现刷 Ynoi 收益很小，大部分时间只是在卡常。

不过数据结构题写起来有意思，自己写起来乐在其中，可能刷 Ynoi 对于算法竞赛并没有什么用，更多只是自我满足罢了。

## <a href = "https://www.luogu.com.cn/problem/P5047">P5047	[Ynoi2019 模拟赛] Yuno loves sqrt technology II</a>

> 给定序列 $a_n$, $m$ 次询问区间逆序对。
> 
> $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$。

莫队二次离线。

求前缀比它小/大的数的个数，用 $O(\sqrt n)$ 修改，$O(1)$ 查询的搞一下就行。

```cpp
#include <bits/stdc++.h>

constexpr int T(512), N(1e5 + 5), S(N / T + 1);
struct Qry {
  int l, r, id;
  bool operator<(const Qry &rhs) const {
    return l / T == rhs.l / T ? l / T & 1 ? r < rhs.r : r > rhs.r : l < rhs.l;
  }
};
int n, m;

int a[N], s[S];
void clear() {
  memset(a, 0, sizeof a);
  memset(s, 0, sizeof s);
}
void add(int p) {
  int t = p / T;
  for (int i = t * T; i <= p; i++) a[i]++;
  for (int i = 0; i < t; i++) s[i]++;
}
int ask(int p) {
  p = std::max(p, 0);
  return a[p] + s[p / T];
}


int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  std::cin >> n >> m;
  std::vector<int> a(n);
  for (int &x : a) std::cin >> x;
  auto b = a;
  std::sort(b.begin(), b.end());
  b.resize(std::unique(b.begin(), b.end()) - b.begin());
  for (int &x : a) x = std::lower_bound(b.begin(), b.end(), x) - b.begin();
  std::vector<long long> c(n + 1), d(n + 1);
  
  for (int i = 0; i < n; i++) {
    add(a[i]);
    c[i + 1] = c[i] + ask(a[i + 1] + 1);
    d[i + 1] = d[i] + i + 1 - ask(a[i]);
  }
  std::vector<Qry> q(m);
  for (int i = 0; i < m; i++) {
    std::cin >> q[i].l >> q[i].r;
    q[i].l--, q[i].r--;
    q[i].id = i;
  }
  std::sort(q.begin(), q.end());
  std::vector<long long> ans(m), out(m);
  std::vector<std::vector<std::array<int, 3>>> g(n), h(n);
  for (int i = 0, x = 1, y = 0; i < m; i++) {
    if (y != q[i].r) {
      ans[i] += c[q[i].r] - c[y];
      if (x) y < q[i].r ? g[x - 1].push_back({y + 1, q[i].r, -i - 1}) : g[x - 1].push_back({q[i].r + 1, y, i});
      y = q[i].r;
    }
    if (x != q[i].l) {
      ans[i] += d[q[i].l] - d[x];
      x < q[i].l ? h[y].push_back({x, q[i].l - 1, -i - 1}) : h[y].push_back({q[i].l, x - 1, i});
      x = q[i].l;
    }
  }
  clear();
  for (int i = 0; i < n; i++) {
    add(a[i]);
    for (auto [l, r, id] : g[i]) {
      int c = id < 0 ? id = -id - 1, -1 : 1;
      for (int j = l; j <= r; j++) {
	ans[id] += c * ask(a[j] + 1);
      }
    }
    for (auto [l, r, id] : h[i]) {
      int c = id < 0 ? id = -id - 1, -1 : 1;
      for (int j = l; j <= r; j++) {
	ans[id] += c * (i + 1 - ask(a[j]));
      }
    }
  }
  for (int i = 1; i < m; i++) ans[i] += ans[i - 1];
  for (int i = 0; i < m; i++) out[q[i].id] = ans[i];
  for (auto x : out) std::cout << x << "\n";
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5046">P5046	[Ynoi2019 模拟赛] Yuno loves sqrt technology I</a>
> 给定 $1\dots n$ 的 **排列** $a_n$, $m$ 次询问区间逆序对。
> 
> $1 \leq n, m \leq 10^5$。
> 
> 强制在线。

序列分块，块内预处理前缀后缀逆序对，每块预处理该块和原序列前缀的逆序对。

块内用两个前缀相减，再归并计算两个前缀之间的贡献。

整块直接用预处理的计算，然后用归并计算两个散块之间的贡献。

$O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Tue Sep 14 14:01:15 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(1e5 + 5), T(512);
LL cal(PII *a, PII *b, int l1, int r1, PII *c, PII *d, int l2, int r2) {
  LL res = 0;
  for (int now = 0; a < b; a++) {
    if (a->second < l1 || a->second >= r1) continue;
    for (; c < d && *c < *a; c++) {
      if (c->second < l2 || c->second >= r2) continue;
      now++;
    }
    res += now;
  }
  return res;
}

int n, m, a[N];
PII b[N], bb[N];
int c[N];
void add(int p, int x) {
  for (; p <= n; p += p & -p) c[p] += x;
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p & -p) r += c[p];
  return r;
}
constexpr int S((N - 1 + T) / T);
LL pre[N], suf[N], cnt[S][N];

int main() {
  // freopen("t.in", "r", stdin);
  // freopen(".out", "w", stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin >> n >> m;

  for (int i = 0; i < n; i++) {
    cin >> a[i];
    bb[i] = b[i] = {a[i], i};
  }
  std::sort(bb, bb + n);
  for (int l = 0, o = 0; l < n; l += T, o++) {
    int r = std::min(n, l + T);
    std::sort(b + l, b + r);
    
    for (int i = 0, j = l; i < n || j < r;) {
      if (j == r || i < n && bb[i] < b[j]) {
        cnt[o][bb[i].second] += j - l;
        i++;
      } else {
        j++;
      }
    }
    for (int i = 1; i < n; i++) cnt[o][i] += cnt[o][i - 1];
    
    for (int i = l; i < r; i++) {
      pre[i] = i - l - ask(a[i]);
      add(a[i], 1);
    }
    for (int i = l; i < r; i++) {
      add(a[i], -1);      
    }
    for (int i = r - 1; i >= l; i--) {
      suf[i] = ask(a[i]);
      add(a[i], 1);
    }
    for (int i = l; i < r; i++) {
      add(a[i], -1);
    }
    
    for (int i = l + 1; i < r; i++) pre[i] += pre[i - 1];
    for (int i = r - 2; i >= l; i--) suf[i] += suf[i + 1];
  }
  LL ans = 0;
  while (m--) {
    LL l, r;
    cin >> l >> r;
    l ^= ans, r ^= ans;
    l--, r--;
    int bl = l / T, br = r / T;
    if (bl == br) {
      ans = pre[r] - (l == bl * T ? 0 : pre[l - 1]);
      int x = bl * T, y = std::min(n, x + T);
      ans -= cal(b + x, b + y, x, l, b + x, b + y, l, r + 1);
    } else {
      ans = suf[l] + pre[r];
      ans += std::max(0, (br - bl - 1) * T) * (r - br * T + 1LL);
      
      for (int i = bl + 1; i < br; i++) {
        ans += suf[i * T];
        ans += cnt[i][i * T - 1];
        if (l) ans -= cnt[i][l - 1];
        ans -= cnt[i][r] - cnt[i][br * T - 1];
      }
      // std::cerr << ans << "\n";
      ans += cal(b + bl * T, b + bl * T + T, l, bl * T + T,
                 b + br * T, b + std::min(n, br * T + T), br * T, r + 1);
    }
    std::cout << ans << "\n";
    // break;
  }
  
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5048">P5048	[Ynoi2019 模拟赛] Yuno loves sqrt technology III</a>
> 给定序列 $a_n$, $m$ 次询问区间众数出现的次数。
> 
> $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$。
> 
> 强制在线。

区间众数要么是中间的整块的众数，要么是两边散块的。

预处理整块两两之间区间的众数个数，然后用 vector 存每个数出现的位置。

对于散块每个数，直接看它的位置 +ans 之后还在不在询问区间内，在的话就暴力拓展。拓展次数是 $O(\sqrt n)$ 级别。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Tue Sep 14 17:41:10 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(5e5 + 5), T(512), S((N - 1 + T) / T);
int n, m, a[N], b[N], c[N], pos[N], cnt[S][S];
struct LazyVector {
  std::vector<int> a, b;
  int c;
  LazyVector(int n) : a(n), b(n), c(0) {}
  void clear() { c++; }
  int &operator[](const int &i) {
    if (b[i] != c) b[i] = c, a[i] = 0;
    return a[i];
  }
};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m;
  for (int i = 0; i < n; i++) {
    std::cin >> a[i];
    b[i] = a[i];
  }
  std::sort(b, b + n);
  int t = std::unique(b, b + n) - b;
  for (int i = 0; i < n; i++) {
    a[i] = std::lower_bound(b, b + t, a[i]) - b;
    c[a[i]]++;
  }
  for (int i = 1; i < t; i++) c[i] += c[i - 1];
  for (int i = n - 1; i >= 0; i--) {
    b[--c[a[i]]] = i;
    pos[i] = c[a[i]];
  }
  LazyVector v(t);
  for (int i = 0; i < n; i += T) {  
    int max = 0;
    v.clear();
    for (int j = i + T; j < n; j += T) {
      for (int k = j - T; k < j; k++) 
        smax(max, ++v[a[k]]);
      cnt[i / T][j / T] = max;
    }
  }
  int ans = 0;
  while (m--) {
    int l, r;
    std::cin >> l >> r;
    l ^= ans, r ^= ans;
    l--, r--;
    int bl = l / T, br = r / T;
    if (bl == br) {
      ans = 0;
      v.clear();
      for (int i = l; i <= r; i++) {
        smax(ans, ++v[a[i]]);
      }
    } else {
      ans = cnt[bl + 1][br];
      int y = bl * T + T, x = br * T;
      for (int i = l; i < y; i++) {
        while (pos[i] + ans < n && b[pos[i] + ans] <= r && a[b[pos[i] + ans]] == a[i]) ans++;
      }
      for (int i = x; i <= r; i++) {
        while (pos[i] - ans >= 0 && b[pos[i] - ans] >= l && a[b[pos[i] - ans]] == a[i]) ans++;
      }
    }
    std::cout << ans << "\n";
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P7447">P7447 [Ynoi2007] rgxsxrs</a>
> 给定一个序列 $a_n$，$m$ 次操作：
> 
> 区间 $[l, r]$ 大于 $x$ 的数减 $x$；求区间和、最大最小值。
>
> $n, m \leq 5 \times 10^5, 1 \leq a_i, x \leq 10^9$
> 
> 空间限制 64MB，强制在线。

值域倍增分块，$[b^k, b^{k+1})$ 在一个块里，所以有 $\log_b a$ 个块。每一块开一个线段树。

修改时，若 $x < b^k$，则块内所有数都要减 $x$，有些数被减后会掉落到更小的值域块中，掉落操作会发生 $n \log_b a$ 次，每次需要 $\log n$ 的时间定位和修改，均摊下来还是 $O(n\log_b a \log n)$。

若 $b^k \leq x < b^{k+1}$，则块内有些数需要减 $x$。因为 $x \ge b^k$，所以每个数最多减 $b$ 次就会掉落，所以每个数最多会被减 $b\log_b a$ 次，最坏情况下每次需要 $\log n$ 时间定位，所以是 $O(nb\log_b a \log n)$。
 
若 $x \ge b^{k+1}$ 则什么都不用做。

设 $n, m$ 同阶，时间复杂度是 $O(nb \log n \log_b a)$，空间复杂度是 $O(n \log_b a)$，取 $b = 2$ 时间最优，但是空间炸了。

考虑先将原序列分块，块大小 $B = \log_b a$，然后线段树节点数变为 $O(n / B)$，这样线段树定位和修改的复杂度变成了 $O(\log n + B)$，仅仅增加了一点常数。

在实现时，要根据实际情况选取 $b, B$ 的大小，为了 cache 友好，不写 $\log_b a$ 棵线段树，而是每个线段树维护 $O(\log_b a)$ 的信息。

```cpp
// Author:  HolyK
// Created: Fri Aug 27 21:50:45 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair<int, int>;
using u64 = uint64_t;
using u32 = uint32_t;
constexpr int N(5e5), T(8), P(32 / T), S(1 << P), B(32), L((N + B - 1) / B);
int n, m, k;
u32 a[N];
u64 pw[T + 1];
struct Info {
  u32 min, max, siz;
  u64 sum;
  Info &operator+=(const Info &r) {
    smin(min, r.min);
    smax(max, r.max);
    siz += r.siz;
    sum += r.sum;
    return *this;
  }
  void tag(const u32 &x) {
    min -= x, max -= x, sum -= u64(siz) * x;
  }
  void ins(const u32 &x) {
    smin(min, x), smax(max, x), siz++, sum += x;
  }
} t[L * 4][T];
u32 tag[L * 4][T];
u32 pos(u32 x) { return std::__lg(x) / P; }
constexpr Info Null = {~0U, 0U, 0U, 0ULL};
inline Info operator+(const Info &a, const Info &b) { return {std::min(a.min, b.min), std::max(a.max, b.max), a.siz + b.siz, a.sum + b.sum}; }
#define ls o << 1
#define rs o << 1 | 1
#define APPLY() for (int _ = 0; _ < T; _ += 4) F(_), F(_ + 1), F(_ + 2), F(_ + 3)
void pushup(int o) {
#define F(i) t[o][i] = t[ls][i] + t[rs][i]
  APPLY();
#undef F
}
void add(int o, int i, u32 z) {
  if (t[o][i].siz) {
    t[o][i].tag(z);
    tag[o][i] += z;
  }
}
void pushdown(int o) {
#define F(i) (tag[o][i] ? (add(ls, i, tag[o][i]), add(rs, i, tag[o][i]), tag[o][i] = 0) : 1)
  APPLY();
#undef F
}
u32 max, min;
u64 sum;
void ask(int o, int l, int r, int x, int y) {
  if (r - l == 1) {
    for (int i = l * B; i < r * B && i < n; i++) {
      a[i] -= tag[o][pos(a[i])];
    }
    memset(tag[o], 0, sizeof tag[o]);
    for (int i = x; i < y; i++) {
      smax(max, a[i]);
      smin(min, a[i]);
      sum += a[i];
    }
    return;
  }
  if (x <= l * B && r * B <= y) {
#define F(i) (smax(max, t[o][i].max), smin(min, t[o][i].min), sum += t[o][i].sum)
    APPLY();
#undef F
    // std::cerr << "range-ask: " << l << " " << r << " " << sum - pre << " ";    
    return;
  } 
  pushdown(o);
  int m = l + r >> 1;
  if (y <= m * B) {
    ask(ls, l, m, x, y);
  } else if (x >= m * B) {
    ask(rs, m, r, x, y);
  } else {
    ask(ls, l, m, x, m * B);
    ask(rs, m, r, m * B, y);
  }
}
void update(int o, int l, int r, int x, int y, u32 z, int bitl = 0, int bitr = T - 1) {

  while (bitl <= bitr && t[o][bitl].max <= z) bitl++;
  while (bitl <= bitr && t[o][bitr].max <= z) bitr--;
  if (bitl > bitr) return;
  if (r - l == 1) {
    for (int i = l * B; i < r * B && i < n; i++) {
      a[i] -= tag[o][pos(a[i])];
    }
    memset(tag[o], 0, sizeof tag[o]);
    // std::cerr << "update-single: ";
    for (int i = x; i < y; i++) {
      if (a[i] > z && a[i] < pw[bitr + 1]) {
        // std::cerr << i << " ";
        a[i] -= z;
      }
    }
    // std::cerr << "\n";
    std::fill(t[o], t[o] + T, Null);
    for (int i = l * B; i < r * B && i < n; i++) {
      t[o][pos(a[i])].ins(a[i]);
    } 
    return;
  }
  if (x <= l * B && r * B <= y) {
    for (; bitl <= bitr; bitr--) {
      const int &i = bitr;
      if (t[o][i].min > z && t[o][i].min - z >= pw[i]) {
        add(o, i, z);
        continue;
      }
      break;
    }
    if (bitl > bitr) {
      return;
    }
  }
  
  pushdown(o);
  int m = l + r >> 1;
  if (y <= m * B) {
    update(ls, l, m, x, y, z, bitl, bitr);
  } else if (x >= m * B) {
    update(rs, m, r, x, y, z, bitl, bitr);
  } else {
    update(ls, l, m, x, m * B, z, bitl, bitr);
    update(rs, m, r, m * B, y, z, bitl, bitr);
  }
  pushup(o);

}
void build(int o, int l, int r) {
  if (r - l == 1) {
    std::fill(t[o], t[o] + T, Null);
    int x = l * B, y = std::min(r * B, n);
    for (int i = x; i < y; i++) {
      t[o][pos(a[i])].ins(a[i]);
    }
    return;
  }
  int m = l + r >> 1;
  build(ls, l, m), build(rs, m, r);
  pushup(o);
}
int main() {
  // freopen("tt.in", "r", stdin);
  // freopen("t.out", "w", stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  pw[0] = 1;
  for (int i = 1; i <= T; i++) pw[i] = pw[i - 1] * S;
  cin >> n >> m;
  for (int i = 0; i < n; i++) cin >> a[i];
  k = (n + B - 1) / B;
  std::cerr << "k = " << k << "\n";
  build(1, 0, k);
  int ans = 0;
  while (m--) {
    int opt, l, r;
    cin >> opt >> l >> r;
    l ^= ans, r ^= ans;
    assert(l <= r);
    l--;
    if (opt == 1) {
      u32 x;
      cin >> x;
      x ^= ans;
      update(1, 0, k, l, r, x);
    } else {
      max = 0U, min = ~0U, sum = 0ULL;
      ask(1, 0, k, l, r);
      ans = sum % (1 << 20);
      std::cout << sum << " " << min << " " << max << "\n";
    }
  }
  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P6578">P6578	[Ynoi2019] 魔法少女网站</a>
> 给定序列 $a_n$，$m$ 次操作，单点修改 $a_x = y$，查询区间 $[l, r]$ 有多少子区间的最大值 $\leq x$。
> 
> $n, m \leq 3 \times 10^5, 1 \leq a_i \leq n$。

将操作分块，块大小为 $B$。

对于每个操作块，被修改的位置只有 $O(B)$ 个。没被修改的位置和询问按值从小到大排序，然后插入，用链表维护连续段。

每次询问，枚举前面的修改操作，暴力插入，询问完之后回滚。

由于是区间询问，还要考虑将序列分块，两边的散块暴力，完整的块要维护块内完整连续段的答案之和，以及左右两边不完整连续段的端点。

设 $n, m$ 同阶，取 $B = \sqrt n$，复杂度是 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Wed Jul 14 11:25:19 2021
#include <bits/stdc++.h>
#define dbg(a...) fprintf(stderr, a)
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;
// using std::cin;
template <class T>
struct Rec {
  std::vector<std::pair<T*, T>> rec;
  Rec(int n = 0) {
    rec.reserve(n);
  }
  void clear() { rec.clear(); }
  void operator()(T &x) {
    rec.emplace_back(&x, x);
  }
  void recover() {
    while (!rec.empty()) *rec.back().first = rec.back().second, rec.pop_back();
  }
};
constexpr int N(3e5 + 5), T(1024), S(N / T + 1);
struct Qry {
  int l, r, x, id;
  bool operator<(const Qry &rhs) const {
    return x < rhs.x || x == rhs.x && id < rhs.id;
  }
} q[N];
int n, m, tot;
PII a[N << 1];
int raw[N], val[N], b[N], pos[N], tmp[N];
LL f[N];
LL sum[S], ans[N];
int lp[S], rp[S], cnt[S];
bool vis[N];
struct Info {
  int l, r, x;
} rec[N];
int recs;
void ins(int l, int r, int z) {
  const int bl = l / T, br = r / T;
  if (bl == br) {
    sum[bl] += z * f[r - l + 1];
  } else if (z > 0) {
    rp[bl] = l, lp[br] = r;
  }
}
void add(int x) {
  if (b[x]) return;
  cnt[x / T]++;
  b[x] = 1;
  int l = x, r = x;
  if (x && b[x - 1]) {
    l = pos[x - 1];
    ins(pos[x - 1], x - 1, -1);
  }
  if (x + 1 < n && b[x + 1]) {
    r = pos[x + 1];
    ins(x + 1, pos[x + 1], -1);
  }
  pos[l] = r, pos[r] = l;
  ins(l, r, 1);
}
void add_rec(int x) {
  if (b[x]) return;
  cnt[x / T]++, b[x] = 1;
  int l = x, r = x;
  if (x && b[x - 1]) {
    l = pos[x - 1];
    ins(pos[x - 1], x - 1, -1);
  }
  if (x + 1 < n && b[x + 1]) {
    r = pos[x + 1];
    ins(x + 1, pos[x + 1], -1);
  }
  pos[l] = r, pos[r] = l;
  ins(l, r, 1);
  rec[++recs] = {l, r, x};
}
void recover() {
  // ri.recover(), rl.recover();
  while (recs) {
    auto &[l, r, x] = rec[recs--];
    cnt[x / T]--, b[x] = 0;
    ins(l, r, -1);
    if (l / T != r / T) rp[l / T] = lp[r / T] = -1;
    if (l < x) ins(l, x - 1, 1), pos[l] = x - 1, pos[x - 1] = l;
    if (x < r) ins(x + 1, r, 1), pos[r] = x + 1, pos[x + 1] = r;
  }
}

LL ask(int l, int r) {
  const int bl = l / T, br = r / T;
  LL ans = 0;
  if (bl == br) {
    int now = 0;
    for (int i = l; i <= r; i++) {
      if (b[i]) {
        now++;
      } else {
        ans += f[now];
        now = 0;
      }
    }
    return ans + f[now];
  }
  int y = bl * T + T, x = br * T, now = 0;
  for (int i = l; i < y; i++) {
    if (b[i]) {
      now++;
    } else {
      ans += f[now];
      now = 0;
    }
  }
  for (int i = bl + 1; i < br; i++, y += T) {
    if (T == cnt[i]) {
      now += T;
      continue;
    }
    if (~lp[i]) {
      now += lp[i] - y + 1;
    }
    ans += f[now] + sum[i];
    now = 0;
    if (~rp[i]) {
      now = y + T - rp[i];
    }
  }
  for (int i = x; i <= r; i++) {
    if (b[i]) {
      now++;
    } else {
      ans += f[now];
      now = 0;
    }
  }
  return ans + f[now];
};
int main() {
  f[0] = 0;
  for (int i = 1; i <= 3e5; i++) {
    f[i] = f[i - 1] + i;
  }
  double sta = (double)clock() / CLOCKS_PER_SEC;
#ifndef ONLINE_JUDGE
  freopen("t.in", "r", stdin);
  freopen("tt.out", "w", stdout);
#endif
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin >> n >> m, tot = (n - 1) / T + 1;
  
  for (int i = 0; i < n; i++) {
    cin >> raw[i];
    a[i] = {raw[i], i};
  }
  
  int ta = n, tq = 0;
  for (int i = 0; i < m; i++) {
    int opt;
    cin >> opt >> q[i].l >> q[i].r;
    q[i].l--;
    q[i].id = i;
    if (opt == 2) {
      cin >> q[i].x;
      q[i].r--;
      tq++;
    } else {
      a[ta++] = {q[i].r, q[i].l};
      ans[i] = -1;
    }
  }
  std::sort(a, a + ta);
  for (int i = 0, r, d; i < m; i = r) {
    for (; i < m && !q[i].x; i++) {
      raw[q[i].l] = q[i].r;;
    }
    r = std::min(m, i + 1324);
    // for (int k = step; r < m && k; r++) k -= !q[r].x;
    std::sort(q + i, q + r);
    for (d = i; d < r && !q[d].x; d++) ;
    // assert(d - i <= step);
    for (int j = 0; j < n; j++) {
      pos[j] = -1;
      b[j] = 0;
      vis[j] = 0;
      val[j] = raw[j];
    }
   for (int j = 0; j < tot; j++) {
      sum[j] = 0;
      cnt[j] = 0;
      lp[j] = rp[j] = -1;
    }
    for (int j = i; j < d; j++) {
      vis[q[j].l] = 1;
    }
    tmp[0] = 0;
    for (int j = 0; j < n; j++) if (vis[j]) tmp[++tmp[0]] = j;
    for (int j = d, k = 0; j < r; j++) {
      auto [ql, qr, x, id] = q[j];
      for (; k < ta && a[k].first <= x; k++) {
        if (val[a[k].second] != a[k].first || vis[a[k].second]) continue;
        add(a[k].second);
      }
      for (int t = i; t < d; t++) {
        if (q[t].id > id) continue;
        val[q[t].l] = q[t].r;
      }
      for (int t = 1; t <= tmp[0]; t++) {
        if (val[tmp[t]] <= x) add_rec(tmp[t]);
      }
      ans[id] = ask(ql, qr);
      for (int t = 1; t <= tmp[0]; t++) {
        val[tmp[t]] = raw[tmp[t]];
      }
      recover();
    }
    for (int j = i; j < d; j++) {
      raw[q[j].l] = q[j].r;
    }
  }
  for (int i = 0; i < m; i++) if (~ans[i]) std::cout << ans[i] << "\n";
  std::cerr << "time : " << (double)clock() / CLOCKS_PER_SEC - sta << "\n";
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5072">P5072	[Ynoi2015] 盼君勿忘</a>
> 给定序列 $a_n$，$m$ 次询问给一个区间 $[l_i, r_i]$，对于它的每个子序列 $S$，将 $S$ 去重后求和，答案对 $p_i$ 取模。
> 
> $1 \leq n, m, a_i \leq 10^5, 1 \leq p \leq 10^9$。

莫队。

考虑每个元素对答案的贡献。设元素 $x$ 的出现次数为 $c$，$len = r - l + 1$，那么贡献是 $x(2^c-1)2^{len-c} = x2^{len} - x2^{len - c}$。前者只需要维护不同数的和，后者考虑按照 $c$ 根号分治。

- $c \geq \sqrt n$ 的数，不超过 $\sqrt n$ 个，暴力计算。

- $c < \sqrt n$ 的，每个维护一下 $\sum x$ 即可。

需要 $O(1)$ 计算 $p_i^k$，根号预处理 $p^k, \big(p^{\sqrt n}\big)^k$ 即可。

```cpp
// Author:  HolyK
// Created: Wed Sep  8 16:32:52 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), T(384);
int n, m, a[N];
struct Qry {
  int l, r, p, id;
  bool operator<(const Qry &rhs) const {
    return l / T == rhs.l / T ? l / T & 1 ? r < rhs.r : r > rhs.r : l < rhs.l;
  }
} q[N];

int cnt[N];
LL s, sum[N];
void add(int x) {
  if (!cnt[x]) s += x;
  sum[cnt[x]] -= x;
  sum[++cnt[x]] += x;
}
void del(int x) {
  sum[cnt[x]] -= x;
  sum[--cnt[x]] += x;
  if (!cnt[x]) s -= x;
}
std::vector<int> big;
int ans[N], pw[T], ppw[T];
int main() {
  // freopen("t.in", "r", stdin);
  // freopen(".out", "w", stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
    cnt[a[i]]++;
  }
  for (int i = 1; i <= 1e5; i++) {
    if (cnt[i] >= T) {
      big.push_back(i);
    }
  }
  for (int i = 1; i <= m; i++) {
    std::cin >> q[i].l >> q[i].r >> q[i].p;
    q[i].id = i;
  }
  std::sort(q + 1, q + 1 + m);
  memset(cnt, 0, sizeof cnt);
  for (int i = 1, x = 1, y = 0; i <= m; i++) {
    while (x > q[i].l) add(a[--x]);
    while (y < q[i].r) add(a[++y]);
    while (x < q[i].l) del(a[x++]);
    while (y > q[i].r) del(a[y--]);
    int len = q[i].r - q[i].l + 1;
    // std::cerr << "[Q] " << q[i].l << " " << q[i].r << ":\n";
    pw[0] = 1;
    const int &p = q[i].p;
    for (int i = 1; i < T; i++) pw[i] = 2LL * pw[i - 1] % p;
    ppw[0] = 1;
    ppw[1] = pw[T - 1] * 2LL % p;
    for (int i = 2; i < T; i++) ppw[i] = 1LL * ppw[i - 1] * ppw[1] % p;
    auto power = [&](int k) {
      return 1LL * ppw[k / T] * pw[k % T] % p;
    };
    auto &r = ans[q[i].id];
    // std::cerr << s << "\n";
    r = s % p * power(len) % p;
    for (int x : big) {
      if (cnt[x] >= T) {
        r = (r - 1LL * x * power(len - cnt[x])) % p;
      }
    }
    for (int i = std::min(T - 1, len), c = power(len - i); i; i--, c = 2LL * c % p) {
      if (sum[i]) {
        r = (r - sum[i] % p * c) % p;
      }
    }
    if (r < 0) r += p;
  }
  for (int i = 1; i <= m; i++) {
    std::cout << ans[i] << "\n";
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5397">P5397	[Ynoi2018] 天降之物</a>
> 给定序列 $a_n$，$m$ 次操作：将所有 $x$ 改成 $y$；找出 $(i, j)$ 满足 $a_i = x, a_j = y$，求 $\min |i - j|$。
> 
> 所有数在 $[1, 10^5]$ 范围内，强制在线。

按照出现次数根号分治，大于等于 $\sqrt n$ 的称为大，否则称为小。

如果没有修改，可以预处理大对其他值的答案 $ans$，询问是有大就查表，否则就归并。

考虑修改，首先用并查集维护每个值的位置集合，每次修改值的时候只要合并并查集就行了，这样方便后面快速得到每个位置的值。

小值维护位置集合，小改为小时，如果合起来还是小，直接归并；否则产生了一个大，$O(n)$ 处理它对其他值的答案。

小改为大（大改为小可以交换两个值）时，直接归并复杂度是 $O(n)$，所以要再摊一下。

对于每个大值维护一个附属位置集合作为缓冲，小值位置集合先向大值附属集合归并，如果归并后大小 $\geq \sqrt n$，则直接 $O(n)$ 重构大值。

此时 $ans$ 只维护大值非附属集合对其他值的答案，附属集合由于大小不超过 $\sqrt n$，它产生的贡献在查询时可以直接归并查询。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Thu Sep 16 08:09:38 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), T(512), S(N / T + 1);

template <int S>
struct LazyArray {
  int a[S], b[S], c;
  void clear() { c++; }
  int &operator[](const int &i) {
    if (b[i] != c) b[i] = c, a[i] = 0;
    return a[i];
  } 
};
int n, m, a[N], s[N];

std::vector<int> g[N], h[N];
int id[N], cnt, trash[N], *cur = trash, val[N], ans[S][N];
int newId() {
  return trash == cur ? ++cnt : *cur--;
}
void del(int x) {
  if (!id[x]) return;
  *++cur = id[x];
  memset(ans[id[x]], 0x3f, sizeof ans[id[x]]);
  val[id[x]] = 0;
  id[x] = 0;
}


int cal(const std::vector<int> &a, const std::vector<int> &b) {
  int res = 1e9;
  for (int i = 0, j = 0; i < a.size() || j < b.size(); ) {
    if (j == b.size() || i < a.size() && a[i] < b[j]) {
      if (j) smin(res, a[i] - b[j - 1]);
      i++;
    } else {
      if (i) smin(res, b[j] - a[i - 1]);
      j++;
    }
  }
  return res;
}

int fa[N], root[N];
int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}
void update(int x) {
  int y = id[x];
  for (int i = 1, p = 0; i <= n; i++) {
    a[i] = a[find(i)];
    if (a[i] == x) {
      p = i;
    } else if (p) {
      smin(ans[y][a[i]], i - p);
    }
  }
  for (int i = n, p = 0; i; i--) {
    if (a[i] == x) {
      p = i;
    } else if (p) {
      smin(ans[y][a[i]], p - i);
    }
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m;
  
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
    s[a[i]]++;
  }

  for (int i = 1; i <= 1e5; i++) {
    if (s[i] >= T) {
      id[i] = newId();
      val[id[i]] = i;
    }
  }
  
  for (int i = 1; i <= n; i++) {
    if (s[a[i]] < T) g[a[i]].push_back(i);
    root[a[i]] = i;
  }

  for (int i = 1; i <= n; i++) {
    fa[i] = root[a[i]];
  }
  
  memset(ans, 0x3f, sizeof ans);
  for (int i = 1; i <= cnt; i++) {
    update(val[i]);
  }
  
  int res = 0;
  while (m--) {
    int opt, x, y;
    std::cin >> opt >> x >> y;
    x ^= res, y ^= res;
    static int tmp[N];
    
    auto mergeTo = [&](std::vector<int> &a, std::vector<int> &b) {
      std::merge(a.begin(), a.end(), b.begin(), b.end(), tmp);
      b.resize(a.size() + b.size());
      a.clear();
      std::copy_n(tmp, b.size(), b.begin());
    };
    // std::cerr << x << " " << y << " " << s[x] << " " << s[y] << "\n";
    if (opt == 1) {
      if (x == y || !s[x]) continue;
      if (!root[y]) {
        root[y] = root[x];
        a[root[y]] = y;
      } else {
        fa[root[x]] = root[y];
      }
      root[x] = 0;
      for (int i = 1; i <= cnt; i++) {
        smin(ans[i][y], ans[i][x]);
        ans[i][x] = 0x3f3f3f3f;
      }
      if (s[x] < T && s[y] < T) {
        s[y] += s[x], s[x] = 0;
        if (s[y] >= T) {
          id[y] = newId();
          val[id[y]] = y;
          g[x].clear(), g[y].clear();
          
          update(y);
          
        } else {
          mergeTo(g[x], g[y]);
        }
        continue;
      }
      
      if (s[x] >= T && s[y] < T || s[x] < T && s[y] >= T) {
        if (s[x] > s[y]) {
          std::swap(s[x], s[y]);
          std::swap(id[x], id[y]);
          std::swap(g[x], g[y]);
          std::swap(h[x], h[y]);
          val[id[y]] = y;
        }
        if (h[y].size() + s[x] < T) {
          s[y] += s[x], s[x] = 0;
          mergeTo(g[x], h[y]);
          continue;
        }
      }
      g[x].clear(), g[y].clear();
      h[x].clear(), h[y].clear(); 
      del(x);
      s[y] += s[x], s[x] = 0;
      update(y);
    } else {
      if (!s[x] || !s[y]) {
        res = 0;
        std::cout << "Ikaros\n";
        continue;
      }
      if (x == y) {
        res = 0;
        std::cout << "0\n";
        continue;
      }
      if (s[x] < T && s[y] < T) {
        res = cal(g[x], g[y]);
      } else if (s[x] >= T && s[y] >= T) {
        res = std::min(ans[id[x]][y], ans[id[y]][x]);
        smin(res, cal(h[x], h[y]));
      } else {
        if (s[x] < s[y]) std::swap(x, y);
        res = ans[id[x]][y];
        smin(res, cal(h[x], g[y]));
      }
      std::cout << res << "\n";
    }
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5398">P5398	[Ynoi2018] GOSICK</a>
> 给定序列 $a_n$，$m$ 次询问，给定区间 $[l, r]$，查询二元组 $(i, j)$ 的个数，满足 $i, j \in [l, r], a_i \mid a_j$。
> 
> $1 \leq n, m, a_i \leq 10^5$。

莫队二次离线。

加入或删除一个数，就查询该数在当前区间内的倍数和约数个数，显然可以通过差分搞成两个前缀之差。

发现枚举倍数复杂度炸了，所以把小数的贡献先搞掉。

令 $T = \sqrt n$，计算每个 $x < T$ 对每个询问的贡献。对于每个 $x$，可以通过前缀和 $O(n + m)$ 完成。

然后大数的因数和倍数都是 $\sqrt n$ 级别的了，直接 $\sqrt n$ 修改 $O(1)$ 查询即可。

```cpp
// Author:  HolyK
// Created: Sun May 30 14:48:18 2021
#include <bits/stdc++.h>
#define dbg(a...) fprintf(stderr, a)
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
inline void pc(char c) {
  static std::streambuf *o = std::cout.rdbuf();
  o->sputc(c);
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;
struct Putter {
  template <class T>
  Putter &operator<<(T w) {
    if (w == 0) return pc('0'), *this;
    if (w < 0) pc('-'), w = -w;
    static char s[20], *t;
    for (t = s; w; w /= 10) *++t = w % 10 + '0';
    while (t != s) pc(*t--);
    return *this;
  }
  Putter &operator<<(const char *s) {
    while (*s) pc(*s++);
    return *this;
  }
} cout;


constexpr int T = 1024, N(5e5 + 5);
struct Qry {
  int l, r, id;
  bool operator<(const Qry &rhs) const {
    return l / T == rhs.l / T ? l / T & 1 ? r < rhs.r : r > rhs.r : l < rhs.l;
  }
} q[N];
int a[N], c[N], d[N], t1[N], t2[N];
LL pre[N], pre1[N], ans[N], out[N];
std::array<int, 4> g[N << 1];
std::vector<int> fac[N];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, max = 0;
  cin >> n >> m;
  for (int i = 0; i < n; i++) cin >> a[i], smax(max, a[i]);
  for (int i = 0; i < m; i++) {
    cin >> q[i].l >> q[i].r;
    q[i].l--, q[i].r--;
    q[i].id = i;
  }
  LL min = 1e18, sum = 0;
  int t = 1;
  for (int i = 0; i < n; i++) c[a[i]]++;
  for (int i = max; i; i--) {
    if (smin(min, sum + 1LL * i * n * 3)) t = i;
    sum += (LL)max / i * c[i];
  }
  for (int i = t + 1; i <= max; i++) {
    for (int j = i; j <= max; j += i) {
      fac[j].push_back(i);
    }
  }
  for (int i = 1; i <= t; i++) {
    memset(t1, 0, n << 2);
    memset(t2, 0, n << 2);
    for (int j = 0; j < n; j++) {
      t1[j] = a[j] % i == 0;
      t2[j] = a[j] == i;
    }
    for (int j = 1; j < n; j++) {
      t1[j] += t1[j - 1];
      t2[j] += t2[j - 1];
    }
    for (int j = 0; j < m; j++) {
      auto [l, r, id] = q[j];
      out[id] += 1LL * (t1[r] - (l ? t1[l - 1] : 0) - 1) * (t2[r] - (l ? t2[l - 1] : 0));
    }
  }
  for (int i = 0; i < n; i++) if (a[i] <= t) a[i] = 0;
  auto clr = [&]() {
    memset(c, 0, max + 1 << 2);
  };
  auto add = [&](int x) {
    if (!x) return;
    for (auto i : fac[x]) c[i]++;
    for (int i = x; i <= max; i += x) c[i]++;
  };
  auto ask = [&](int x) {
    return c[x];
  };
  clr();
  for (int i = 0; i < n - 1; i++) {
    add(a[i]);
    pre[i + 1] = ask(a[i]) + pre[i];
    pre1[i + 1] = ask(a[i + 1]) + pre1[i];
  }
  std::sort(q, q + m);
  int x = 1, y = 0, cnt = 0;
  for (int i = 0; i < m; i++) {
    if (x < q[i].l) {
      g[cnt++] = {y, x, q[i].l - 1, -i - 1};
    }
    if (x > q[i].l) {
      g[cnt++] = {y, q[i].l, x - 1, i};
    }
    ans[i] += pre[q[i].l] - pre[x];
    x = q[i].l;
    if (x) {
      if (y < q[i].r) {
	g[cnt++] = {x - 1, y + 1, q[i].r, -i - 1};
      }
      if (y > q[i].r) {
	g[cnt++] = {x - 1, q[i].r + 1, y, i};
      }
    }
    ans[i] += pre1[q[i].r] - pre1[y];
    y = q[i].r;
  }
  std::sort(g, g + cnt);
  clr();
  for (int i = 0, p = 0; i < n && p < cnt; i++) {
    add(a[i]);
    for (; p < cnt && g[p][0] == i; p++) {
      auto [k, l, r, id] = g[p];
      LL t = 0;
      for (int j = l; j <= r; j++) t += ask(a[j]);
      if (id < 0) {
	ans[-id - 1] -= t;
      } else {
	ans[id] += t;
      }
    }
  }
  for (int i = 1; i < m; i++) ans[i] += ans[i - 1];
  for (int i = 0; i < m; i++) out[q[i].id] += ans[i] + q[i].r - q[i].l + 1;
  for (int i = 0; i < m; i++) std::cout << out[i] << "\n";
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5399">P5399	[Ynoi2018] 駄作</a>
> 给定 $n$ 个节点的树，边权为 1。$m$ 次询问，给定 $p_0, d_0, p_1, d_1$，计算
> $$
> \sum_{d(p_0, a) \leq d_0}\sum_{d(p_1, b) \leq d_1} d(a, b)
> $$
> 
> $1 \leq n, m \leq 10^5$

Top cluster 树分块。

这个题前前后后写了几天，还是常数太大过不了。

每个邻域可以被分成每个块的邻域，只有 $p_0, p_1$ 所在块的起点不是界点，其余都是。

不同块邻域之间的贡献，可以在收缩树上DP，这里需要预处理每个块以界点为起点的邻域的各种信息。

相同块邻域之间的贡献，如果起点不是界点，这样的情况只有 $O(m)$ 次，在块内 DP，复杂度 $O(m \sqrt n)$。

如果起点是界点，将询问离线，对于每个块，处理以界点为起点的邻域之间的答案。可以转换为求 $\sum d(LCA)$，然后搞 $O(B)$ 修改，$O(1)$ 查询。

我的实现用到了预处理块与块的距离，点到界点的距离，块内 $O(1)$ rmq lca 的方式来搞，常数太大了。

**怎么卡常**：通过阅读其他人的代码，可以发现，对于每一块，按照bfs序重新标号，这样每次寻找邻域时用bfs就比较 cache 友好，然后对于收缩树，我的代码中是直接以界点构成的树来DP的，但是好像别人是用块构成的树来DP的，所以我还要处理 rake 块的小情况，十分麻烦。

```cpp
// Author:  HolyK
// Created: Mon Mar 28 17:33:17 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair<int, int>;

std::mt19937_64 rng((std::random_device())());
LL rnd(LL l, LL r) {
  if (l > r) std::swap(l, r);
  return std::uniform_int_distribution<LL>(l, r)(rng);
}

constexpr int N(1e5 + 5), T(666), K(N / T + 5), S(N / T * 6 + 5);
std::vector<int> g[N];
int n, m, root, fa[N], dep[N], siz[N], bot[N];

std::vector<int> g1[N], pt[N];
int key[N], keys[N], fa1[N];
int gl[N], gr[N], bel[N], tot, end[N][2];
int in[N], st[10][N], lg[N];

void dfs(int x) {
  int cnt = 0;
  
  static int s[N], t; 
  for (int y : g[x]) {
    fa[y] = x;
    g[y].erase(std::find(g[y].begin(), g[y].end(), x));
    s[t++] = y;
    dep[y] = dep[x] + 1;
    dfs(y);
    siz[x] += siz[y];
    if (bot[y]) {
      bot[x] = bot[y];
      cnt++;
    }
  }

  if (x == root || siz[x] + 1 >= T || cnt > 1) {
    key[x] = ++keys[0];
    keys[keys[0]] = x;
    bot[x] = x;
    siz[x] = 0;

    int r = g[x].size(), c = 0, now = 0;
    for (int i = g[x].size() - 1; i >= 0; i--) {
      int y = g[x][i];
      if (c && bot[y] || now + siz[y] >= T) {
        int tt = t;
        do {
          bel[s[--t]] = tot;
          in[s[t]] = in[0]--;
        } while (s[t] != g[x][i + 1]);
        pt[tot].assign(s + t, s + tt);
        gl[tot] = i + 1, gr[tot] = r;
        r = i + 1;
        end[tot][0] = x;
        end[tot][1] = c;
        tot++;

        now = c = 0;
      }

      now += siz[y];
      if (bot[y]) {
        c = y = bot[y];
        g1[x].push_back(y);
        g1[y].push_back(x);
        fa1[y] = x;
      }
    }

    int tt = t;
    do {
      bel[s[--t]] = tot;
      in[s[t]] = in[0]--;
      
    } while (s[t] != g[x][0]);
    pt[tot].assign(s + t, s + tt);
    gl[tot] = 0, gr[tot] = r;
    end[tot][0] = x;
    end[tot][1] = c;
    tot++;
  }

  siz[x]++;
}

int get(int x, int y) {
  return in[x] < in[y] ? x : y;
}
int lca(int x, int y) {
  if (x == y) return x;
  x = in[x], y = in[y];
  if (x > y) std::swap(x, y);
  int k = lg[y - x];
  return get(st[k][x], st[k][y - (1 << k)]);
}
int dis(int x, int y) {
  return dep[x] + dep[y] - dep[lca(x, y)] * 2;
}
void initLCA() {
  for (int i = 1; i <= n; i++) {
    st[0][in[i] - 1] = fa[i];
  }
  
  for (int i = 2; i <= n; i++) {
    lg[i] = lg[i >> 1] + 1;
  }
  for (int i = 1; i < 10; i++) {
    for (int j = 1; j + (1 << i) - 1 <= n; j++) {
      st[i][j] = get(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
    }
  }
}

int vis[N], cnt[S][T][2], d2k[N][2], dk[K][K];
LL sum[S][T][2][2];

std::vector<PII> pts[S][2];
void init() {
  static PII q[N];
  int l, r;
  for (int i = 1; i <= n; i++) {
    if (!key[i]) continue;
    int o = key[i];
    q[l = r = 1] = {i, 0};
    vis[i] = ++vis[0];    
    while (l <= r) {
      auto [x, z] = q[l++];
      dk[o][key[x]] = z;
      for (int y : g1[x]) {
        if (vis[y] == vis[0]) continue;
        vis[y] = vis[0];
        q[++r] = {y, z + std::abs(dep[x] - dep[y])};
      }
    }
  }

  for (int i = 0; i < tot; i++) {
    int p = end[i][0], p1 = end[i][1];
    static int c[2][T];
    memset(c, 0, sizeof c);
    for (int x : pt[i]) {
      int dx = d2k[x][0] = dep[x] - dep[p];
      c[0][d2k[x][0]]++;
      cnt[i][dx][0]++;
      sum[i][dx][0][0] += dx;
      if (p1) {
        int dy = d2k[x][1] = dis(x, p1);
        c[1][d2k[x][1]]++;
        cnt[i][dy][1]++;
        sum[i][dx][0][1] += dy;
        sum[i][dy][1][0] += dx;
        sum[i][dy][1][1] += dy;
      }
    }
    
    pts[i][0].resize(pt[i].size());
    if (p1) pts[i][1].resize(pt[i].size());
    for (int j = 1; j < T; j++) c[0][j] += c[0][j - 1], c[1][j] += c[1][j - 1];
    for (int u = pt[i].size() - 1; u >= 0; u--){
      int x = pt[i][u];
      pts[i][0][--c[0][d2k[x][0]]] = {x, d2k[x][0]};
      if (p1) pts[i][1][--c[1][d2k[x][1]]] = {x, d2k[x][1]};
    }

    for (int j = 1; j < T; j++) {
      for (int k : {0, 1}) {
        cnt[i][j][k] += cnt[i][j - 1][k];
        sum[i][j][k][0] += sum[i][j - 1][k][0];
        sum[i][j][k][1] += sum[i][j - 1][k][1];        
      }
    }
  }
}

std::array<int, 4> qry[N];


struct Info {
  int c;
  LL s[2];
  void clear() {
    c = 0;
    s[0] = s[1] = 0;
  }
} rake[N][2], comp[N][2];

LL ans[N];
void dp(int x, int id) {
  ans[id] += rake[x][0].c * rake[x][1].s[0] + rake[x][1].c * rake[x][0].s[0];
  
  for (int y : g1[x]) {
    if (y == fa1[x]) continue;
    dp(y, id);

    // compress
    for (int i = 0; i < 2; i++) {
      ans[id] += rake[y][i].c * comp[y][!i].s[1] + rake[y][i].s[0] * comp[y][!i].c;
    } 
    for (int i = 0; i < 2; i++) {
      comp[y][i].c += rake[y][i].c;
      comp[y][i].s[0] += 1LL * rake[y][i].c * (dep[y] - dep[x]) + rake[y][i].s[0];
    }
    
    // rake
    for (int i = 0; i < 2; i++) {
      ans[id] += rake[x][i].c * comp[y][!i].s[0] + rake[x][i].s[0] * comp[y][!i].c;

    } 
    for (int i = 0; i < 2; i++) {
      rake[x][i].c += comp[y][i].c;
      rake[x][i].s[0] += comp[y][i].s[0];
    }
  }
}

void split(int x, int d, int k) {
  if (x == root) {
    rake[root][k].c++;
    for (int i = 0; i < tot; i++) {
      auto &f = end[i][1] ? comp[end[i][1]][k] : rake[end[i][0]][k];
      
      int q = dep[end[i][0]];
      if (q > d) continue;
      q = std::min(T - 1, d - q);
      f.c += cnt[i][q][0];
      f.s[0] += sum[i][q][0][0];
      f.s[1] += sum[i][q][0][1];
    }
    return;
  }
  
  int o = bel[x], ou = key[end[o][0]], od = key[end[o][1]];
  if (dep[x] <= d) rake[root][k].c++;
  for (int i = 0; i < tot; i++) {
    auto &f = end[i][1] ? comp[end[i][1]][k] : rake[end[i][0]][k];
    if (i == o) {
      if (key[x] || d >= T - 1) {
        int r = key[x] ? 1 : 0, q = std::min(d, T - 1);
        f.c += cnt[i][q][r];
        f.s[0] += sum[i][q][r][0];
        f.s[1] += sum[i][q][r][1];
      } else {
        for (auto v : pt[i]) {
          if (dis(x, v) > d) continue;
          f.c++;
          f.s[0] += d2k[v][0];
          f.s[1] += d2k[v][1];
        }
      }
      continue;
    }

    int iu = key[end[i][0]], id = key[end[i][1]];
    int r = 0, q = dk[ou][iu] + d2k[x][0];
    if (od) smin(q, dk[od][iu] + d2k[x][1]);
    if (id) {
      int qq = dk[ou][id] + d2k[x][0];
      if (od) smin(qq, dk[od][id] + d2k[x][1]);
      if (smin(q, qq)) r = 1;
    }

    if (q > d) continue;
    q = std::min(T - 1, d - q);

    f.c += cnt[i][q][r];
    f.s[0] += sum[i][q][r][0];
    f.s[1] += sum[i][q][r][1];
  }
}


LL val[N], s[N], ss, cc;

void getS(int x) {
  if (key[x]) return;
  for (int y : g[x]) {
    if (y == fa[x]) continue;
    s[y] = s[x] + val[y];
    getS(y);
  }
}
void update(int x, int y) {
  while (!key[fa[x]]) {
    val[x] += y;
    x = fa[x];
  }
  s[x] = val[x] += y;
  getS(x);  
  // std::cerr << "update " << x << "\n";
}

struct Node {
  int d, id;
  PII a2;
};

void cal(int o) {
  int p = end[o][0], p1 = end[o][1], ou = key[p], od = key[p1];

  int coef = p1 ? 1 : 0;

  std::vector<Node> b[2];
  for (int i = 1; i <= m; i++) {
    PII a[2];
    for (int k : {0, 1}) {
      int x = qry[i][k * 2], d = qry[i][k * 2 + 1];
      if (x == root) {
        if (d <= dep[p]) goto ed;
        a[k] = {0, d - dep[p]};
      } else if (bel[x] == o) {
        if (d >= T - 1 || key[x]) {
          a[k] = {key[x] ? 1 : 0, d};
        } else {
          a[k] = {-x, d};
        }
      } else {
        int r = 0, i = bel[x], iu = key[end[i][0]], id = key[end[i][1]], q = dk[ou][iu] + d2k[x][0];
        if (id) smin(q, dk[ou][id] + d2k[x][1]);
        if (od) {
          int qq = dk[od][iu] + d2k[x][0];
          if (id) smin(qq, dk[od][id] + d2k[x][1]);
          if (smin(q, qq)) r = 1;
        }
        if (q > d || q == d && !r) goto ed;
        a[k] = {r, d - q};
      }

      if (a[k].first >= 0) {
        smin(a[k].second, pts[o][a[k].first].back().second);
      }
    }
    
    if (a[0].first < 0) {
      std::swap(a[0], a[1]);
    }
    
    if (a[0].first < 0) {
      // std::cerr << "AA\n";
      int x1 = -a[0].first, d1 = a[0].second, x2 = -a[1].first, d2 = a[1].second;
      static int c[N][2];

      c[p][0] = c[p][1] = 0;
      for (int x : pt[o]) {
        c[x][0] = dis(x, x1) <= d1;
        c[x][1] = dis(x, x2) <= d2;
      }
      if (p1) {
        static LL s[N][2];
        s[p][0] = s[p][1] = 0;
        for (int x : pt[o]) s[x][0] = s[x][1] = 0;
        for (int j = pts[o][0].size() - 1; j >= 0; j--) {
          int x = pts[o][0][j].first, y = fa[x];
          s[x][0] += c[x][0], s[x][1] += c[x][1];
          ans[i] += c[x][0] * s[y][1] + s[x][0] * c[y][1] +
                    c[x][1] * s[y][0] + s[x][1] * c[y][0];

          c[y][0] += c[x][0], c[y][1] += c[x][1];
          s[y][0] += s[x][0], s[y][1] += s[x][1];
        }
      } else {
        for (int j = pts[o][0].size() - 1; j >= 0; j--) {
          int x = pts[o][0][j].first, y = fa[x];
          ans[i] -= 2LL * c[x][0] * c[x][1];
          c[y][0] += c[x][0], c[y][1] += c[x][1];
        }
      }
      
    } else {
      b[a[0].first].push_back({a[0].second, i, a[1]});
    }
    
    ed:;
  }

  for (int z : {0, 1}) {
    if (b[z].empty()) continue;
    int m = 0;
    for (auto &v : b[z]) smax(m, v.d);
    std::vector<int> c(m + 1);
    for (auto &v : b[z]) c[v.d]++;
    for (int i = 1; i <= m; i++) c[i] += c[i - 1];
    std::vector<Node> bb(b[z].size());
    for (auto &v : b[z]) bb[--c[v.d]] = v;

    for (int i = 0, j, k = 0; i < bb.size(); i = j) {
      int d = bb[i].d, m[2] = {};
      static LL sum[2][T];

      for (j = i; j < bb.size() && d == bb[j].d; j++) {
        if (bb[j].a2.first >= 0) smax(m[bb[j].a2.first], bb[j].a2.second);
      }
      while (k < pts[o][z].size() && pts[o][z][k].second <= d) {
        int x = pts[o][z][k++].first;
        update(x, 1);
        ss += d2k[x][0];
        cc += 1;
      }
      for (int i = 0; i <= m[0]; i++) sum[0][i] = 0;
      for (int i = 0; i <= m[1]; i++) sum[1][i] = 0;
      for (auto [x, d] : pts[o][0]) {
        if (d > m[0]) break;
        sum[0][d] += coef * (ss + 1LL * cc * d) - s[x] * 2;
      }
      for (int i = 1; i <= m[0]; i++) sum[0][i] += sum[0][i - 1];
      for (auto [x, d] : pts[o][1]) {
        if (d > m[1]) break;
        sum[1][d] += coef * (ss + 1LL * cc * d2k[x][0]) - s[x] * 2;
      }
      for (int i = 1; i <= m[1]; i++) sum[1][i] += sum[1][i - 1];

      for (int k = i; k < j; k++) {
        auto [x, d] = bb[k].a2;
        if (x >= 0) {
          // assert(d <= m[x]);
          ans[bb[k].id] += sum[x][d];
        } else {
          for (int v : pt[o]) {
            if (dis(v, -x) <= d) {
              ans[bb[k].id] += coef * (ss + 1LL * cc * d2k[v][0]) - s[v] * 2;
            }
          }
        }
      }
    }
    for (int x : pt[o]) s[x] = val[x] = 0, ss = cc = 0;
  }
}

void solve() {
  cin >> n;
  for (int i = 2, x; i <= n; i++) {
    cin >> x;
    g[x].push_back(i);
    g[i].push_back(x);
  }

  root = rnd(1, n);
  bel[root] = -1;
  in[0] = n, in[root] = 1;
  dfs(root);

  // for (int i = 1; i <= n; i++) {
  //   std::cerr << i << " " << bel[i] << "\n";
  // }
  initLCA();

  // std::cerr << "??\n";
  
  for (int i = 1; i <= n; i++) {
    if (i != root)
      g[i].push_back(fa[i]);
  }

  init();

  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
  cin >> m;
  for (int i = 1; i <= m; i++) {
    int x1, d1, x2, d2;
    cin >> x1 >> d1 >> x2 >> d2;
    qry[i] = {x1, d1, x2, d2};
    for (int j = 1; j <= keys[0]; j++) {
      int x = keys[j];
      rake[x][0].clear();
      rake[x][1].clear();
      comp[x][0].clear();
      comp[x][1].clear();
    }

    split(x1, d1, 0), split(x2, d2, 1);
    dp(root, i);
  }

  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
  for (int i = 0; i < tot; i++) {
    cal(i);
  }
  
  for (int i = 1; i <= m; i++) {
    std::cout << ans[i] << "\n";
  }
  
  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
}
int main() {
  // freopen("t.in", "r", stdin);
  // freopen("t1.out", "w", stdout);

  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P4119">P4119	[Ynoi2018] 未来日记</a>
> 给定序列 $a_n$，$m$ 次操作，区间 $[l, r]$ 所有 $x$ 改成 $y$；查区间 $[l, r]$ 的第 $k$ 小值。
> 
> $1 \leq n, m, a_i \leq 10^5$

序列分块+值域分块。

每个值、每个值域块维护序列块中出现次数的前缀和。

用并查集维护每个序列快中每个值的位置集合。

修改时重新计算对应的 $O(1)$ 个值和值域块的前缀和。

查询时两边散块重新统计值和值域块的出现次数，中间整块直接查表。

然后先确定答案所在的值域块，再确定具体的值。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Fri Sep 17 08:24:37 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), T(512), S(N / T + 1);
int n, m, tot, a[N], fa[N], rt[S][N];
int b[N][S], c[S][S]; // Inter-block(single, block) prefix

int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}

int main() {
  // freopen("t.in", "r", stdin);
  // freopen("t.out", "w", stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin >> n >> m;
  tot = (n - 1 + T) / T;
  
  memset(rt, -1, sizeof rt);
  int max = 0;
  for (int i = 0; i < n; i++) {
    std::cin >> a[i];
    rt[i / T][a[i]] = i;
    b[a[i]][i / T]++;
    c[a[i] / T][i / T]++;
    smax(max, a[i]);
  }
  for (int i = 1; i <= max; i++) {
    for (int j = 1; j < tot; j++) {
      b[i][j] += b[i][j - 1];
    }
  }
  for (int i = 0; i <= max / T; i++) {
    for (int j = 1; j < tot; j++) {
      c[i][j] += c[i][j - 1];
    }
  }
  for (int i = 0; i < n; i++) {
    fa[i] = rt[i / T][a[i]];
  }

  while (m--) {
    int opt, l, r, x, y;
    std::cin >> opt >> l >> r >> x;
    l--;
    
    if (opt == 1) {
      std::cin >> y;
      if (x == y) continue;
      static int tmp[S];
      for (int o = l / T, i = o * T, j; i < r; o++, i += T) {
        j = std::min(n, T + i);  
        int &u = rt[o][x], &v = rt[o][y];
        if (u == -1) continue;
        if (i < l || r < j) {
          for (int k = i; k < j; k++) {
            a[k] = a[find(k)];
          }
          u = v = -1;

          for (int k = std::max(l, i); k < j && k < r; k++) {
            if (a[k] == x) a[k] = y, tmp[o]++;
          }
          for (int k = i; k < j; k++) {
            if (a[k] == x) {
              u = k;
            } else if (a[k] == y) {
              v = k;
            }
          }

          for (int k = i; k < j; k++) {
            fa[k] = rt[o][a[k]];
          }
          
        } else {
          tmp[o] = b[x][o] - (o ? b[x][o - 1] : 0);
          if (~v) {
            fa[u] = v;
          } else {
            a[v = u] = y;
          }
          u = -1;
        }        
      }

      for (int i = l / T; i < tot; i++) {
        if (i) tmp[i] += tmp[i - 1];
        b[x][i] -= tmp[i];
        b[y][i] += tmp[i];
        c[x / T][i] -= tmp[i];
        c[y / T][i] += tmp[i];
      }
      for (int i = l / T; i < tot; i++) {
        tmp[i] = 0;
      }
    } else {
      static int tmp[N], blo[S];
      if (r - l <= T * 2) {
        for (int i = l; i < r; i++) tmp[i] = a[find(i)];
        // for (int i = l; i < r; i++) std::cerr << tmp[i] << " \n"[i + 1 == r];
        std::nth_element(tmp + l, tmp + l + x - 1, tmp + r);
        std::cout << tmp[l + x - 1] << "\n";
        for (int i = l; i < r; i++) tmp[i] = 0;
        continue;
      }
      r--;
      int bl = l / T, br = r / T;
      assert(bl + 1 < br);
      
      for (int i = l; i < bl * T + T; i++) {
        a[i] = a[find(i)];
        tmp[a[i]]++;
        blo[a[i] / T]++;
      }
      for (int i = br * T; i <= r; i++) {
        a[i] = a[find(i)];
        tmp[a[i]]++;
        blo[a[i] / T]++;
      }
      int d = 0;
      auto calSig = [&](int i) {
        return tmp[i] + b[i][br - 1] - b[i][bl];
      };
      auto calBlo = [&](int i) {
        return blo[i] + c[i][br - 1] - c[i][bl];
      };
      int z;
      while (x > (z = calBlo(d))) {
        x -= z, d++;
      }
      d *= T;
      while (x > (z = calSig(d))) {
        x -= z, d++;
      }
      std::cout << d << "\n";

      for (int i = l; i < bl * T + T; i++) {
        tmp[a[i]] = 0;
        blo[a[i] / T] = 0;
      }
      for (int i = br * T; i <= r; i++) {
        tmp[a[i]] = 0;
        blo[a[i] / T] = 0;
      }
    }
  }
  return 0;
}
```


## <a href = "https://www.luogu.com.cn/problem/P4117">P4117	[Ynoi2018] 五彩斑斓的世界</a>
> 给定序列 $a_n$，$m$ 次操作，区间大于 $x$ 的减 $x$；区间查询 $x$ 的出现次数。
> 
> $1 \leq n \leq 10^6, 1 \leq m \leq 5 \times 10^5, 0 \leq a, x \leq 10^5 + 1$。
> 
> 空间限制 64MB。

序列分块，每个块对答案的贡献是独立的，所以可以考虑将询问离线，每个块单独处理贡献，这样空间就比较小。

用并查集维护每个值出现的位置集合，然后考虑当前块的最大值 $max$，

如果 $x > max / 2$，那么操作之后最大值会变成 $< x$，如果 $x \leq max / 2$，那么操作之后最大值会减少 $x$。

即操作一次，最大值至少会减少 $\min\{max - x, x\}$。

- 如果 $\min\{max-x, x\} \leq \sqrt m$，我们用 $O(\min\{max-x, x\})$ 的时间来搞这个操作就行。
   - 如果 $max - x < x$，那么直接枚举 $x + 1\cdots max$ 并查集合并就行。
   - 如果 $max - x > x$，可以先把 $1 \cdots x$ 这些数加 $x$，然后再整体打标记减 $x$。
   
   这样上面的操作不会超过 $m$ 次，复杂度 $O(m\sqrt n)$。
- 如果 $\min\{max-x, x\} > \sqrt m$，那么最多 $\sqrt m$ 次就会把最大值减到 1，所以每次暴力减就行，复杂度 $O(n\sqrt m)$。

总复杂度 $O(n\sqrt m + m\sqrt n)$。

```cpp
// Author:  HolyK
// Created: Fri Sep 10 15:54:37 2021
#include <bits/stdc++.h>
template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(1e6 + 5), T(888), M(2e5 + 5);
struct Option {
  int opt, l, r, x;
} q[N];

int n, m, a[N], ans[N];
int pos[M];
int fa[T], siz[T];
int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}
int main() {
  // freopen("t.in", "r", stdin);
  // freopen("t.out", "w", stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin >> n >> m;
  for (int i = 0; i < n; i++) cin >> a[i];
  for (int i = 1; i <= m; i++) {
    cin >> q[i].opt >> q[i].l >> q[i].r >> q[i].x;
    q[i].l--;
  }
  memset(pos, -1, sizeof pos);
  for (int x = 0; x < n; x += T) {
    int y = std::min(n, x + T), max, tag;
    
    auto build = [&] {
      max = tag = 0;
      memset(siz, 0, sizeof siz);
      for (int i = x; i < y; i++) {
        smax(max, a[i]);
        pos[a[i]] = i - x;
      }
      for (int i = x; i < y; i++) {
        fa[i - x] = pos[a[i]];
        siz[fa[i - x]]++;
      }
    };
    build();
    for (int i = 1; i <= m; i++) {
      if (q[i].l >= y || q[i].r <= x) continue;
      if (q[i].l <= x && y <= q[i].r) {
        if (q[i].opt == 2) {
          if (~pos[q[i].x + tag]) {
            ans[i] += siz[pos[q[i].x + tag]];
          }
          continue;
        }
        if (max <= q[i].x || !q[i].x) continue;
        if (std::min(max - q[i].x, q[i].x) <= T) {
          if (max <= q[i].x * 2) {
            for (int j = q[i].x + 1 + tag; j <= max + tag; j++) {
              if (pos[j] == -1) continue;
              int &u = pos[j], &v = pos[j - q[i].x];
              if (v == -1) {
                v = u, a[x + u] -= q[i].x;
              } else {
                fa[u] = v;
                siz[v] += siz[u];
                siz[u] = 0;
              }
              u = -1;
            }
            max = q[i].x;
          } else {
            for (int j = q[i].x + tag; j >= tag; j--) {
              if (pos[j] == -1) continue;
              int &u = pos[j], &v = pos[j + q[i].x];
              if (v == -1) {
                v = u, a[x + u] += q[i].x;
              } else {
                fa[u] = v;
                siz[v] += siz[u];
                siz[u] = 0;
              }
              u = -1;
            }
            tag += q[i].x;
            max -= q[i].x;
          }
          continue;
        }
      }
      if (q[i].opt == 1 && max <= q[i].x) continue;
      if (q[i].opt == 2 && pos[q[i].x + tag] == -1) continue;
      for (int j = x; j < y; j++) {
        a[j] = a[x + find(j - x)];
      }
      for (int j = x; j < y; j++) {
        pos[a[j]] = -1;
        a[j] -= tag;
      }
      int l = std::max(q[i].l, x), r = std::min(q[i].r, y);
      
      if (q[i].opt == 1) {   
        for (int j = l; j < r; j++) {
          if (a[j] > q[i].x) a[j] -= q[i].x;
        }
      } else {
        for (int j = l; j < r; j++) {
          if (a[j] == q[i].x) ans[i]++;
        }
      }
      build();
    }
    for (int i = x; i < y; i++) {
      if (fa[i - x] == i - x) pos[a[i]] = -1;
    }
  }
  for (int i = 1; i <= m; i++) {
    if (q[i].opt == 2) {
      std::cout << ans[i] << "\n";
    }
  }
  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
  return 0;
}
```


## <a href = "https://www.luogu.com.cn/problem/P4689">P4689	[Ynoi2016] 这是我自己的发明</a>
> $n$ 个点的树，有点权，初始根是 1，$m$ 次操作，换根为 $x$；给两个点 $x, y$，求从 $x$ 子树内和 $y$ 子树中分别选一个点，求两个点点权相等的情况数。
> 
> $1 \leq n \leq 10^5, 1 \leq m \leq 5\times 10^5, 1 \leq a_i \leq 10^9$



## <a href = "https://www.luogu.com.cn/problem/P7897">P7897	[Ynoi2006] spxmcq</a>


## <a href = "https://www.luogu.com.cn/problem/P8204">P8204	[Ynoi2005] tdnmo</a>

## <a href = "https://www.luogu.com.cn/problem/P5068">P5068	[Ynoi2015] 我回来了</a>

## <a href = "https://www.luogu.com.cn/problem/P4688">P4688	[Ynoi2016] 掉进兔子洞</a>

## <a href = "https://www.luogu.com.cn/problem/P5355">P5355	[Ynoi2017] 由乃的玉米田</a>

## <a href = "https://www.luogu.com.cn/problem/P5607">P5607	[Ynoi2013] 无力回天 NOI2017</a>

## <a href = "https://www.luogu.com.cn/problem/P5356">P5356	[Ynoi2017] 由乃打扑克</a>

## <a href = "https://www.luogu.com.cn/problem/P5309">P5309	[Ynoi2011] 初始化</a>

## <a href = "https://www.luogu.com.cn/problem/P5071">P5071	[Ynoi2015] 此时此刻的光辉</a>

## <a href = "https://www.luogu.com.cn/problem/P5610">P5610	[Ynoi2013] 大学</a>

## <a href = "https://www.luogu.com.cn/problem/P8205">P8205 [Ynoi2005] vti</a>
> $n$ 个点的有根树，有边权，$m$ 次询问，每次给出 $t_i$ 个点，求它们的虚树包含的边的祖孙顺序对。
> 
> $1 \leq n \leq 10^5, 1 \leq m \leq 10^6, \sum t_i \leq 10^6$.

可以通过一些简单计算，将问题转换为 $O(\sum t_i)$ 次祖孙链查询。

树分块之后，因为都是祖孙链查询，考虑二次离线莫队。

左端点在同一块的，按照右端点dfs序排序，然后和普通莫队差不多。

需要讨论左右端点是否在同一块里面，两个需要分开计算。

二次离线莫队最后要根据前缀和计算答案，因为最后忘记区分这俩，调了一会。

需要求树上前缀的答案，这个用树状数组就行。

还要 $O(1)$ 查询某个前缀比某个点小的数的个数，经典问题，搞一个 $O(\sqrt n)$ 修改，$O(1)$ 查询的数据结构。

```cpp
// Author:  HolyK
// Created: Sat Apr  2 20:50:00 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), M(1e6 + 5);
int n, m;
std::vector<int> g[N];

int a[N], fa[N], in[N], out[N], dep[N], dfn;
namespace RMQLCA {
int st[17][N], lg[N];
int get(int x, int y) {
  return in[x] < in[y] ? x : y;
}

void init() {
  for (int i = 1; i <= n; i++) st[0][in[i] - 1] = fa[i];
  for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;
  for (int i = 1; i < 17; i++) {
    for (int j = 1; j + (1 << i) - 1 <= n; j++) {
      st[i][j] = get(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
    }
  }
}

int lca(int x, int y) {
  if (x == y) return x;
  x = in[x], y = in[y];
  if (x > y) std::swap(x, y);
  int k = lg[y - x];
  return get(st[k][x], st[k][y - (1 << k)]);
}
}

using RMQLCA::lca;

LL pre1[N], pre2[N];
int c[N];
void dfs(int x) {

  in[x] = ++dfn;
  for (int p = a[x]; p <= n; p += p & -p) c[p]++;
  for (int p = a[x] - 1; p; p -= p & -p) pre1[x] += c[p];
  pre2[x] += dep[x];
  for (int p = a[x]; p; p -= p & -p) pre2[x] -= c[p];

  for (int y : g[x]) {
    pre1[y] = pre1[x];
    pre2[y] = pre2[x];
    dep[y] = dep[x] + 1;
    dfs(y);
  }

  out[x] = dfn;
  for (int p = a[x]; p <= n; p += p & -p) c[p]--;
}


int siz[N], bot[N], bel[N], tot;
bool key[N];

struct Qry {
  int l, r, k, id;
  bool operator<(const Qry &rhs) const {
    return bel[l] == bel[rhs.l] ? in[r] < in[rhs.r] : bel[l] < bel[rhs.l];
  }
} q[M * 2];
int qcnt, B;
LL ans[M * 2], oans[M];

struct Block {
  int top, bot;
} b[N];

void build(int x) {
  static int q[N], r;
  auto add = [&](int d) {
    int o = tot++;
    b[o] = {x, d};
    for (int i = 1; i <= r; i++) {
      int u = q[i];
      bel[u] = o;
      if (key[u]) continue;
      for (int v : g[u]) q[++r] = v;
    }
  };

  int s = 0, c = 0;
  for (int y : g[x]) {
    build(y);
    s += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }

  if (1 + s >= B || c > 1 || !x) {
    std::sort(g[x].begin(), g[x].end(), [](int i, int j) {
      return siz[i] < siz[j];
    });

    siz[x] = 1;
    bot[x] = x;
    key[x] = true;
    s = c = r = 0;

    for (int y : g[x]) {
      if (c && bot[y] || siz[y] + s >= B) {
        add(c);
        s = c = r = 0;
      }

      c |= bot[y];
      s += siz[y];
      q[++r] = y;
    }

    add(c);
  } else {
    siz[x] = 1 + s;
  }
}

std::vector<Qry> q0[N], q1[N], q2[N];

constexpr int T(256);
struct SumDS {
  int tot, s0[N], s1[N / T + 1];
  void add(int p, int x) {
    int k = p / T + 1, r = std::min(k * T, n + 1);
    while (p < r) s0[p++] += x;
    while (k < tot) s1[k++] += x;
  }
  int ask(int p) {
    return s0[p] + s1[p / T];
  }
} sumDS;

void dfsq(int x) {

  sumDS.add(a[x], 1);
  for (auto &[l, r, k, id] : q0[x]) {
    LL s = 0;
    while (r != l) s += sumDS.ask(a[r] - 1), r = fa[r];
    oans[id] += s * k;
  }
  for (auto &[l, r, k, id] : q1[x]) {
    LL s = 0;
    while (r != l) s += sumDS.ask(a[r] - 1), r = fa[r];
    ans[id] += s * k;
  }
  for (auto &[l, r, k, id] : q2[x]) {
    LL s = 0;
    while (r != l) s += dep[x] - sumDS.ask(a[r]), r = fa[r];
    ans[id] += s * k;
  }
  
  for (int y : g[x]) {
    dfsq(y);
  }
  sumDS.add(a[x], -1);
}

void solve() {
  std::cin >> n;
  a[1] = n;
  for (int i = 2; i <= n; i++) {
    std::cin >> fa[i] >> a[i];
    g[fa[i]].push_back(i);
  }

  dep[1] = 1;
  dfs(1);
  
  RMQLCA::init();
  
  std::cin >> m;
  for (int i = 1; i <= m; i++) {
    int t;
    std::cin >> t;
    std::vector<int> p(t);
    for (int j = 0; j < t; j++) std::cin >> p[j];
    std::sort(p.begin(), p.end(), [](int i, int j) {
      return in[i] < in[j];
    });
    for (int j = 0; j + 1 < t; j++) {
      p.push_back(lca(p[j], p[j + 1]));
    }

    std::sort(p.begin(), p.end(), [](int i, int j) {
      return in[i] < in[j];
    });
    p.erase(std::unique(p.begin(), p.end()), p.end());

    t = p.size();
    std::vector<int> s = {0}, c(t);
    for (int j = 1, x, u; j < t; j++) {
      x = p[j];
      for (;;) {
        u = p[s.back()];
        if (in[u] <= in[x] && in[x] <= out[u]) break;
        s.pop_back();
      }
      c[s.back()]++;
      s.push_back(j);
    }

    for (int j = 1; j < t; j++) {
      q[++qcnt] = {p[0], p[j], 1 - c[j], i};
    }
  }

  B = n / sqrt(qcnt) * 1.5;
  
  g[0] = {1};
  build(0);
  
  std::sort(q + 1, q + 1 + qcnt);
  for (int i = 1, j; i <= qcnt; i = j) {
    int o = bel[q[i].l];
    for (j = i + 1; j <= qcnt && o == bel[q[j].l]; j++) ;

    for (int k = i, x = b[o].bot, y = b[o].bot; k < j; k++) {
      if (bel[q[k].r] == o) {
        q0[q[k].l].push_back({q[k].l, q[k].r, -q[k].k, q[k].id});
        oans[q[k].id] += q[k].k * (pre1[q[k].r] - pre1[q[k].l]);
      } else {
        int l = q[k].l, r = q[k].r, t = lca(y, r);
        if (t != y) {
          ans[k] -= pre1[y] - pre1[t];
          q1[x].push_back({t, y, 1, k});
          y = t;
        }
        if (y != r) {
          ans[k] += pre1[r] - pre1[y];
          q1[x].push_back({y, r, -1, k});
          y = r;
        }
        if (x != l) {
          if (in[x] < in[l]) {
            ans[k] += pre2[l] - pre2[x];
            q2[y].push_back({x, l, -1, k});
          } else {
            ans[k] -= pre2[x] - pre2[l];
            q2[y].push_back({l, x, 1, k});
          }
          x = l;
        }
      }
    }
  }

  sumDS.tot = n / T + 1;
  dfsq(1);

  for (int i = 1; i <= qcnt; i++) {

    if (i > 1 && bel[q[i].l] == bel[q[i - 1].l]) {
      ans[i] += ans[i - 1];
    }

    if (bel[q[i].l] != bel[q[i].r]) oans[q[i].id] += ans[i] * q[i].k;
  }

  for (int i = 1; i <= m; i++) {
    std::cout << oans[i] << "\n";
  }
}

int main() {
  // freopen("t.in", "r", stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P6778">P6778 [Ynoi2009] rpdq</a>
> 给定 $n$ 个点的无根有边权的树，$m$ 次询问，求
> $$
> \sum_{l \leq i < j \leq r} \operatorname{dis}(i, j)
> $$
> 
> $1 \leq n, m, d \leq 2\times 10^5$。
> 
> 答案对 $2^{32}$ 取模。

二次离线莫队之后转换成求一个点到前缀 $1\dots k$ 的距离之和。转换成求它们的 lca 的深度之和。变成经典的链加链和，可以用树分块做到 $O(\sqrt n)$ 修改，$O(1)$ 查询。

这里树分块比较简单，只需要求出关键点，使得每个点向上最多跳 $\sqrt n$ 步就能到达某个关键点。

之前卡常卡魔怔了，这个代码貌似用bfs序重新标了一下号，感觉很毒瘤。

```cpp
// Author:  HolyK
// Created: Mon Apr 11 10:09:33 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(2e5 + 5), T(512), S(T * 4 + 5);
int n, m, B, siz[N], bot[N], fa[N], val[N], bup[N], bdn[N], kp[S];
int que[N], out[N], id[N], key[N], kid[S], kcnt;
unsigned dis[N], dep[N];
std::vector<PII> g[N];
void build(int x) {
  static int l = 1, r = 0;
  int c = 0;
  for (auto [y, z] : g[x]) {
    if (x) g[y].erase(std::find(g[y].begin(), g[y].end(), PII{x, z}));
    fa[y] = x;
    dep[y] = dep[x] + z;
    build(y);
    siz[x] += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }
  if (!x || siz[x] + 1 >= B || c > 1) {
    key[x] = ++kcnt;
    bot[x] = kcnt;
    siz[x] = 0;
    for (auto [y, z] : g[x]) {
      que[++r] = y;
      val[r] = z;
      if (bot[y]) {
        dis[r] = z;
        kp[bot[y]] = kcnt;
      }
      int u = r, bu = kcnt, bd = bot[y];
      for (; l <= r; l++) {
        int x = que[l];
        bup[l] = bu;
        bdn[l] = bd;
        if (key[x]) continue;
        for (auto [y, z] : g[x]) {
          que[++r] = y;
          val[r] = z;
          dis[r] = dis[l];
          if (bot[y]) dis[r] += z;
        }
      }
      out[u] = r;
    }
  }
  siz[x]++; 
}

void relabel() {
  static int tmp[N];
#define R(a) for (int i = 0; i <= n; i++) tmp[i] = a[que[i]]; memcpy(a, tmp, sizeof tmp)
  R(bot);
  R(fa);
  R(key);
  for (int i = 1; i <= n; i++) id[que[i]] = i;
  for (int i = 1; i <= n; i++) {
    fa[i] = id[fa[i]];
    if (key[i]) {
      kid[key[i]] = i;
    }
  }
}

unsigned v[N], s[N], ks[S], tag[S];
void add(int x) {
  while (!key[fa[x]]) {
    v[x] += val[x];
    x = fa[x];
  }
  assert(out[x]);
  s[x] = v[x] += val[x];
  for (int i = x + 1; i <= out[x]; i++) {
    s[i] = v[i] + s[fa[i]];
  }
  x = bup[x];
  while (x < kcnt) {
    tag[x]++;
    x = kp[x];
  }
  for (int i = kcnt - 1; i; i--) {
    ks[i] = ks[kp[i]] + dis[kid[i]] * tag[i] + s[kid[i]];
  }
}

unsigned ask(int x) {
  return key[x] ? ks[key[x]] : dis[x] * tag[bdn[x]] + s[x] + ks[bup[x]];
}

unsigned pre[N], ans[N], oans[N];
struct Qry {
  int l, r, id;
  bool operator<(const Qry &rhs) const {
    return l / T == rhs.l / T ? l / T & 1 ? r < rhs.r : r > rhs.r : l < rhs.l;
  }
} q[N];

struct Q {
  int l, r, k, id;
};
std::vector<Q> qq[N];
void solve() {
  cin >> n >> m;
  B = 1.5 * sqrt(n);
  for (int i = 1, x, y, z; i < n; i++) {
    cin >> x >> y >> z;
    g[x].push_back({y, z});
    g[y].push_back({x, z});
  }
  g[0].push_back({n + 1 >> 1, 0});
  build(0);
  relabel();
  unsigned sum = 0;
  for (int i = 1; i <= n; i++) {
    add(id[i]);
    sum += dep[i];
    pre[i] = pre[i - 1] + sum + i * dep[i] - 2 * ask(id[i]);
  }
  
  for (int i = 1; i <= m; i++) {
    int l, r;
    cin >> l >> r;
    q[i] = {l, r, i};
  }
  std::sort(q + 1, q + 1 + m);
  for (int i = 1, x = 1, y = 0; i <= m; i++) {
    if (y != q[i].r) {
      ans[i] += pre[q[i].r] - pre[y];
      if (y < q[i].r) {
        qq[x - 1].push_back({y + 1, q[i].r, -1, i});
      } else {
        qq[x - 1].push_back({q[i].r + 1, y, 1, i});
      }
      y = q[i].r;
    }
    if (x != q[i].l) {
      ans[i] += pre[q[i].l - 1] - pre[x - 1];
      if (x < q[i].l) {
        qq[y].push_back({x, q[i].l - 1, -1, i});
      } else {
        qq[y].push_back({q[i].l, x - 1, 1, i});
      }
      x = q[i].l;
    }
  }
  memset(v, 0, sizeof v);
  memset(s, 0, sizeof s);
  memset(ks, 0, sizeof ks);
  memset(tag, 0, sizeof tag);

  sum = 0;
  for (int i = 1; i <= n; i++) {
    add(id[i]);
    sum += dep[i];
    for (auto &[l, r, k, t] : qq[i]) {
      LL s = 0;
      for (int j = l; j <= r; j++) {
        s += sum + i * dep[j] - 2 * ask(id[j]);
      }
      ans[t] += k * s;
    }
  }
  for (int i = 1; i <= m; i++) {
    ans[i] += ans[i - 1];
    oans[q[i].id] = ans[i];
  }
  for (int i = 1; i <= m; i++) {
    std::cout << oans[i] << "\n";
  }
}

int main() {
  // freopen("t.in", "r", stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5064">P5064 [Ynoi2014] 等这场战争结束之后</a>

> 给你一个图，每个点有点权，最开始没有边。
> 
> 有一些操作：
> 
> 1. 添加一条 $x$ 与 $y$ 之间的双向边。
> 2. 回到第 $x$ 次操作后的状态（注意这里的 $x$ 可以是 0，即回到初始状态）。
> 3. 查询 $x$ 所在联通块能到的点中点权第 $y$ 小的值，如果不存在，那么输出 -1。
> 
> $1 \leq n, m \leq 10^5, 0 \leq a_i \leq 10^9$

zx2003 的论文题，复杂度是 $O(m\sqrt n)$ 时间，$O(n)$ 空间，但是跑不过暴力。

先离散化，注意到这里的离散化不需要去重。

建出操作树，然后可以预处理每个操作涉及到的点在当时所属并查集的根（因为要回滚，所以并查集是按秩合并），这个是 $O(m\log n)$ 的。

值域分块，对于每个询问，我们先求出它属于哪个值域块。

对于每个值域块，用 01 表示某个点是否属于这个值域块，然后用并查集维护每个联通块的和，就可以知道每个联通块里面 1 的个数。注意到并查集的合并是 $O(1)$ 的，而查询在前面已经预处理过。

所以这步总共是 $O(m \sqrt n)$。

然后要求出每个询问的具体答案，需要支持 $O(1)$ 询问一个点是否和当前的点联通。

将操作树分块，只需要求出关键点。每个关键点处理整张图的连通性，每个操作距离关键点最多只会连 $O(\sqrt n)$ 条边，将这些边用前向星存下来之后，每次操作bfs一下就可求出当前联通块有哪些点了。

我在实现的时候，为了方便，在关键点处改用了路径压缩并查集。

```cpp
// Author:  HolyK
// Created: Tue Apr 12 00:19:05 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), T(512);
int n, m, a[N], ch[N], g[N], fa[N];
PII b[N];
struct Option {
  int opt, x, y;
} q[N];
bool key[N];
int ans[N], siz[N], bot[N];
int f[N], s[N];
int find(int x) {
  while (x != f[x]) x = f[x];
  return x;
}
int find2(int x) {
  while (x != f[x]) x = f[x] = f[f[x]];
  return x;
}

int seq[N * 2], scnt;
void dfs1(int x) {
  if (q[x].opt == 1) {
    int &u = q[x].x, &v = q[x].y;
    u = find(u), v = find(v);
    if (u != v) {
      seq[scnt++] = x;
      if (s[u] > s[v]) std::swap(u, v);
      s[v] += s[u];
      f[u] = v;
    }
    
  } else if (q[x].opt == 3) {
    q[x].x = find(q[x].x);
    seq[scnt++] = x;
  }
  
  for (int i = ch[x], y; y = g[i], i < ch[x + 1]; i++) {
    dfs1(y);
  }
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      seq[scnt++] = x;
      s[v] -= s[u];
      f[u] = u;
    }
  }
}

int head[N], to[N], next[N], tot;
void add(int x, int y) {
  to[++tot] = y, next[tot] = head[x], head[x] = tot;
}
void del(int x, int y) {
  head[x] = next[tot--];
}

int tmp[N];
void dfs3(int x) {
  if (key[x]) return;
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      add(u, v), add(v, u);
    }
  } else if (q[x].opt == 3) {
    // std::cerr << "! dfs3 " << q[x].x << " " << q[x].y << "\n";
    static int que[N], r, vis[N], vcnt;
    que[r = 1] = q[x].x;
    vcnt++;
    for (int i = 1; i <= r; i++) {
      int x = que[i];
      vis[x] = vcnt;
      for (int j = head[x]; j; j = next[j]) {
        int y = to[j];
        if (vis[y] == vcnt) continue;
        que[++r] = y;
      } 
    }
    while (ans[x] < n) {
      if (vis[find2(b[ans[x]].second)] == vcnt && !q[x].y--) break; 
      ans[x]++;
    }
  }
  for (int i = ch[x], y; y = g[i], i < ch[x + 1]; i++) {
    dfs3(y);
  }
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      del(v, u), del(u, v);
    }
  }
}
void work(int x) {
  // std::cerr << "key " << x << "\n";
  memcpy(tmp, f, sizeof f);
  if (q[x].opt == 3) {
    while (ans[x] < n) {
      if (find2(b[ans[x]].second) == q[x].x && !q[x].y--) break; 
      ans[x]++;
    }
  }
  for (int i = ch[x], y; y = g[i], i < ch[x + 1]; i++) dfs3(y);
  memcpy(f, tmp, sizeof f);
}

void dfs2(int x) {
  if (q[x].opt == 1 && q[x].x != q[x].y) f[q[x].x] = q[x].y;
  int c = 0;
  for (int i = ch[x], y; y = g[i], i < ch[x + 1]; i++) {
    dfs2(y);
    siz[x] += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }
  if (!x || siz[x] + 1 >= T || c > 1) {
    key[x] = true;
    bot[x] = x;
    siz[x] = 0;
    work(x);
  }
  siz[x]++;
  if (q[x].opt == 1 && q[x].x != q[x].y) f[q[x].x] = q[x].x;
}

void solve() {
  std::cin >> n >> m;
  for (int i = 0; i < n; i++) {
    std::cin >> a[i];
    b[i] = {a[i], i};
  }
  std::sort(b, b + n);
  for (int i = 0; i < n; i++) {
    a[b[i].second] = i;
  }
  for (int i = 1; i <= m; i++) {
    int opt, x, y = 0, &f = fa[i];
    std::cin >> opt >> x;
    if (opt == 2) {
      f = x;
    } else {
      f = i - 1;
      std::cin >> y;
      x--, y--;
    }
    ch[f]++;
    q[i] = {opt, x, y};
  }
  for (int i = 1; i <= m; i++) ch[i] += ch[i - 1];
  for (int i = 1; i <= m; i++) g[--ch[fa[i]]] = i;
  for (int i = 0; i < n; i++) f[i] = i, s[i] = 1;
  dfs1(0);
  int tot = (n - 1) / T + 1;
  for (int i = 0; i < tot; i++) {
    for (int j = 0; j < n; j++) {
      s[j] = a[j] / T == i;
    }
    for (int j = 0; j < scnt; j++) {
      auto &[opt, x, y] = q[seq[j]];
      if (opt == 1) {
        if (f[x] == x) {
          f[x] = y;
          s[y] += s[x];
        } else {
          f[x] = x;
          s[y] -= s[x];
        }
      } else {
        if (ans[seq[j]] / T != i) continue;
        if (s[x] <= y) {
          y -= s[x];
          ans[seq[j]] += T;
        }
      }
    }
  }
  for (int i = 0; i < n; i++) {
    assert(f[i] == i);
  }
  dfs2(0);
  for (int i = 1; i <= m; i++) {
    if (q[i].opt == 3) {
      std::cout << (ans[i] >= n ? -1 : b[ans[i]].first) << "\n";
    }
  }
}

int main() {
  // freopen("t.in", "r", stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```


## <a href = "https://www.luogu.com.cn/problem/P4690">P4690 [Ynoi2016] 镜中的昆虫</a>
> 给定序列 $a_n$，$m$ 次操作。区间赋值，区间数颜色。
> 
> $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$
> 
> 空间 64MB。

数颜色的套路，数 $pre < l, l \leq i \leq r$ 的个数，再加一维时间，是三维偏序问题。

用 set 维护区间同色段之后就变成单点修改了，用 CDQ 分治搞一下三维偏序就行，但是这毒瘤空间那么小，我好像搞了多次 CDQ 才卡过，但是后来一次也搞过了，忘了为啥。

时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n)$。


```cpp
// Author:  HolyK
// Created: Tue Apr 12 15:02:43 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), Q(N * 15);
int n, m, a[N], la, ans[N];
std::map<int, std::set<int>> g;
std::set<int> p;

struct Option {
  int x, l, r, id;
  bool operator<(const Option &rhs) const {
    return x < rhs.x || x == rhs.x && id < rhs.id;
  }
} s[Q], t[Q];
int cnt;

namespace Fenwick {
int c[N];
void add(int p, int x) {
  for (; p <= n; p += p & -p) {
    c[p] += x;
  }
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p & -p) {
    r += c[p];
  }
  return r;
}
}
int st[Q];

void solve(int l, int r) {
  if (l == r) return;
  int m = l + r >> 1;
  solve(l, m), solve(m + 1, r);
  using namespace Fenwick;
  int i = l, j = m + 1;
  for (int k = l; k <= r; k++) {
    if (j > r || i <= m && s[i] < s[j]) {
      if (!s[i].id) {
        add(s[i].l, s[i].r);
        st[++st[0]] = i;
      }
      t[k] = s[i++];
    } else {
      if (s[j].id) {
        ans[s[j].id] += ask(s[j].r) - ask(s[j].l - 1);
      }
      t[k] = s[j++];
    }
  }
  while (st[0]) {
    i = st[st[0]--];
    add(s[i].l, -s[i].r);
  }
  for (int k = l; k <= r; k++) s[k] = t[k];
}

void add(int p, int i) {
  s[++cnt] = {p, i, 1, 0};
}
void del(int p, int i) {
  s[++cnt] = {p, i, -1, 0};
}
void ask(int l, int r, int id) {
  s[++cnt] = {l - 1, l, r, id};
}

std::set<int>::iterator split(int x) {
  auto u = p.insert(x);
  if (u.second) {
    int p = *std::prev(u.first);
    a[x] = a[p];
    auto &v = g[a[x]];
    auto it = v.insert(x).first;
    add(p, x);
    if (++it != v.end()) del(p, *it), add(x, *it);
  }
  return u.first;
}


void solve() {
  std::cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    std::cin >> a[i];
    p.insert(i);
  }
  p.insert(n + 1);

  for (int i = 1; i <= n; i++) {
    auto &v = g[a[i]];
    auto it = v.insert(i).first;
    int p = it == v.begin() ? 0 : *std::prev(it);
    add(p, i);
  }

  for (int i = 1; i <= m; i++) {
    int opt, l, r, x;
    std::cin >> opt >> l >> r;
    if (opt == 1) {
      split(++r);
      for (auto it = split(l); *it != r; it = p.erase(it)) {
        x = *it;
        auto &v = g[a[x]];
        auto t = v.find(x);
        assert(t != v.end());
        int p = t == v.begin() ? 0 : *std::prev(t);
        t = v.erase(t);
        del(p, x);
        if (t != v.end()) {
          del(x, *t);
          add(p, *t);
        }
      }
      std::cin >> x;
      auto &v = g[x];
      a[l] = x;
      p.insert(l);
      auto it = v.insert(l).first;
      int p = it == v.begin() ? 0 : *std::prev(it);
      add(p, l);
      if (++it != v.end()) {
        del(p, *it);
        add(l, *it);
      }
    } else {
      split(l);
      ask(l, r, ++la);
    }
  }
  solve(1, cnt);
  for (int i = 1; i <= la; i++) {
    std::cout << ans[i] << "\n";
  }
}

int main() {
  // freopen("t.in", "r", stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P5073">P5073 [Ynoi2015] 世上最幸福的女孩</a>
> 给定序列 $a_n$，$m$ 次操作，全局加，区间求最大子段和。
> 
> $1 \leq n \leq 3\times 10^5, 1 \leq m \leq 6\times 10^5$。
> 
> 空间 128MB。

考虑经典线段树做法维护前后缀以及答案。

对于全局加了 $a$，设原先长度为 $a$ 的答案为 $b$，那么新的答案是 $ax + b$，是经典的维护凸包问题。

对于合并左子树后缀和右子树前缀的情况，可以发现是闵可夫斯基和。

线段树维护一下几个凸包就行。

然后将询问离线，把 $x$ 从小到大排序，就可以不用在凸包上二分。

但是这样空间炸了。

考虑可以一层一层做，在线段树上从底向上做，每次只存一层的信息即可。

但我还是没卡过去空间，所以经典卡空间方法：考虑将序列分块，每块都重新建线段树算一遍，又好写又快。

实现的时候，把线段树底层改成暴力会有很明显的优化效果。

写这个的时候，维护凸包用的是 kactl 里面那个 lineContainer 的方法，有除法，有点不优，不如直接维护算了。

```cpp
// Author:  HolyK
// Created: Mon Apr 25 10:14:03 2022
#include <bits/stdc++.h>

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

namespace {
inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(3e5 + 5), B(N >> 2), T(16);
constexpr LL INF(LLONG_MAX);
struct Line {
  int x;
  LL y, p;
  bool operator<(LL r) const { return p < r; }

  LL eval(LL z) { return x * z + y; } 
};
using C = std::vector<Line>;

LL div(LL a, LL b) {
  return a / b - ((a ^ b) < 0 && a % b);
}
void get(Line &a, const Line &b) {
  if (a.x == b.x) {
    a.p = a.y > b.y ? INF : -INF;
  } else {
    a.p = div(a.y - b.y, b.x - a.x);
  }
}
void add(C &c, int x, LL y) {
  Line o = {x, y, INF};
  if (c.empty()) {
    c.push_back(o);
    return;
  }
  while (c.size() > 1) {
    get(c.back(), o);
    if (c[c.size() - 2].p < c.back().p) break;
    c.pop_back();
  }
  get(c.back(), o);
  c.push_back(o);
}


int n, m, a[N];
LL b[N];
struct Node {
  C pre, suf, ans;
  LL sum;
  int pl, sl, al;
} t[B >> 2];
#define ls o << 1
#define rs o << 1 | 1

C msum(const C &a, const C &b) {
  C c = {Line{a[0].x + b[0].x, a[0].y + b[0].y, INF}};
  for (int i = 0, j = 0; i + 1 < a.size() || j + 1 < b.size(); ) {
    Line &o = c.back();
    if (j + 1 == b.size() || i + 1 < a.size() && a[i].p < b[j].p) {
      add(c, o.x + a[i + 1].x - a[i].x, o.y + a[i + 1].y - a[i].y);
      i++;
    } else {
      add(c, o.x + b[j + 1].x - b[j].x, o.y + b[j + 1].y - b[j].y);
      j++;
    }
  }
  return c;
}
C merge(const C &a, const C &b) {
  C c;
  for (int i = 0, j = 0; i < a.size() || j < b.size(); ) {
    if (j == b.size() || i < a.size() && a[i].x < b[j].x) {
      add(c, a[i].x, a[i].y);
      i++;
    } else {
      add(c, b[j].x, b[j].y);
      j++;
    }
  }
  return c;
}

void build(int o, int l, int r) {
  t[o].pl = t[o].sl = t[o].al = 0;
  if (r - l + 1 <= T) {
    t[o].pre.clear();
    t[o].suf.clear();
    t[o].ans.clear();
    LL s = 0;
    add(t[o].pre, 0, 0);
    for (int i = 1; i <= r - l + 1; i++) {
      s += a[l + i - 1];
      add(t[o].pre, i, s);
    }
    s = 0;
    add(t[o].suf, 0, 0);
    for (int i = 1; i <= r - l + 1; i++) {
      s += a[r - i + 1];
      add(t[o].suf, i, s);
    }
    add(t[o].ans, 0, 0);
    for (int i = 1; i <= r - l + 1; i++) {
      LL max = -INF;
      for (int j = l + i - 1; j <= r; j++) {
        smax(max, b[j] - b[j - i]);
      }
      add(t[o].ans, i, max);
    }
    t[o].sum = s;
    return;
  }
  int m = l + r >> 1;
  build(ls, l, m);
  build(rs, m + 1, r);

  t[o].pre = t[ls].pre;
  for (auto &[x, y, _] : t[rs].pre) {
    add(t[o].pre, x + m - l + 1, y + t[ls].sum);
  }
  t[o].suf = t[rs].suf;
  for (auto &[x, y, _] : t[ls].suf) {
    add(t[o].suf, x + r - m, y + t[rs].sum);
  }
  t[o].ans = merge(merge(t[ls].ans, t[rs].ans), msum(t[ls].suf, t[rs].pre));
  t[o].sum = t[ls].sum + t[rs].sum;
}

struct Info {
  LL r, a;
  void apply(LL pre, LL suf, LL ans, LL sum) {
    smax(a, ans);
    smax(a, r + pre);
    r = std::max(suf, r + sum);
  }
} qans[N * 2];

LL ask(const C &c, LL x) {
  auto l = std::lower_bound(c.begin(), c.end(), x);
  assert(l != c.end());
  return l->x * x + l->y;
}

void ask(int o, int l, int r, int x, int y, LL z, int id) {
  if (x <= l && r <= y) {
    auto &pl = t[o].pl, &sl = t[o].sl, &al = t[o].al;
    while (t[o].pre[pl].p < z) pl++;
    while (t[o].suf[sl].p < z) sl++;
    while (t[o].ans[al].p < z) al++;
    qans[id].apply(t[o].pre[pl].eval(z), t[o].suf[sl].eval(z), t[o].ans[al].eval(z), t[o].sum + z * (r - l + 1));
    return;
  }
  if (r - l + 1 <= T) {
    LL pre, suf, ans, sum, max = 0;
    pre = suf = ans = sum = 0;
    for (int i = std::max(x, l); i <= r && i <= y; i++) {
      sum += a[i] + z;
      smax(pre, sum);
      smax(ans, sum + max);
      smax(max, -sum);
    }
    sum = 0;
    for (int i = std::min(r, y); i >= l && i >= x; i--) {
      sum += a[i] + z;
      smax(suf, sum);
    }
    qans[id].apply(pre, suf, ans, sum);
    return;
  }
  int m = l + r >> 1;
  if (x <= m) ask(ls, l, m, x, y, z, id);
  if (y > m) ask(rs, m + 1, r, x, y, z, id);
}


struct Qry {
  int l, r, id;
  LL x;
  bool operator<(const Qry &rhs) const {
    return x < rhs.x;
  }
} q[N * 2];
int qq;
void solve() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i], b[i] = a[i] + b[i - 1];
  LL d = 0;
  while (m--) {
    int opt, l, r;
    cin >> opt;
    if (opt == 1) {
      cin >> l;
      d += l;
    } else {
      cin >> l >> r;
      q[qq] = {l, r, qq, d};
      qq++;
    }
  }
  std::sort(q, q + qq);
  for (int l = 1, r; l <= n; l += B) {
    r = std::min(l + B - 1, n);
    build(1, l, r);
    for (int i = 0; i < qq; i++) {
      if (q[i].r < l || q[i].l > r) continue;
      ask(1, l, r, q[i].l, q[i].r, q[i].x, q[i].id);
    }
  }
  for (int i = 0; i < qq; i++) {
    std::cout << qans[i].a << "\n";
  }
}
}

int main() {
  // freopen("t.in", "r", stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## <a href = "https://www.luogu.com.cn/problem/P4118">P4118 [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？</a>
> 给定序列 $a_n$，$m$ 次操作，区间加，区间求最大子段和。
> 
> $1 \leq n, m \leq 10^5$。
> 
> 空间 64 MB。

上面那题的进阶版本，1秒时限太毒瘤了，卡不过去，所以这题是 80 分。

顺着上题思路，分块之后每块处理。

修改和询问会变成 $O(m\sqrt n)$ 次全局操作和 $O(m)$ 次区间操作。

对于全局加全局查询，按照上题的做法，把询问按照 $x$ 基数排序，每次做凸包指针移动次数是 $O(\sqrt n)$。

对于区间修改，会使得把全局查询的凸包指针失效，但是只会修改 $O(m)$ 次，所以每次修改之后重置指针，复杂度是 $O(m\sqrt n)$。

区间修改，在线段树上更新凸包，这样做的复杂度是 $O(\sqrt n+ \sqrt n/2+ \sqrt n/4+\dots) = O(\sqrt n)$，所以每次直接在线段树上搞，复杂度是 $O(m\sqrt n)$。

区间查询，每次查询可以是 $O(\sqrt n)$ 的，但是这样写可能常数比较大，我写的是在线段树上查询，每个凸包二分一下，复杂度是 $O(m \log^2 n)$。

线段树底层仍然要暴力。

对于信息合并，直接归并的复杂度太高了，观察这个凸包，发现 $x$ 坐标的范围是 $1 \dots len$，所以说可以类似桶排序，对于每个 $x$ 坐标存一下 $y$ 坐标的最大值，这样 cache 友好，卡常效果明显。

这个信息，本来是用 vector 存，后面卡常把 vector 扔掉了，最后还是没卡过去，真是尽力了。

```cpp
// Author:  HolyK
// Created: Wed Apr 27 14:32:40 2022
#include <bits/stdc++.h>

inline char gc() {
  static constexpr int BufferSize = 1 << 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i->sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template <class T>
  Reader &operator>>(T &w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == '-') p = 1;
    for (w = c & 15; std::isdigit(c = gc()); w = w * 10 + (c & 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

template <class T, class U>
inline bool smin(T &x, const U &y) {
  return y < x ? x = y, 1 : 0;
}
template <class T, class U>
inline bool smax(T &x, const U &y) {
  return x < y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair<int, int>;

constexpr int N(1e5 + 5), T(8), B(T << 6);
constexpr LL INF(LLONG_MAX / 3);
struct Pt {
  int x;
  LL y;
  Pt operator+(const Pt &r) const { return {x + r.x, y + r.y}; }
  Pt operator-(const Pt &r) const { return {x - r.x, y - r.y}; }
  LL operator*(const Pt &r) const { return x * r.y - y * r.x; }
  LL cross(const Pt &a, const Pt &b) const { return (a - *this) * (b - *this); }
  LL eval(LL z) const { return x * z + y; }
} pt[B * 30], s[B + 5];
int ptr;

struct Hull {
  int l, r;
  Pt *begin() const { return pt + l; }
  Pt *data() const { return begin(); }
  Pt *end() const { return pt + r; }
  int size() const { return r - l; }
  void assign(Pt *s, Pt *e) {
    r = l + (e - s);
    memcpy(pt + l, s, (e - s) * sizeof(*s));
  }
  Pt &operator[](const int &i) const {
    // assert(0 <= i && i < size());
    return pt[l + i];
  }
};
using C = Hull;
// using C = std::vector<Pt>;

void fwd(const C &c, int &p, LL x) {
  while (p + 1 < c.size() && c[p].y - c[p + 1].y < x * (c[p + 1].x - c[p].x)) p++;
}

int top;
void add(Pt x) {
  while (top > 1 && s[top - 2].cross(s[top - 1], x) >= 0) top--;
  s[top++] = x;
}

LL val[B + 5];
void update(const Pt &x) { smax(val[x.x], x.y); }
void cal(int n) {
  top = 0;
  for (int i = 1; i <= n; i++) if (val[i] != -INF) add({i, val[i]});
}

struct Node {
  C pre, suf, ans;
  LL sum;
} t[B << 2];
LL tag[B << 2];
#define ls o << 1
#define rs o << 1 | 1
void pushup(int o, int len) {
  int ll = len - len / 2, rr = len / 2, tmp = ptr;
  LL l = t[ls].sum + tag[ls] * ll, r = t[rs].sum + tag[rs] * rr;
  C lsuf, rpre;
  lsuf.l = ptr -= t[ls].suf.size();
  lsuf.assign(t[ls].suf.begin(), t[ls].suf.end());
  rpre.l = ptr -= t[rs].pre.size();
  rpre.assign(t[rs].pre.begin(), t[rs].pre.end());
  // auto lsuf = t[ls].suf, rpre = t[rs].pre;
  
  // pre
  top = t[ls].pre.size();
  memcpy(s, t[ls].pre.data(), top * sizeof(*s));
  for (int i = 0; i < top; i++) s[i].y += s[i].x * tag[ls];
  int cur = top;
  for (auto &[x, y] : rpre) {
    y += x * tag[rs];
    s[cur++] = {x + ll, y + l};
  }
  for (int i = top; i < cur; i++) add(s[i]);
  t[o].pre.assign(s, s + top);

  // suf
  top = t[rs].suf.size();
  memcpy(s, t[rs].suf.data(), top * sizeof(*s));
  for (int i = 0; i < top; i++) s[i].y += s[i].x * tag[rs];
  cur = top;
  for (auto &[x, y] : lsuf) {
    y += x * tag[ls];
    s[cur++] = {x + rr, y + r};
  }
  for (int i = top; i < cur; i++) add(s[i]);
  t[o].suf.assign(s, s + top);

  // ans: lr
  for (int i = 1; i <= len; i++) val[i] = -INF;
  for (auto &[x, y] : t[ls].ans) smax(val[x], y + x * tag[ls]);
  for (auto &[x, y] : t[rs].ans) smax(val[x], y + x * tag[rs]);

  // ans: merge
  update(lsuf[0] + rpre[0]);
  for (int i = 0, j = 0; i + 1 < lsuf.size() || j + 1 < rpre.size(); ) {
    if (j + 1 == rpre.size() || i + 1 < lsuf.size() && (lsuf[i + 1] - lsuf[i]) * (rpre[j + 1] - rpre[j]) < 0) {
      i++;
    } else {
      j++;
    }
    update(lsuf[i] + rpre[j]);
  }
  cal(len);
  t[o].ans.assign(s, s + top);
  
  t[o].sum = l + r;
  
  ptr = tmp;
}

LL a[N];
void init(int o, int l, int r) {
  LL sum = 0;
  top = 0;
  for (int i = l; i <= r; i++) {
    sum += a[i];
    add({i - l + 1, sum});
  }
  t[o].pre.assign(s, s + top);
  top = 0, sum = 0;
  for (int i = r; i >= l; i--) {
    sum += a[i];
    add({r - i + 1, sum});
  }
  t[o].suf.assign(s, s + top);
  t[o].sum = sum;
  for (int i = 1; i <= r - l + 1; i++) val[i] = -INF;
  for (int i = l; i <= r; i++) {
    sum = 0;
    for (int j = i; j <= r; j++) {
      sum += a[j];
      smax(val[j - i + 1], sum);
    }
  }
  cal(r - l + 1);
  t[o].ans.assign(s, s + top);
}

void build(int o, int l, int r) {
  t[o].pre.l = ptr -= r - l + 1;
  t[o].suf.l = ptr -= r - l + 1;
  t[o].ans.l = ptr -= r - l + 1;
  tag[o] = 0;
  if (r - l + 1 <= T) {
    init(o, l, r);
    return;
  }
  int m = l + r >> 1;
  build(ls, l, m);
  build(rs, m + 1, r);
  pushup(o, r - l + 1);
}


void update(int o, int l, int r, int x, int y, LL z) {
  if (x <= l && r <= y) {
    tag[o] += z;
    return;
  }
  if (r - l + 1 <= T) {
    // std::cerr << "updateI " << l << " " << r << " " << x << " " << y << "\n";
    for (int i = std::max(l, x); i <= r && i <= y; i++) a[i] += z;
    init(o, l, r);
    return;
  }
  int m = l + r >> 1;
  if (x <= m) update(ls, l, m, x, y, z);
  if (y > m) update(rs, m + 1, r, x, y, z);
  pushup(o, r - l + 1);
}

struct Info {
  LL r, a;
  void apply(LL pre, LL suf, LL ans, LL sum) {
    smax(a, ans);
    smax(a, r + pre);
    r = std::max(suf, r + sum);
  }
} qans[N];


LL ask(const C &c, LL x) {
  int l = 0, r = c.size() - 1;
  while (l < r) {
    int m = l + r >> 1;
    if (c[m].y - c[m + 1].y < x * (c[m + 1].x - c[m].x)) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return c[l].eval(x);
}

void ask(int o, int l, int r, int x, int y, int id, LL z) {
  z += tag[o];
  if (x <= l && r <= y) {
    qans[id].apply(ask(t[o].pre, z), ask(t[o].suf, z), ask(t[o].ans, z), t[o].sum + z * (r - l + 1));
    return;
  }
  if (r - l + 1 <= T) {
    LL pre, suf, ans, sum, max;
    pre = suf = ans = sum = max = 0;
    for (int i = std::max(x, l); i <= r && i <= y; i++) {
      sum += a[i] + z;
      smax(pre, sum);
      smax(ans, sum + max);
      smax(max, -sum);
    }
    sum = 0;
    for (int i = std::min(r, y); i >= l && i >= x; i--) {
      sum += a[i] + z;
      smax(suf, sum);
    }
    qans[id].apply(pre, suf, ans, sum);
    return;
  }

  int m = l + r >> 1;
  if (x <= m) ask(ls, l, m, x, y, id, z);
  if (y > m) ask(rs, m + 1, r, x, y, id, z);
}


struct Operation {
  int opt, l, r, x;
} op[N];
struct Qry {
  LL x;
  int id;
} q[N], nq[N];

void solve() {
  int n, m;
  cin >> n >> m;
  for (int i = 1; i <= n; i++) cin >> a[i];
  for (int i = 0; i < m; i++) {
    int opt, l, r, x = 0;
    cin >> opt >> l >> r;
    if (opt == 1) cin >> x;
    op[i] = {opt, l, r, x};
  }

  for (int l = 1; l <= n; l += B) {
    ptr = B * 30;
    int r = std::min(l + B - 1, n);
    build(1, l, r);
    int pl, sl, al, qn;

    auto init = [&] { pl = sl = al = qn = 0; };

    auto run = [&] {
      if (!qn) return;
      if (qn > 800) {
        LL min = LLONG_MAX;
        for (int i = 0; i < qn; i++) smin(min, q[i].x);
        for (int i = 0; i < qn; i++) q[i].x -= min;
        static int c[256];
#define SORT(a, b, n, d)                                                \
        memset(c, 0, sizeof c);                                         \
        for (int i = 0; i < n; i++) c[a[i].x >> d & 0xff]++;            \
        for (int i = 1; i < 256; i++) c[i] += c[i - 1];                 \
        for (int i = qn - 1; i >= 0; i--) b[--c[a[i].x >> d & 0xff]] = a[i];

        SORT(q, nq, qn, 0);
        SORT(nq, q, qn, 8);
        SORT(q, nq, qn, 16);
        SORT(nq, q, qn, 24);
        
        for (int i = 0; i < qn; i++) q[i].x += min;
      } else {
        std::sort(q, q + qn, [&](const Qry &i, const Qry &j) { return i.x < j.x; });
      }
      for (int i = 0; i < qn; i++) {
        fwd(t[1].pre, pl, q[i].x);
        fwd(t[1].suf, sl, q[i].x);
        fwd(t[1].ans, al, q[i].x);
        qans[q[i].id].apply(t[1].pre[pl].eval(q[i].x), t[1].suf[sl].eval(q[i].x), t[1].ans[al].eval(q[i].x), t[1].sum + (r - l + 1) * q[i].x);
      }
    };
    
    init();
    for (int i = 0; i < m; i++) {
      if (op[i].r < l || op[i].l > r) continue;
      if (op[i].l <= l && r <= op[i].r) {
        if (op[i].opt == 1) {
          tag[1] += op[i].x;
        } else {
          q[qn++] = {tag[1], i};
        }
      } else {
        if (op[i].opt == 1) {
          run();
          init();
          update(1, l, r, op[i].l, op[i].r, op[i].x);
        } else {
          ask(1, l, r, op[i].l, op[i].r, i, 0);
        }
      }
    }
    run();
  }
  for (int i = 0; i < m; i++) {
    if (op[i].opt == 2) {
      std::cout << qans[i].a << "\n";
    }
  }
}

int main() {
  // freopen("t.in", "r", stdin);
  // freopen("t.out", "w", stdout);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin >> t;
  
  while (t--) {
    solve();
  }

  std::cerr << (double)clock() / CLOCKS_PER_SEC << "\n";
  return 0;
}
```
                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2022-08-05</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="/post/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E8%AE%B0/">
			下回<br>全局平衡二叉树小记
                </a>
                
                
                
                <a class="older-posts" href="/post/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%B0%8F%E8%AE%B0/">
			上回<br>常系数齐次线性递推小记
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                










            </div>
        </div>
    </div>


                    </div>
            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	
</div>
            </div>
    
    <script src="/js/journal.js"></script>
    </body>
</html>
