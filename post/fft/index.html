<!DOCTYPE html>
<html><head>
<title>Fast Fourier Transform</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="快速傅里叶变换的推导和优化。">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">











<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">


  






<link rel="stylesheet" href="/scss/journal.min.8e28ea12f6e17fa31de20b68201547b6843cb5deca28115ad2f58c2a899823e3.css" integrity="sha256-jijqEvbhf6Md4gtoIBVHtoQ8td7KKBFa0vWMKomYI&#43;M=" media="screen">



<script src="/vendor/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>






  <script src="/js/toc.js"></script>















<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]], [["\\(", "\\)"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\\[", "\\]"],
    ],
    svg: {
      fontCache: "global",
    },
    options: {
    enableMenu: true,          
    menuOptions: {
      settings: {
        texHints: true,        
        semantics: false,      
        zoom: 'NoZoom',        
        zscale: '200%',        
        renderer: 'CHTML',     
        alt: false,            
        cmd: false,            
        ctrl: false,           
        shift: false,          
        scale: 1,              
        inTabOrder: true,      

        assistiveMml: true,    
        collapsible: false,    
        explorer: false,       
      },
      annotationTypes: {
        TeX: ['TeX', 'LaTeX', 'application/x-tex'],
        StarMath: ['StarMath 5.0'],
        Maple: ['Maple'],
        ContentMathML: ['MathML-Content', 'application/mathml-content+xml'],
        OpenMath: ['OpenMath']
      }
    }
  }
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js">
    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>

<link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.initLineNumbersOnLoad();</script>

</head>
<body>
    	<div id="app"><div id="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://blog.asukakyle.top">
    
        <div class="nav-title">
            HolyK&#39;s Blog
        </div>
        
        <div class="nav-subtitle">
            明日は明日の風が吹く
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/about">
                About
            </a>
            
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/post">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/friend">
                Friends
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS Feed
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	

    </div>
    
</div><div id="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" id="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/about">
                    About
                </a>
                
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/post">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/friend">
                    Friends
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS Feed
                </a>
                
            
            
            <div class="toc">


</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div id="drawer-mask" v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav id="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div id="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a id="navTitle" class="navbar-brand" href="https://blog.asukakyle.top">
            HolyK&#39;s Blog
        </a>
        
    </div>
</nav>
<div class="single-column-header-container" id="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://blog.asukakyle.top">
        <div class="single-column-header-title">HolyK&#39;s Blog</div>
        
        <div class="single-column-header-subtitle">明日は明日の風が吹く</div>
        

    </a>
</div>

            <div id="content">
                <div id="streamContainer" class="stream-container">

    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper"
                
                    style="background-image: url('http://www.dmoe.cc/random.php')"
                
            >
                <div class="post-title">
                    Fast Fourier Transform
                    
                    <div class="post-subtitle">
                        快速傅里叶变换的推导和优化。
                    </div>
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-03-18 15:28
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0">算法笔记</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/fft">FFT</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    
## Introduction

> `快速傅里叶变换(Fast Fourier Transform，FFT)`是一种可在 $O(n \log n)$ 时间内完成的`离散傅里叶变换 (Discrete Fourier Transform，DFT)` 的算法，用来实现将信号从原始域（通常是时间或空间）到频域的互相转化。

FFT 在算法竞赛中主要用来加速多项式乘法（循环卷积）。

### 多项式

形如
$$
A(x) = a_0 + a_1x + a_2x^2 + \dots + a_{n-1}x^{n - 1}
$$
的式子称为 $x$ 的 $n - 1$ 次多项式，其中 $a_0, a_1, \dots, a_{n - 1}$ 称为多项式系数，$n-1$ 称为多项式的次数，记为 $\deg A(x)$ 或 $\deg A$。

### 点值

$n - 1$ 次多项式 $A(x)$ 在 $x = m$ 处的**点值**
$$
A(m) = \sum_{k=0}^{n-1} a_km^k
$$

### 多项式乘法

记 $A(x)\times B(x)$ 表示多项式 $A(x), B(x)$ 做多项式乘法，可以简写为 $A(x)\cdot B(x)$ 或 $A(x)B(x)$。

多项式乘法
$$
\begin{aligned}
C(x) = &A(x) \times B(x)\\
= &\left(a_0 + a_1x + \dots + a_{\deg A}x^{\deg A}\right)\cdot\left(b_0 + b_1x + \dots + b_{\deg B}x^{\deg B}\right)\\
= &\sum_{r = 0}^{\deg A + \deg B} \sum_{k = 0}^r a_kb_{r - k} x^r
\end{aligned}
$$
用系数关系可以表示为
$$
c_r = \sum_{k = 0}^ra_kb_{r - k}
$$

其中 $\deg C = \deg A + \deg B$。

易证它们的点值满足如下关系
$$
C(m) = A(m)B(m)
$$

### 循环卷积

记 $\operatorname{conv}(A, B, n)$ 表示多项式 $A(x), B(x)$ 做长度为 $n$ 的循环卷积。

循环卷积
$$
C(x) = \operatorname{conv}(A, B, n)
$$
系数关系表示为
$$
c_k = \sum_{p, q}[(p + q) \bmod n = k]a_pb_q
$$
其中 $\deg C = n - 1$。

容易发现，当 $n > \deg A + \deg B$ 时，该运算等价于多项式乘法。

### DFT

> `离散傅里叶变换(Discrete Fourier Transform, DFT)` 将多项式 $A(x)=\sum_{k=0}^{n-1}a_kx^k$ 转换为一些特殊的点值。

记  $n$ 次单位复根
$$
\omega_n = e^{\frac{2i\pi}n}=\cos\dfrac{2\pi}{n}+i\sin\dfrac{2\pi}{n}
$$
$DFT(A)$ 就是要计算点值 $A(\omega_n^k), k = 0， 1， 2， \dots, n-1$。

单位根自带的循环特性使得循环卷积 $C(x) = \operatorname{conv}(A, B, n)$ 的点值也满足：
$$
C(\omega_n^k) = A(\omega_n^k)B(\omega_n^k)
$$

### IDFT

IDFT 是 DFT 的逆变换。

首先，用等比数列求和易证：
$$
\begin{aligned}
\frac1n\sum_{k = 0}^{n - 1}\omega_n^{vk} &= [v \bmod n = 0]
\end{aligned}
$$
考虑循环卷积 $C(x) = \operatorname{conv}(A, B, n)$ 的系数表示
$$
\begin{aligned}
c_r = &\sum_{p, q}[(p + q) \bmod n = r]a_pb_q\\
= &\sum_{p, q}[(p + q - r) \bmod n = 0]a_pb_q\\
= &\sum_{p, q}\frac1n\sum_{k = 0}^{n - 1}\omega_n^{pk+qk-rk}a_pb_q\\
= &\sum_{p, q}\frac1n\sum_{k = 0}^{n - 1}\omega_n^{-rk}\cdot\omega_n^{pk}a_p\cdot\omega_n^{qk}b_q\\
= &\frac1n\sum_{k = 0}^{n - 1}\omega_n^{-rk}\left(\sum_{p}\omega_n^{pk}a_p\sum_q\omega_n^{qk}b_q\right)\\
= &\frac1n\sum_{k = 0}^{n - 1}\left(\omega_n^{-r}\right)^kA(\omega_n^k)B(\omega_n^k)\\
= &\frac1n\sum_{k = 0}^{n - 1}\left(\omega_n^{n-r}\right)^kC(\omega_n^k)
\end{aligned}
$$

设多项式
$$
C'(x) = \sum_{k=0}^{n-1}C(\omega_n^k)x^k
$$
只要计算 $DFT(C')$ 即可得到 $C(x)$ 的系数，于是我们用 DFT 完成了逆变换 IDFT。

用两次 DFT 和一次 IDFT就可以计算 $\operatorname{conv}(A, B, n)$。

暴力的复杂度是 $O(n^2)$，此处不赘述。

### FFT

现在尝试将 DFT 问题分解以优化时间复杂度。

**本部分认为 $n = \deg A + 1$ 为 $2$ 的整数次幂。对于更一般的情况，暂不考虑。**

#### DIF

**将序列 $a_i$ 分成左右两半**。
$$
\begin{aligned}
A(\omega_n^{r}) &= \sum_{k = 0}^{n-1}a_k\omega_n^{rk}\\
&= \sum_{k = 0}^{n / 2 - 1} \left(a_k\cdot\omega_n^{rk} + a_{k+n/2}\cdot\omega_n^{rk+rn/2}\right)\\
&= \sum_{k = 0}^{n / 2 - 1} \left[a_k\cdot\omega_n^{rk} + (-1)^r\cdot a_{k+n/2}\cdot\omega_n^{rk}\right]\\
&= \sum_{k = 0}^{n / 2 - 1} \left[a_k+(-1)^ra_{k+n/2}\right]\omega_{n}^{rk}
\end{aligned}
$$
**进一步，将 $A(\omega_{n}^r)$ 按奇偶分类**：
$$
\begin{aligned}
A\left(\omega_n^{2r}\right) &= \sum_{k=0}^{n/2-1}\left(a_k+a_{k+n/2}\right)\omega_{n/2}^{rk}\\
A\left(\omega_n^{2r+1}\right) &= \sum_{k=0}^{n/2-1}\left(\omega_{n}^ka_k-\omega_{n}^ka_{k+n/2}\right)\omega_{n/2}^{rk}
\end{aligned}
$$

设
$$
\begin{aligned}
&p_k=a_k+a_{k+n/2}, &P(x) = \sum_{k = 0}^{n/2-1}p_kx^k\\
&q_k=\omega_{n}^k(a_k-a_{k+n/2}), &Q(x) = \sum_{k=0}^{n/2-1}q_kx^k
\end{aligned}
$$
我们只需要求出 $P(\omega_{n/2}^r)$ 和 $Q(\omega_{n/2}^r)$ ，即求解规模为原来一半的两个子问题 $DFT(P), DFT(Q)$，就能在 $O(n)$ 时间内计算出 $DFT(A)$。


#### DIT

**在算法竞赛中这种方法更常见。**

注意到在 `DIF` 中我们最后将 $A(\omega_n^r)$ 奇偶分类求解，那不妨思考**将序列 $a_k$ 按奇偶分类**。

设
$$
\begin{aligned}
A_0(x) = a_0 + a_2x + \dots + a_{n - 2}x^{n / 2}\\
A_1(x) = a_1 + a_3x+ \dots + a_{n - 1}x^{n / 2}
\end{aligned}
$$
则
$$
A(x) = A_0(x^2) + xA_1(x^2)
$$
所以
$$
\begin{aligned}
A(\omega_n^k) &= A_0(\omega_n^{2k}) + \omega_n^kA_1(\omega_n^{2k})\\
&= A_0(\omega_{n/2}^k) + \omega_n^kA_1(\omega_{n/2}^k)
\end{aligned}
$$
**将 $A(\omega_n^k)$ 再分为左右两半**，这里运用了等式  $\omega_{n/2}^k = \omega_{n/2}^{k + n/2}$ 和 $\omega_n^k+\omega_n^{k+n/2} = 0$ :
$$
\begin{aligned}
A(\omega_n^k) &= A_0(\omega_{n/2}^k) + \omega_n^kA_1(\omega_{n/2}^k)\\
A\left(\omega_n^{k+n/2}\right) &= A_0(\omega_{n/2}^k) - \omega_n^kA_1(\omega_{n/2}^k)
\end{aligned}
$$
我们只需要求出 $A_0(\omega_{n/2}^k)$ 和 $A_1(\omega_{n/2}^k)$ ，即求解规模为原来一半的两个子问题 $DFT(A_0), DFT(A_1)$，就能在 $O(n)$ 时间内计算出 $DFT(A)$。

#### Complexity

设次数为 $n - 1$ 的多项式做 DFT 的时间复杂度为 $T(n)$，则
$$
T(n) = 2T(\frac{n}{2}) + O(n)
$$
根据主定理
$$
T(n) = O(n \log n)
$$


## Implementation
### Recursive
上述两种计算方式均可以使用递归实现，这里直接给出代码，不再赘述。

#### DIF

```cpp
const double PI = acos(-1.0);
void dft(std::vector<Complex> &a) {
  int n = a.size(), m = n >> 1;
  if (n == 1) return;
  std::vector<Complex> p(m), q(m);
  for (int i = 0; i < m; i++) {
    p[i] = a[i] + a[i + m];
    q[i] = (a[i] - a[i + m]) * Complex(cos(2 * PI * i / n), sin(2 * PI * i / n));
  }
  dft(p), dft(q);
  for (int i = 0; i < m; i++)
    a[i << 1] = p[i], a[i << 1 | 1] = q[i];
}
void idft(std::vector<Complex> &a) {
  dft(a);
  for (auto &v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
```

#### DIT

```cpp
const double PI = acos(-1.0);
void dft(std::vector<Complex> &a) {
  int n = a.size(), m = n >> 1;
  if (n == 1) return;
  std::vector<Complex> p(m), q(m);
  for (int i = 0; i < m; i++) {
    p[i] = a[i << 1];
    q[i] = a[i << 1 | 1];
  }
  dft(p), dft(q);
  for (int i = 0; i < m; i++) {
    Complex &u = p[i], v = Complex(cos(2 * PI * i / n), sin(2 * PI * i / n)) * q[i];
    a[i] = u + v, a[i + m] = u - v;
  }
}
void idft(std::vector<Complex> &a) {
  dft(a);
  for (auto &v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
```

下面探讨以 **非递归方式** 实现 `DIF` 与 `DIT`。

### Non-recursive
#### DIT
先讲较常用的DIT。
考虑递归的过程：
$$
\begin{aligned}
&0. (a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7)\\
&1. (a_0, a_2, a_4, a_6)(a_1, a_3, a_5, a_7)\\
&2. (a_0, a_4)(a_2, a_6)(a_1, a_5)(a_3, a_7)\\
&3. (a_0)(a_4)(a_2)(a_6)(a_1)(a_5)(a_3)(a_7)\\
&2' (A_{00}, A_{01})(A_{10},A_{11})(A_{00},A_{01})(A_{10}, A_{11})\\
&1' (A_{00}, A_{01}, A_{02}, A_{03})(A_{10}, A_{11}, A_{12}, A_{13})\\
&0' (A_0, A_1, A_2, A_3, A_4, A_5, A_6, A_7)
\end{aligned}
$$

发现 $0 \rightarrow 3$ 只是在重新安排数据位置，并没有修改数据，如果我们能把映射关系找到，那就可以一步到位，直接从 $3$ 开始。

设一个数在第 $i$ 个阶段 $(0 \leq i \leq \log_2n)$ 的位置为 $p_i$，相对位置为 $p_i'$（`相对位置`指它在括号里的位置，例如上面第 $1$ 阶段 $a_1$ 的相对位置为 $0$）。

容易发现
$$
p'_i = p_i \bmod \frac{n}{2^i}
$$
$$
p_{i + 1} = p_{i} - p'_i + 
\begin{cases}
\dfrac{n}{2^{i+1}}+\dfrac{p'_i-1}{2} & p_i' \equiv 1 \pmod 2\\
\dfrac{p'_i}{2} & p_i' \equiv 0 \pmod 2
\end{cases}
$$
如果将 $p_0$ 写成二进制 $\overline{b_4b_3b_2b_1b_0}$（这里以 $n = 32$ 为例），那么单次变化的过程相当于把二进制的后几位 `rotate` 一位，总的变化过程可以描述为：
$$
\begin{aligned}
\overline{|b_4b_3b_2b_1b_0} \rightarrow \overline{|b_0b_4b_3b_2b_1} \\
\overline{b_0|b_4b_3b_2b_1} \rightarrow \overline{b_0|b_1b_4b_3b_2} \\
\overline{b_0b_1|b_4b_3b_2} \rightarrow \overline{b_0b_1|b_2b_4b_3} \\
\overline{b_0b_1b_2|b_4b_3} \rightarrow \overline{b_0b_1b_2|b_3b_4} \\
\overline{b_0b_1b_2b_3|b_4} \rightarrow \overline{b_0b_1b_2b_3|b_4}
\end{aligned}
$$
可以发现，整个过程实际上是在做 `bit-reverse` 操作！ 

至此我们找到了映射关系，成功把前面的步骤都砍掉了，只剩回溯，可以改成循环。

```cpp
void dft(std::vector<Complex> &a) {
  int n = a.size();
  for (int i = 0, j = 0; i < n; i++) {
    if (i > j) std::swap(a[i], a[j]);
    for (int k = n >> 1; (j ^= k) < k; k >>= 1);
  }
  for (int k = 1; k < n; k <<= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        auto t = a[i + j + k] * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j + k] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
      }
    }
  }
}
```

#### DIF

这里先将DIF的过程简单复述：

**第一步：将序列 $a$ 对半分**
$$
\begin{aligned}
&p_k=a_k+a_{k+n/2}, &P(x) = \sum_{k = 0}^{n/2-1}p_kx^k\\
&q_k=\omega_{n}^k(a_k-a_{k+n/2}), &Q(x) = \sum_{k=0}^{n/2-1}q_kx^k
\end{aligned}
$$
**第二步：递归计算 $DFT(p), DFT(q)$**
**第三步：重新安排数据位置**
$$
\begin{aligned}
A\left(\omega_n^{2r}\right) &= P(\omega_{n/2}^r)\\
A\left(\omega_n^{2r+1}\right) &= Q(\omega_{n/2}^r)
\end{aligned}
$$
发现回溯的过程（即第三步）实际上也只是在重新安排数据存储的位置，而且是上面 DIT 第一步的逆过程，所以就是位反转的逆过程，所以还是位反转。

所以最后安排数据位置可以一步搞定，只剩递归压栈的过程，可以改成循环。

```cpp
void dft(vector<Complex> &a) {
  int n = a.size();
  for (int k = n >> 1; k; k >>= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        auto t = a[i + j + k];
        a[i + j + k] = (a[i + j] - t) * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j] = a[i + j] + t;
      }
    }
  }
  for (int i = 0, j = 0; i < n; i++) {
    if (i > j) std::swap(a[i], a[j]);
    for (int k = n >> 1; (j ^= k) < k; k >>= 1);
  }
}
```

### Combination

发现 DIF 的最后一步和 DIT 的第一步都是位反转，所以先 DIF 再 DIT，就可以省略位反转。

完整代码

```cpp
#include <bits/stdc++.h>

template <class T>
inline void readInt(T &w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == '-';
  for (w = c & 15; isdigit(c = getchar());) w = w * 10 + (c & 15);
  if (p) w = -w;
}

struct Complex {
  double a, b; // a + bi
  Complex(double a = 0, double b = 0): a(a), b(b) {}
};
inline Complex operator+(const Complex &p, const Complex &q) {
  return Complex(p.a + q.a, p.b + q.b);
}
inline Complex operator-(const Complex &p, const Complex &q) {
  return Complex(p.a - q.a, p.b - q.b);
}
inline Complex operator*(const Complex &p, const Complex &q) {
  return Complex(p.a * q.a - p.b * q.b, p.a * q.b + p.b * q.a);
}

const double PI = acos(-1.0);
void dft(std::vector<Complex> &a) {
  int n = a.size();
  for (int k = n >> 1; k; k >>= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        auto t = a[i + j + k];
        a[i + j + k] = (a[i + j] - t) * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j] = a[i + j] + t;
      }
    }
  }
}
void idft(std::vector<Complex> &a) {
  int n = a.size();
  for (int k = 1; k < n; k <<= 1) {
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        auto t = a[i + j + k] * Complex(cos(PI * j / k), sin(PI * j / k));
        a[i + j + k] = a[i + j] - t;
        a[i + j] = a[i + j] + t;
      }
    }
  }
  for (auto &v: a) v.a /= a.size(), v.b /= a.size();
  std::reverse(a.begin() + 1, a.end());
}
int main() {
  int n, m, k;
  readInt(n), readInt(m);
  k = 1 << std::__lg(n + m) + 1;
  std::vector<Complex> a(k), b(k), c(k);
  for (int i = 0; i <= n; i++) readInt(a[i].a);
  for (int i = 0; i <= m; i++) readInt(b[i].a);
  dft(a), dft(b);
  for (int i = 0; i < k; i++) c[i] = a[i] * b[i];
  idft(c);
  for (int i = 0; i <= n + m; i++) printf("%d ", (int)(c[i].a + 0.5));
  return 0;
}
```

## Number Theory Transform

如果一个质数存在 $2^n$ 次单位根，那么在这个质数的剩余系下上面的结论依旧成立，可以使用FFT，多称这种FFT为`快速数论变换(Number Theory Transform, NTT)`。

质数 $P$ 的 $2^n$ 次单位根可以通过它的原根计算出来。

最常见的质数是 $P = 998244353$，它的原根 $g = 3$。

下面是常用 NTT 模数的质数和原根表：

<table>
    <tr>
    <td>周期 $n$</td>
    <td>素数 $p$</td>
    <td>(原始根)</td>
    <td>$z$ ($z^n = 1$)</td>
    <td>$p-1$ の素因数分解</td>
    </tr>
    <tr>
    <td>2<sup>26</sup></td>
    <td>469762049</td>
    <td>3</td>
    <td>2187</td>
    <td>2<sup>26</sup> * 7</td>
    </tr>
    <tr>
    <td>2<sup>25</sup></td>
    <td>167772161</td>
    <td>3</td>
    <td>243</td>
    <td>2<sup>25</sup> * 5</td>
    </tr>
    <tr>
    <td>2<sup>24</sup></td>
    <td>754974721</td>
    <td>11</td>
    <td>739831874</td>
    <td>2<sup>24</sup> * 3<sup>2</sup> * 5</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>377487361</td>
    <td>7</td>
    <td>48510621</td>
    <td>2<sup>23</sup> * 3<sup>2</sup> * 5</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>595591169</td>
    <td>3</td>
    <td>361399025</td>
    <td>2<sup>23</sup> * 71</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>645922817</td>
    <td>3</td>
    <td>224270701</td>
    <td>2<sup>23</sup> * 7 * 11</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>880803841</td>
    <td>26</td>
    <td>273508579</td>
    <td>2<sup>23</sup> * 3 * 5 * 7</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>897581057</td>
    <td>3</td>
    <td>872686320</td>
    <td>2<sup>23</sup> * 107</td>
    </tr>
    <tr>
    <td>2<sup>23</sup></td>
    <td>998244353</td>
    <td>3</td>
    <td>15311432</td>
    <td>2<sup>23</sup> * 7 * 17</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>104857601</td>
    <td>3</td>
    <td>39193363</td>
    <td>2<sup>22</sup> * 5<sup>2</sup></td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>113246209</td>
    <td>7</td>
    <td>58671006</td>
    <td>2<sup>22</sup> * 3<sup>3</sup></td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>138412033</td>
    <td>5</td>
    <td>99040867</td>
    <td>2<sup>22</sup> * 3 * 11</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>155189249</td>
    <td>6</td>
    <td>14921912</td>
    <td>2<sup>22</sup> * 37</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>163577857</td>
    <td>23</td>
    <td>121532577</td>
    <td>2<sup>22</sup> * 3 * 13</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>230686721</td>
    <td>6</td>
    <td>71750113</td>
    <td>2<sup>22</sup> * 5 * 11</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>415236097</td>
    <td>5</td>
    <td>73362476</td>
    <td>2<sup>22</sup> * 3<sup>2</sup> * 11</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>666894337</td>
    <td>5</td>
    <td>147340140</td>
    <td>2<sup>22</sup> * 3 * 53</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>683671553</td>
    <td>3</td>
    <td>236932120</td>
    <td>2<sup>22</sup> * 163</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>918552577</td>
    <td>5</td>
    <td>86995699</td>
    <td>2<sup>22</sup> * 3 * 73</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>935329793</td>
    <td>3</td>
    <td>86363943</td>
    <td>2<sup>22</sup> * 223</td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>943718401</td>
    <td>7</td>
    <td>754500478</td>
    <td>2<sup>22</sup> * 3<sup>2</sup> * 5<sup>2</sup></td>
    </tr>
    <tr>
    <td>2<sup>22</sup></td>
    <td>985661441</td>
    <td>3</td>
    <td>79986183</td>
    <td>2<sup>22</sup> * 5 * 47</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>111149057</td>
    <td>3</td>
    <td>60767546</td>
    <td>2<sup>21</sup> * 53</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>132120577</td>
    <td>5</td>
    <td>102376994</td>
    <td>2<sup>21</sup> * 3<sup>2</sup> * 7</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>136314881</td>
    <td>3</td>
    <td>2981173</td>
    <td>2<sup>21</sup> * 5 * 13</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>169869313</td>
    <td>5</td>
    <td>143354861</td>
    <td>2<sup>21</sup> * 3<sup>4</sup></td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>186646529</td>
    <td>3</td>
    <td>88383805</td>
    <td>2<sup>21</sup> * 89</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>199229441</td>
    <td>3</td>
    <td>174670364</td>
    <td>2<sup>21</sup> * 5 * 19</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>211812353</td>
    <td>3</td>
    <td>113852926</td>
    <td>2<sup>21</sup> * 101</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>249561089</td>
    <td>3</td>
    <td>61724276</td>
    <td>2<sup>21</sup> * 7 * 17</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>257949697</td>
    <td>5</td>
    <td>186470816</td>
    <td>2<sup>21</sup> * 3 * 41</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>270532609</td>
    <td>22</td>
    <td>74891632</td>
    <td>2<sup>21</sup> * 3 * 43</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>274726913</td>
    <td>3</td>
    <td>255478716</td>
    <td>2<sup>21</sup> * 131</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>383778817</td>
    <td>5</td>
    <td>324881819</td>
    <td>2<sup>21</sup> * 3 * 61</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>387973121</td>
    <td>6</td>
    <td>124477810</td>
    <td>2<sup>21</sup> * 5 * 37</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>459276289</td>
    <td>11</td>
    <td>238723101</td>
    <td>2<sup>21</sup> * 3 * 73</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>463470593</td>
    <td>3</td>
    <td>428228038</td>
    <td>2<sup>21</sup> * 13 * 17</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>576716801</td>
    <td>6</td>
    <td>153098993</td>
    <td>2<sup>21</sup> * 5<sup>2</sup> * 11</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>597688321</td>
    <td>11</td>
    <td>395834143</td>
    <td>2<sup>21</sup> * 3 * 5 * 19</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>635437057</td>
    <td>11</td>
    <td>171402456</td>
    <td>2<sup>21</sup> * 3 * 101</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>639631361</td>
    <td>6</td>
    <td>432237000</td>
    <td>2<sup>21</sup> * 5 * 61</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>648019969</td>
    <td>17</td>
    <td>592437138</td>
    <td>2<sup>21</sup> * 3 * 103</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>710934529</td>
    <td>17</td>
    <td>69533131</td>
    <td>2<sup>21</sup> * 3 * 113</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>715128833</td>
    <td>3</td>
    <td>355872337</td>
    <td>2<sup>21</sup> * 11 * 31</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>740294657</td>
    <td>3</td>
    <td>237508734</td>
    <td>2<sup>21</sup> * 353</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>786432001</td>
    <td>7</td>
    <td>228383098</td>
    <td>2<sup>21</sup> * 3 * 5<sup>3</sup></td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>799014913</td>
    <td>13</td>
    <td>374051146</td>
    <td>2<sup>21</sup> * 3 * 127</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>824180737</td>
    <td>5</td>
    <td>133412682</td>
    <td>2<sup>21</sup> * 3 * 131</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>899678209</td>
    <td>7</td>
    <td>118485495</td>
    <td>2<sup>21</sup> * 3 * 11 * 13</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>924844033</td>
    <td>5</td>
    <td>44009197</td>
    <td>2<sup>21</sup> * 3<sup>2</sup> * 7<sup>2</sup></td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>950009857</td>
    <td>7</td>
    <td>741494216</td>
    <td>2<sup>21</sup> * 3 * 151</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>962592769</td>
    <td>7</td>
    <td>695637473</td>
    <td>2<sup>21</sup> * 3<sup>3</sup> * 17</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>975175681</td>
    <td>17</td>
    <td>518451017</td>
    <td>2<sup>21</sup> * 3 * 5 * 31</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>1004535809</td>
    <td>3</td>
    <td>702606812</td>
    <td>2<sup>21</sup> * 479</td>
    </tr>
    <tr>
    <td>2<sup>21</sup></td>
    <td>1012924417</td>
    <td>5</td>
    <td>673144645</td>
    <td>2<sup>21</sup> * 3 * 7 * 23</td>
    </tr>
</table>

代码（预处理单位根，较好地平衡了代码复杂度和常数且有一定的封装度）：

```cpp
#include <bits/stdc++.h>
template <class T>
inline void readInt(T &w) {
  char c, p = 0;
  while (!isdigit(c = getchar())) p = c == '-';
  for (w = c & 15; isdigit(c = getchar());) w = w * 10 + (c & 15);
  if (p) w = -w;
}
template <class T, class... U>
inline void readInt(T &w, U &... a) { readInt(w), readInt(a...); }

constexpr int P(998244353), G(3);
inline void inc(int &x, int y) { (x += y) >= P ? x -= P : 0; }
inline int sum(int x, int y) { return x + y >= P ? x + y - P : x + y; }
inline int sub(int x, int y) { return x - y < 0 ? x - y + P : x - y; }
inline int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k >>= 1, x = 1LL * x * x % P)
    if (k & 1) r = 1LL * r * x % P;
  return r;
}


namespace Polynomial {
using Polynom = std::vector<int>;
int n;
std::vector<int> w;
void getOmega(int k) {
  w.resize(k);
  w[0] = 1;
  int base = fpow(G, (P - 1) / (k << 1));
  for (int i = 1; i < k; i++) w[i] = 1LL * w[i - 1] * base % P;
}
void dft(Polynom &a) {
  for (int k = n >> 1; k; k >>= 1) {
    getOmega(k);
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int y = a[i + j + k];
        a[i + j + k] = (1LL * a[i + j] - y + P) * w[j] % P;
        inc(a[i + j], y);
      }
    }
  }
}
void idft(Polynom &a) {
  for (int k = 1; k < n; k <<= 1) {
    getOmega(k);
    for (int i = 0; i < n; i += k << 1) {
      for (int j = 0; j < k; j++) {
        int x = a[i + j], y = 1LL * a[i + j + k] * w[j] % P;
        a[i + j] = sum(x, y);
        a[i + j + k] = sub(x, y);
      }
    }
  }
  int inv = fpow(n);
  for (int i = 0; i < n; i++) a[i] = 1LL * a[i] * inv % P;
  std::reverse(a.begin() + 1, a.end());
}
} // namespace Polynom
using Polynomial::dft;
using Polynomial::idft;
void poly_multiply(unsigned *A, int n, unsigned *B, int m, unsigned *C) {
  int k = Polynomial::n = 1 << std::__lg(n + m) + 1;
  std::vector<int> a(k), b(k);
  for (int i = 0; i <= n; i++) a[i] = A[i];
  for (int i = 0; i <= m; i++) b[i] = B[i];
  dft(a), dft(b);
  for (int i = 0; i < k; i++) a[i] = 1LL * a[i] * b[i] % P;
  idft(a);
  for (int i = 0; i <= n + m; i++) C[i] = a[i];
}
int main() {
  int n, m, k;
  readInt(n, m);
  Polynomial::n = k = 1 << std::__lg(n + m) + 1;
  std::vector<int> a(k), b(k);
  for (int i = 0; i <= n; i++) readInt(a[i]);
  for (int i = 0; i <= m; i++) readInt(b[i]);
  dft(a), dft(b);
  for (int i = 0; i < k; i++) a[i] = 1LL * a[i] * b[i] % P;
  idft(a);
  for (int i = 0; i <= n + m; i++) printf("%d ", a[i]);
  return 0;
}

```


## 常数优化

### 求系数为整数的多项式乘积 $A(x)B(x)$

$$
\begin{aligned}
P(x) &= A(x)+ iB(x)\\
P^2(x) &= A^2(x) -B^2(x) + i2A(x)B(x)\\
A(x)B(x) &= \frac12\operatorname{Imag}P^2(x) 
\end{aligned}
$$

### 求系数为整数的多项式 $A(x), B(x)$ 的点值表示

$$
\begin{aligned}
P(x) &= A(x)+ iB(x)\\
\overline{P}(x) &= A(x)-iB(x)\\
A(x) &= \frac{P(x) + \overline P (x)}{2}\\
B(x) &= \frac{P(x) - \overline P (x)}{2i}
\end{aligned}
$$

毛爷爷结论：
$$
\overline P(\omega^k) = \overline{P(\omega^{-k})}
$$
所以只要一次DFT。

## 拆系数FFT

### 求 $A(x)B(x)$，系数范围 $[0,2^{30})$


$$
\begin{aligned}
A(x) &= A_0(x)& + &2^{15}A_1(x) &  \\
B(x) &= B_0(x)& + &2^{15}B_1(x) &  \\
A(x)B(x) &= A_0(x)B_0(x)& + &2^{15}(A_0(x)B_1(x) + A_1(x)B_0(x)) + &2^{30}A_1(x)B_1(x)
\end{aligned}
$$


先两次 DFT 求 $A_0, A_1, B_0, B_1$ 的点值表示。

然后两次 IDFT(等价于DFT) 求 $A_0B_0, A_0B_1, A_1B_0, A_1B_1$ 的系数。

## Bluestein’s Algorithm

上面提到的 FFT 算法虽然限制了 $n$ 为 2 的次幂，但在大多数情况下已经足够解决问题。

对于更一般的 $n$ 需要用到 `Bluestein’s Algorithm` ，可以参考2016年国家集训队论文《再探快速傅里叶变换——毛啸》。

后续可能会填这个坑。
                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2022-07-05</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="/post/%E6%9D%8E%E8%B6%85%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8Cset%E7%BB%B4%E6%8A%A4%E5%87%B8%E5%8C%85/">
			下回<br>李超线段树和set维护凸包
                </a>
                
                
                
                <a class="older-posts" href="/post/codeforces1148h-holy-diver/">
			上回<br>[Codeforces1148H] Holy Diver
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                










            </div>
        </div>
    </div>


                    </div>
            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://risehere.net/">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	
</div>
            </div>
    
    <script src="/js/journal.js"></script>
    </body>
</html>
