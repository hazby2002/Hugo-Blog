<!DOCTYPE html>
<html><head>
<title>位运算卷积(FWT) &amp; 集合幂级数</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="转载自 cmd_block https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">











<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>






<link rel="stylesheet" href="https://blog.asukakyle.top/scss/journal.min.dce5c5bb78c91c68b144b286629d241f6f49f433651635b0f41835f578e63bfe.css" integrity="sha256-3OXFu3jJHGixRLKGYp0kH29J9DNlFjWw9Bg19XjmO/4=" media="screen">



<script src="https://blog.asukakyle.top/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>


<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]], [["\\(", "\\)"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\\[", "\\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    MathJax.Hub.Queue(function () {
      
      
      
      var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

<style>
  code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
  }
</style>

<link href="https://cdn.bootcss.com/highlight.js/10.6.0/styles/atom-one-dark.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/highlight.js/10.6.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


  
    <script src="https://blog.asukakyle.top/js/toc-collapse.js"></script>
  










</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://blog.asukakyle.top">
    
        <div class="nav-title">
            HolyK&#39;s Blog
        </div>
        
        <div class="nav-subtitle">
            明日は明日の風が吹く
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/post">
                Archive
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                Categories
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                Tags
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/friend">
                Friends
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x01.fwt-%e6%a6%82%e8%ae%ba" onclick="onNavClick(`#x01.fwt-概论-nav`)" id="x01.fwt-概论-nav">
									0x01.FWT 概论
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x02.%e5%9f%ba%e7%a1%80%e4%bd%8d%e8%bf%90%e7%ae%97%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#x02.基础位运算卷积-nav`)" id="x02.基础位运算卷积-nav">
									0x02.基础位运算卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#or-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#or-卷积-nav`)" id="or-卷积-nav">
									1.1 Or 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#and-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#and-卷积-nav`)" id="and-卷积-nav">
									1.2 And 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#xor-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#xor-卷积-nav`)" id="xor-卷积-nav">
									1.3 Xor 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#x03.rm-fwt-%e5%8f%98%e6%8d%a2%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%a7%e8%b4%a8" onclick="onNavClick(`#x03.rm-fwt-变换的一些性质-nav`)" id="x03.rm-fwt-变换的一些性质-nav">
									0x03.\(\rm FWT\) 变换的一些性质
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x04.%e4%bd%8d%e5%80%bc%e5%9f%9f%e7%9a%84%e6%89%a9%e5%b1%95" onclick="onNavClick(`#x04.位值域的扩展-nav`)" id="x04.位值域的扩展-nav">
									0x04.位值域的扩展
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8f%96-bf-max" onclick="onNavClick(`#每一维取-bf-max-nav`)" id="每一维取-bf-max-nav">
									每一维取 \(\bf max\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8f%96-bf-min" onclick="onNavClick(`#每一维取-bf-min-nav`)" id="每一维取-bf-min-nav">
									每一维取 \(\bf min\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8a%a0%e8%b5%b7%e6%9d%a5-bf-mod-k" onclick="onNavClick(`#每一维加起来-bf-mod-k-nav`)" id="每一维加起来-bf-mod-k-nav">
									每一维加起来 \(\bf mod\ k\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#x04.%e5%ad%90%e9%9b%86%e5%8d%b7%e7%a7%af-%e9%9b%86%e5%90%88%e5%b9%82%e7%ba%a7%e6%95%b0" onclick="onNavClick(`#x04.子集卷积-集合幂级数-nav`)" id="x04.子集卷积-集合幂级数-nav">
									0x04.子集卷积 &amp; 集合幂级数
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/post">
                    Archive
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    Categories
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    Tags
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/friend">
                    Friends
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x01.fwt-%e6%a6%82%e8%ae%ba" onclick="onNavClick(`#x01.fwt-概论-nav`)" id="x01.fwt-概论-nav">
									0x01.FWT 概论
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x02.%e5%9f%ba%e7%a1%80%e4%bd%8d%e8%bf%90%e7%ae%97%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#x02.基础位运算卷积-nav`)" id="x02.基础位运算卷积-nav">
									0x02.基础位运算卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#or-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#or-卷积-nav`)" id="or-卷积-nav">
									1.1 Or 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#and-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#and-卷积-nav`)" id="and-卷积-nav">
									1.2 And 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#xor-%e5%8d%b7%e7%a7%af" onclick="onNavClick(`#xor-卷积-nav`)" id="xor-卷积-nav">
									1.3 Xor 卷积
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#x03.rm-fwt-%e5%8f%98%e6%8d%a2%e7%9a%84%e4%b8%80%e4%ba%9b%e6%80%a7%e8%b4%a8" onclick="onNavClick(`#x03.rm-fwt-变换的一些性质-nav`)" id="x03.rm-fwt-变换的一些性质-nav">
									0x03.\(\rm FWT\) 变换的一些性质
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#x04.%e4%bd%8d%e5%80%bc%e5%9f%9f%e7%9a%84%e6%89%a9%e5%b1%95" onclick="onNavClick(`#x04.位值域的扩展-nav`)" id="x04.位值域的扩展-nav">
									0x04.位值域的扩展
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								<ul class="collapse" data-toggle="collapse">
							
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8f%96-bf-max" onclick="onNavClick(`#每一维取-bf-max-nav`)" id="每一维取-bf-max-nav">
									每一维取 \(\bf max\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8f%96-bf-min" onclick="onNavClick(`#每一维取-bf-min-nav`)" id="每一维取-bf-min-nav">
									每一维取 \(\bf min\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
						
						
						
							<li>
								<a href="#%e6%af%8f%e4%b8%80%e7%bb%b4%e5%8a%a0%e8%b5%b7%e6%9d%a5-bf-mod-k" onclick="onNavClick(`#每一维加起来-bf-mod-k-nav`)" id="每一维加起来-bf-mod-k-nav">
									每一维加起来 \(\bf mod\ k\)
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#x04.%e5%ad%90%e9%9b%86%e5%8d%b7%e7%a7%af-%e9%9b%86%e5%90%88%e5%b9%82%e7%ba%a7%e6%95%b0" onclick="onNavClick(`#x04.子集卷积-集合幂级数-nav`)" id="x04.子集卷积-集合幂级数-nav">
									0x04.子集卷积 &amp; 集合幂级数
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://blog.asukakyle.top">
            HolyK&#39;s Blog
        </a>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://blog.asukakyle.top">
        <div class="single-column-header-title">HolyK&#39;s Blog</div>
        
        <div class="single-column-header-subtitle">明日は明日の風が吹く</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                
            >
                <div class="post-title">
                    位运算卷积(FWT) &amp; 集合幂级数
                    
                    <div class="post-subtitle">
                        转载自 cmd_block https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan
                    </div>
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-07-09 11:21
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/">[算法笔记]</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/fwt">fwt</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <h2 id="x01.fwt-概论">0x01.FWT 概论</h2>
<ul>
<li><p><strong>位运算卷积</strong> 众所周知，多项式乘法是加法卷积, 因为第 <span class="math inline">\({i}\)</span> 项和第 <span class="math inline">\({j}\)</span> 项的乘积贡献到第 <span class="math inline">\({i+j}\)</span> 项。</p>
<p>类似地定义位运算卷积 : <span class="math inline">\({}\)</span> 第 <span class="math inline">\({i}\)</span> 项和第 <span class="math inline">\({j}\)</span> 项的乘积贡献到第 <span class="math inline">\({i \oplus j}\)</span> 项。其中 <span class="math inline">\({\oplus}\)</span> 是某种位运算。</p>
<p>即 <span class="math inline">\({S[k]=\sum_{i \oplus j=k} A[i] B[j]}\)</span>, 记作卷积式 <span class="math inline">\({A * B=S}\)</span> 。</p></li>
<li><p><strong>构造的尝试</strong> 众所周知, <span class="math inline">\({\mathrm{FFT}}\)</span> 把多项式转换成点值之后, 从卷积变为了直接点积。</p>
<p>我们自然也期望把位运算卷积转化成点积。</p>
<p>设 <span class="math inline">\({F W T(A)}\)</span> 是幕级数 <span class="math inline">\({A}\)</span> 经过 <span class="math inline">\({\mathrm{FWT}}\)</span> 变换之后得到的幕级数。</p>
<p>我们需要令其满足 : <span class="math inline">\({ A * B=C \Longleftrightarrow F W T(A) \cdot F W T(B)=F W T(C)}\)</span> (点积)。</p>
<p><span class="math inline">\({\mathrm{FFT}}\)</span> 是一个<strong>线性变换</strong>，我们也希望 <span class="math inline">\({\mathrm{FWT}}\)</span> 变换是线性的。 我们还不知道怎么变换，于是设 <span class="math inline">\({c(i, j)}\)</span> 为变换系数, 即 <span class="math inline">\({A[j]}\)</span> 对 <span class="math inline">\({F W T(A)[i]}\)</span> 的贡献系数。</p>
<p>则 <span class="math inline">\({F W T(A)[i]=\sum_{j=0}^{n-1} c(i, j) A_{j}}\)</span></p>
<p>根据 <span class="math inline">\({F W T(A) \cdot F W T(B)=F W T(C)}\)</span>, 得到： <span class="math display">\[
{
\begin{array}{l}
 F W T(A)[i] F W T(B)[i]=F W T(C)[i] \\
\sum_{j=0}^{n-1} c(i, j) A[j] \sum_{k=0}^{n-1} c(i, k) B[k]=\sum_{p=0}^{n-1} c(i, p) C[p] \\
\sum_{j=0}^{n-1} \sum_{k=0}^{n-1} c(i, j) c(i, k) A[j] B[k]=\sum_{p=0}^{n-1} c(i, p) C[p]
\end{array}
}
\]</span></p>
<p>根据 <span class="math inline">\({A * B=C}\)</span>, 又能得到 : <span class="math display">\[
{
C[p]=\sum_{t_{1} \oplus t_{2}=p} A\left[t_{1}\right] B\left[t_{2}\right]
}
\]</span> <span class="math display">\[
\begin{array}{c}
\sum_{p=0}^{n-1} c(i, p) C[p]=\sum_{p=0}^{n-1} c(i, p) \sum_{t_{\oplus} \oplus 2=p} A\left[t_{1}\right] B\left[t_{2}\right] \\
\sum_{j=0}^{n-1} \sum_{k=0}^{n-1} c(i, j) c(i, k) A[j] B[k]=\sum_{p=0}^{n-1} c(i, p) \sum_{t_{1} \oplus t_{2}=p} A\left[t_{1}\right] B\left[t_{2}\right] \\
\sum_{j=0}^{n-1} \sum_{k=0}^{n-1} c(i, j) c(i, k) A[j] B[k]=\sum_{p=0}^{n-1} \sum_{t_{1} \oplus t_{2}=p} A\left[t_{1}\right] B\left[t_{2}\right] c\left(i, t_{1} \oplus t_{2}\right)=\sum_{t_{1}=0}^{n-1} \sum_{t_{2}=0}^{n-1} A\left[t_{1}\right] B\left[t_{2}\right] c\left(i, t_{1} \oplus t_{2}\right)
\end{array}
\]</span> 到左右两边, 得到 <span class="math inline">\({c(i, j) c(i, k)=c(i, j \oplus k)}\)</span>, 只需要满足这个就好了。</p>
<p>另外,由于位于每一位的独立性, <span class="math inline">\({c(i, j)}\)</span> 也有一个重要性质: 可以分位考虑。</p>
<p>假设我们已经(根据真值表)求出满足要求的 <span class="math inline">\({c([0,1],[0,1])}\)</span> ，我们能这样构造出所有的 <span class="math inline">\({c}\)</span> :</p>
<p>设二进制数 <span class="math inline">\({a}\)</span> 的每一位分别为 : <span class="math inline">\({a_{0}, a_{1}, a_{2} \ldots}\)</span></p>
<p>则有 <span class="math inline">\({c(i, j)=c\left(i_{0}, j_{0}\right) c\left(i_{1}, j_{1}\right) c\left(i_{2}, j_{2}\right) \ldots}\)</span>, 就是<strong>把每一位的变换系数乘起来</strong>。</p>
<p>那么: 对于每个 <span class="math inline">\({t}\)</span>, 部 <span class="math inline">\({c\left(i_{t}, j_{t}\right) c\left(i_{t}, k_{t}\right)=c\left(i_{t}, j_{t} \oplus k_{t}\right) \Longleftrightarrow c(i, j) c(i, k)=c(i, j \oplus k)}\)</span></p>
<p>这就符合我们的条件。</p>
<p>好了,现在假设我们已经有了符合要求的 <span class="math inline">\({c}\)</span>,如何快速求解 <span class="math inline">\({\mathrm{FWT}}\)</span> 变换呢?</p>
<p><span class="math inline">\({F W T(A)[i]=\sum_{j=0}^{n-1} c(i, j) A[j]}\)</span></p>
<p>根据这个式子直接求和,复杂度至少是 <span class="math inline">\({O\left(n^{2}\right)}\)</span> 的,并没有起到优化作用。</p>
<p>我们考虑<strong>按位拆半</strong>：</p>
<p><span class="math inline">\({=\sum_{j=0}^{(n / 2)-1} c(i, j) A[j]+\sum_{j=(n / 2)}^{n-1} c(i, j) A[j]}\)</span></p>
<p>设 <span class="math inline">\({i{\prime}}\)</span> 为 <span class="math inline">\({i}\)</span> 去掉二进制首位剩下的数。</p>
<p>在首位分开考虑 :</p>
<p><span class="math inline">\({=\sum_{j=0}^{(n / 2)-1} c\left(i_{0}, j_{0}\right) c\left(i{\prime}, j{\prime}\right) A[j]+\sum_{j=(n / 2)}^{n-1} c\left(i_{0}, j_{0}\right) c\left(i{\prime}, j{\prime}\right) A[j]}\)</span> <span class="math inline">\({=c\left(i_{0}, 0\right) \sum_{j=0}^{(n / 2)-1} c\left(i{\prime}, j{\prime}\right) A[j]+c\left(i_{0}, 1\right) \sum_{j=(n / 2)}^{n-1} c\left(i{\prime}, j{\prime}\right) A[j]}\)</span></p>
<p>考虑到 <span class="math inline">\({c\left(i{\prime}, j{\prime}\right)}\)</span> 就是去掉最高位的子变换这里规模减半了。</p>
<p>设 <span class="math inline">\({A_{0}}\)</span> 为幕级数下标首位为 0 的部分类似地有 <span class="math inline">\({A_{1}}\)</span> 。</p>
<p>若 <span class="math inline">\({i_{0}=0}\)</span>, 则有：</p>
<p><span class="math inline">\({F W T(A)[i]=c(0,0) F W T\left(A_{0}\right)[i]+c(0,1) F W T\left(A_{1}\right)[i] (i \in[0, n / 2))}\)</span></p>
<p>若 <span class="math inline">\({i_{0}=1}\)</span>, 则有：</p>
<p><span class="math inline">\({F W T(A)[i+(n / 2)]=c(1,0) F W T\left(A_{0}\right)[i]+c(1,1) F W T\left(A_{1}\right)[i] (i \in[0, n / 2))}\)</span></p>
<p>我们就能以 <span class="math inline">\({O(n)}\)</span> 的代价,根据上列式子合并两个规模为 <span class="math inline">\({n / 2}\)</span> 的子变换。</p>
<p>所以,若 <span class="math inline">\({n=2^{m}}\)</span>,需要合并 <span class="math inline">\({m}\)</span> 次,复杂度为 <span class="math inline">\({O\left(m 2^{m}\right)}\)</span> 。</p>
<p>(可能有点抽象,但是您如果写过FFT,看到代码就会值了)</p>
<p>此外,逆变换 IFWT 就是对 <span class="math inline">\({c}\)</span> 矩阵求个逆,具体见下文。</p>
<p>( 一个重要的地方是,这个构造出来的 c 矩阵<strong>一定要有逆</strong>,否则就变换不回去TAT )</p></li>
</ul>
<h2 id="x02.基础位运算卷积">0x02.基础位运算卷积</h2>
<p>针对不同的位运算,根据 <span class="math inline">\({c(i, j) c(i, k)=c(i, j \oplus k)}\)</span> 构造出 <span class="math inline">\({c([0,1],[0,1])}\)</span> 即可。</p>
<p>我们把这个矩阵称为<strong>位矩阵</strong>。</p>
<p>构造的过程可能有些繁杂, 可以直接记结论, 或者去后面看扩展版的。</p>
<h3 id="or-卷积">1.1 Or 卷积</h3>
<p>设位矩阵为 <span class="math inline">\(c=\begin{bmatrix}c(0,0)&amp;c(0,1)\\c(1,0)&amp;c(1,1)\end{bmatrix}\)</span></p>
<p><strong>起点</strong> : <span class="math inline">\({c(i, j) c(i, k)=c(i, j | k)}\)</span></p>
<ul>
<li><span class="math inline">\({c(0,0) c(0,0)=c(0,00)}\)</span> <span class="math inline">\({\Rightarrow c(0,0)=1}\)</span> 或 <span class="math inline">\(0\)</span></li>
</ul>
<p>同理不难推知 <span class="math inline">\(c(\_,\_)∈\{0,1\}\)</span></p>
<ul>
<li><span class="math inline">\({c(0,1) c(0,0)=c(0,1 | 0)}\)</span></li>
</ul>
<p><span class="math inline">\({\Rightarrow c(0,1)=0}\)</span> 或 <span class="math inline">\({c(0,0)=c(0,1)=1}\)</span> - <span class="math inline">\({c(1,1) c(1,0)=c(1,1 | 0)}\)</span></p>
<p><span class="math inline">\({\Rightarrow c(1,1)=0}\)</span> 或 <span class="math inline">\({c(1,0)=c(1,1)=1}\)</span></p>
<p>首先,如果有一排0就一列0那么这个矩阵就没有逆,那么可以构造出: 两种情况<span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;0\end{bmatrix}\)</span> 或 <span class="math inline">\(\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix}\)</span>。</p>
<blockquote>
<p><strong>Tips</strong> : <span class="math inline">\(Or\)</span> 卷积的上面第二个矩阵 <span class="math inline">\(FWT\)</span> 相当于子集求和。</p>
<p>原因:第二个矩阵相当于 <span class="math inline">\(c(i,j)=[i\&amp;j=j]\)</span></p>
<p><span class="math inline">\(A&#39;_i=\sum\limits_{i\&amp;j=j}A_i\)</span>等价于<span class="math inline">\(A&#39;_i=\sum\limits_{j∈i}A_i\)</span>。</p>
<p>(也可以使用高维前缀和来推导)</p>
</blockquote>
<p>(下面采用第二个矩阵)</p>
<p><span class="math inline">\(FWT(A)[i]=FWT(A_0)[i]\)</span></p>
<p><span class="math inline">\(FWT(A)[i+(n/2)]=FWT(A_0)[i]+FWT(A_1)[i]\)</span></p>
<p>对于逆变换,把矩阵求个逆可得 <span class="math inline">\(\begin{bmatrix}1&amp;0\\-1&amp;1\end{bmatrix}\)</span>。</p>
<p><span class="math inline">\(IFWT(A)[i]=IFWT(A_0)[i]\)</span></p>
<p><span class="math inline">\(IFWT(A)[i+(n/2)]=IFWT(A_1)[i]-IFWT(A_0)[i]\)</span></p>
<h3 id="and-卷积">1.2 And 卷积</h3>
<p>起点 : <span class="math inline">\(c(i,j)c(i,k)=c(i,j\&amp;k)\)</span>。</p>
<p>同上,容易得到 <span class="math inline">\(c(\_,\_)∈\{0,1\}\)</span>。 - <span class="math inline">\(c(0,1)c(0,0)=c(0,1\&amp;0)\)</span> <span class="math inline">\(\Rightarrow c(0,0)=0\)</span> 或 <span class="math inline">\(c(0,0)=c(0,1)=1\)</span> - <span class="math inline">\(c(1,1)c(1,0)=c(1,1\&amp;0)\)</span> <span class="math inline">\(\Rightarrow c(1,0)=0\)</span> 或 <span class="math inline">\(c(1,0)=c(1,1)=1\)</span></p>
<p>还是老样子,如果有一排 <span class="math inline">\(0\)</span> 或者一列 <span class="math inline">\(0\)</span> 那么这个矩阵就没有逆,那么可 以构造出:</p>
<p>两种情况 : <span class="math inline">\(\begin{bmatrix}0&amp;1\\1&amp;1\end{bmatrix}\)</span> 或 <span class="math inline">\(\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}\)</span>,下面采用第二种。</p>
<p><span class="math inline">\(FWT(A)[i]=FWT(A_0)[i]+FWT(A_1)[i]\)</span></p>
<p><span class="math inline">\(FWT(A)[i+(n/2)]=FWT(A_1)[i]\)</span></p>
<p>把矩阵求个逆可得<span class="math inline">\(\begin{bmatrix}1&amp;-1\\0&amp;1\end{bmatrix}\)</span>:</p>
<p><span class="math inline">\(IFWT(A)[i]=IFWT(A_0)[i]-IFWT(A_1)[i]\)</span></p>
<p><span class="math inline">\(IFWT(A)[i+(n/2)]=IFWT(A_1)[i]\)</span></p>
<h3 id="xor-卷积">1.3 Xor 卷积</h3>
<p>起点 : <span class="math inline">\(c(i,j)c(i,k)=c(i,j\ \text{xor}\ k)\)</span></p>
<ul>
<li>对于任意的 <span class="math inline">\(x,y\)</span> ,均有 <span class="math inline">\(c(0,0)c(x,y)=c(x,y\ \text{xor}\ 0)=c(x,y)\)</span> <span class="math inline">\(\Rightarrow c(0,0)=1\)</span>.</li>
<li><span class="math inline">\(c(1,1)c(1,1)=c(1,0)\)</span> 此时若 <span class="math inline">\(c(1,1)=c(1,0)=0\)</span>,则一行为 <span class="math inline">\(0\)</span> ,矩阵无逆。 所以 <span class="math inline">\(c(1,1),c(1,0)\)</span> 必然都非 <span class="math inline">\(0\)</span>。</li>
<li><span class="math inline">\(c(1,0)c(1,1)=c(1,1)\)</span> 刚才说<span class="math inline">\(c(1,1)\)</span> 非 <span class="math inline">\(0\)</span>,所以此处 <span class="math inline">\(c(1,0)\)</span> 一定是1.</li>
<li><span class="math inline">\(c(0,1)c(0,1)=c(0,0)\)</span> <span class="math inline">\(\Rightarrow c(0,1)∈\{-1,1\}\)</span></li>
</ul>
<p>两种情况 : <span class="math inline">\(\begin{bmatrix}1&amp;1\\-1&amp;1\end{bmatrix}\)</span> 或</p>
<p><span class="math inline">\(\begin{bmatrix}1&amp;1\\1&amp;-1\end{bmatrix}\)</span> ,下面采用第二种。</p>
<p>附 ：不难观察出 <span class="math inline">\(c(i,j)=(-1)^{|i\&amp;j|}\)</span></p>
<p><span class="math inline">\(FWT(A)_i=FWT(A_0)_i+FWT(A_1)_i\)</span></p>
<p><span class="math inline">\(FWT(A)_{i+(n/2)}=FWT(A_0)_i-FWT(A_1)_{i}\)</span></p>
<p>求逆可得<span class="math inline">\(\begin{bmatrix}0.5&amp;0.5\\0.5&amp;-0.5\end{bmatrix}\)</span></p>
<p><span class="math inline">\(IFWT(A)_i=\dfrac{IFWT(A_0)_i+IFWT(A_1)_i}{2}\)</span></p>
<p><span class="math inline">\(IFWT(A)_{i+(n/2)}=\dfrac{IFWT(A_0)_i-IFWT(A_1)_i}{2}\)</span></p>
<h2 id="x03.rm-fwt-变换的一些性质">0x03.<span class="math inline">\(\rm FWT\)</span> 变换的一些性质</h2>
<p>前面讲了, <span class="math inline">\(\rm FWT\)</span> 变换的本质是线性变换。</p>
<p>这意味着 <span class="math inline">\(FWT(A+B)=FWT(A)+FWT(B)\)</span> ,且 <span class="math inline">\(FWT(cA)=cFWT(A)\)</span></p>
<p>此外,如果需要卷积的向量只有少数非 <span class="math inline">\(0\)</span> 项( <span class="math inline">\(2,3\)</span> 个)可能会有分类讨论的神奇的解法。</p>
<p>例题(<del>我只能做到这些了</del>):</p>
<p><a href="https://www.luogu.org/problem/CF449D">CF449D Jzzhu and Numbers</a> + <a href="https://www.luogu.org/blog/command-block/post-shuo-xue-ji-lu-cf449d-jzzhu-and-numbers">题解Link</a></p>
<p><a href="https://www.luogu.org/problem/CF1119H">CF1119H Triple</a> + <a href="https://www.luogu.org/problemnew/solution/CF1119H">题解Link</a></p>
<p>题做多了再来填坑吧。</p>
<h2 id="x04.位值域的扩展">0x04.位值域的扩展</h2>
<p>其实<strong>位运算的本质</strong>是对一个 <span class="math inline">\(n\)</span> 维 <span class="math inline">\(01\)</span> 向量的运算。</p>
<p>或运算就是每一维取 <span class="math inline">\(\max\)</span>。且运算就是每一维取 <span class="math inline">\(min\)</span>。</p>
<p>异或运算则是每一维对应相加再 <span class="math inline">\(\bmod\ 2\)</span>。</p>
<p>位运算有个特点 : 向量的每一位都是独立的。我们把<span class="math inline">\(\{0,1\}\)</span>扩展到 <span class="math inline">\([0,k)∩Z\)</span> 也就是扩展到 <span class="math inline">\(k\)</span> 进制，看看会得到什么？</p>
<h3 id="每一维取-bf-max">每一维取 <span class="math inline">\(\bf max\)</span></h3>
<p>对应原来的按位 <span class="math inline">\(\rm or\)</span>。可得 <span class="math inline">\(c(x,y)c(x,y)=c(x,max(y,y))=c(x,y)\)</span></p>
<p>所以整个矩阵中只有 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span>。</p>
<p>又可得 <span class="math inline">\(c(x,y1)c(x,y2)=c(x,max(y1,y2))\)</span></p>
<p>假如有 <span class="math inline">\(c(x,y1)=1,\ c(x,y2)=0\)</span>,可得 <span class="math inline">\(c(x,y1)c(x,y2)=c(x,max(y1,y2))\)</span></p>
<p>又因为 <span class="math inline">\(1*0=0\)</span> 所以 <span class="math inline">\(max(y1,y2)=y2\)</span> ,可得 <span class="math inline">\(y1&lt;y2\)</span>.</p>
<p>也就是说，每一行以内， <span class="math inline">\(1\)</span> 总是在 <span class="math inline">\(0\)</span> 的前面。</p>
<p>接下来，除了矩阵有逆之外,再没有别的要求了。</p>
<p>如果要有逆的话，每一行都必须不同，那么 <span class="math inline">\(1\)</span> 的个数分别就是 <span class="math inline">\(1...n\)</span>,随意排列都可以。</p>
<p>例子 ： <span class="math inline">\(k=4\)</span> 的情形</p>
<p><span class="math inline">\(\begin{bmatrix}1&amp;0&amp;0&amp;0\\1&amp;1&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\1&amp;1&amp;1&amp;1\end{bmatrix}\)</span>或者<span class="math inline">\(\begin{bmatrix}1&amp;1&amp;1&amp;1\\1&amp;0&amp;0&amp;0\\1&amp;1&amp;1&amp;0\\1&amp;1&amp;0&amp;0\end{bmatrix}\)</span>等等<span class="math inline">\(4!\)</span>种。</p>
<p>为了方便,一般取用第一种,求逆可得<span class="math inline">\(\begin{bmatrix}1&amp;0&amp;0&amp;0\\-1&amp;1&amp;0&amp;0\\0&amp;-1&amp;1&amp;0\\0&amp;0&amp;-1&amp;1\end{bmatrix}\)</span></p>
<p>暴力做的话 <span class="math inline">\(O(k^{n+1}n)\)</span>。</p>
<p>这个矩阵本质上就是前缀和和差分……所以可以优化到 <span class="math inline">\(O(k^nn)\)</span>。</p>
<p>(宏观上就是高维前缀和)</p>
<h3 id="每一维取-bf-min">每一维取 <span class="math inline">\(\bf min\)</span></h3>
<p>对应原来的按位 <span class="math inline">\(\rm and\)</span>。</p>
<p>类似的，整个矩阵中只有 <span class="math inline">\(0\)</span> 或 <span class="math inline">\(1\)</span> ,每一行以内, <span class="math inline">\(1\)</span> 总是在 <span class="math inline">\(0\)</span> 的后面。</p>
<p>例子 ： <span class="math inline">\(k=4\)</span> 的情形</p>
<p><span class="math inline">\(\begin{bmatrix}1&amp;1&amp;1&amp;1\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;0&amp;0&amp;1\end{bmatrix}\)</span>或者<span class="math inline">\(\begin{bmatrix}1&amp; 1&amp;1&amp;1\\0&amp;0&amp;1&amp;1\\0&amp;1&amp;1&amp;1\\0&amp;0&amp;0&amp;1\end{bmatrix}\)</span>等等<span class="math inline">\(4!\)</span>种。 为了方便，一般取用第一种,求逆可得<span class="math inline">\(\begin{bmatrix}1&amp;-1&amp;0&amp;0\\0&amp;1&amp;-1&amp;0\\0&amp;0&amp;1&amp;-1\\0&amp;0&amp;0&amp;1\end{bmatrix}\)</span></p>
<p>这个矩阵本质上就是后缀和和差分……同样能优化到 <span class="math inline">\(O(k^nn)\)</span></p>
<p>(宏观上就是高维后缀和)</p>
<h3 id="每一维加起来-bf-mod-k">每一维加起来 <span class="math inline">\(\bf mod\ k\)</span></h3>
<p>对应原来的按位 <span class="math inline">\(\rm xor\)</span>。</p>
<p>这玩意就比较复杂了,需要动用单位根……</p>
<p>我们知道 <span class="math inline">\(c(x,y1)c(x,y2)=c(x,(y1+y2)mod\ k)\)</span></p>
<p><span class="math inline">\(c(x,y)=\omega_k^y\)</span> 就能满足要求：</p>
<p><span class="math inline">\(c(x,y1)c(x,y2)=\omega_k^{y1}\omega_k^{y2}=\omega_k^{(y1+y2)mod\ k}\)</span></p>
<p>但是，每一行都一样的话，矩阵就没有逆。</p>
<p>你会发现直接把 FFT 的范德蒙德矩阵拿来用就好了:</p>
<p><span class="math inline">\(\begin{bmatrix}1&amp; 1 &amp; 1&amp; ... &amp; 1\\ 1&amp; w_k^1&amp; w_k^2&amp; ... &amp; w_k^{k - 1}\\ 1&amp; w_k^2 &amp; w_k^4&amp; ... &amp; w_k^{2(k - 1)}\\ ...&amp; ...&amp; ...&amp; ...&amp; ...\\ 1&amp; w_k^{k - 1}&amp; w_k^{2(k - 1)} &amp; ... &amp; w_k^{(k - 1)(k - 1)}\end{bmatrix}\)</span></p>
<p>逆矩阵我们也知道，那就是:</p>
<p><span class="math inline">\(\dfrac{1}{k}\begin{bmatrix}1&amp; 1 &amp; 1&amp; ... &amp; 1\\ 1&amp; w_k^{-1}&amp; w_k^{-2}&amp; ... &amp; w_k^{-(k - 1)}\\ 1&amp; w_k^{-2} &amp; w_k^{-4}&amp; ... &amp; w_k^{-2(k - 1)}\\ ...&amp; ...&amp; ...&amp;...&amp; ...\\ 1&amp; w_k^{-(k - 1)}&amp; w_k^{-2(k - 1)} &amp; ... &amp; w_k^{-(k - 1)(k - 1)}\end{bmatrix}\)</span></p>
<p>暴力计算显然是 <span class="math inline">\(O(k^{n+1}n)\)</span> 的。</p>
<p>可以使用 <span class="math inline">\(\rm FFT\)</span> 优化到 <span class="math inline">\(O(k^nn\log k)\)</span>。</p>
<p>但是，单位根在模意义很可能不存在。考虑扩充我们“数”的表示。</p>
<p>首先想到的是，人为地定义代数对象 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(x^k=1\)</span> （且 <span class="math inline">\(x\)</span> 的阶恰为 <span class="math inline">\(k\)</span>），用其代替单位根 <span class="math inline">\(w_k\)</span>，不难验证其满足前文构造 矩阵的条件。</p>
<p>此举相当于用 <span class="math inline">\(\pmod{x^{k}-1}\)</span> 下的循环卷积多项式替换了“数”。</p>
<p>我们的位矩阵长这样 ： <span class="math inline">\(C_1=\begin{bmatrix}1&amp; 1 &amp; 1&amp; ... &amp; 1\\ 1&amp; x^1&amp; x^2&amp; ... &amp; x^{k - 1}\\ 1&amp; x^2 &amp; x^4&amp; ... &amp; x^{2(k - 1)}\\ ...&amp; ...&amp; ...&amp; ...&amp; ...\\ 1&amp; x^{k - 1}&amp; x^{2(k - 1)} &amp; ... &amp; x^{(k - 1)(k - 1)}\end{bmatrix}\)</span> <span class="math inline">\(C_2=\dfrac{1}{k}\begin{bmatrix}1&amp; 1 &amp; 1&amp; ... &amp; 1\\ 1&amp; x^{-1}&amp; x^{-2}&amp; ... &amp; x^{-(k - 1)}\\ 1&amp; x^{-2} &amp; x^{-4}&amp; ... &amp; x^{-2(k - 1)}\\ ...&amp; ...&amp; ...&amp; ...&amp; ...\\ 1&amp; x^{-(k - 1)}&amp; x^{-2(k - 1)} &amp; ... &amp; x^{-(k - 1)(k - 1)}\end{bmatrix}\)</span></p>
<p>接下来的推导可能需要抽象代数和高等代数相关知识。详情可见 ： <a href="https://www.luogu.com.cn/blog/command-block/jin-shi-dai-shuo-luan-bian">近世代数乱编</a></p>
<p>问题在于，此时 <span class="math inline">\(\pmod{x^{k}-1}\)</span> 下的循环卷积多项式并不是域，其存在 零因子。</p>
<p>这样就会导致两个位矩阵并非严格互逆。</p>
<p>具体而言，我们原本希望 <span class="math inline">\(C_1*C_2=I\)</span> ,这需要满足 <span class="math inline">\(\sum\limits_{i=0}^{k- 1}C_1[a][i]C_2[i][b]=[a=b]\)</span>。</p>
<p>当 <span class="math inline">\(a=b\)</span> 时，有 <span class="math inline">\(\sum\limits_{i=0}^{n-1}C_1[a][i]C_2[i][a]=\dfrac{1} {k}\sum\limits_{i=0}^{k-1}x^{ai}x^{-ai}=1\)</span> ，这不需要消去律也成立，这部 分贡献是没有差错的。</p>
<p>当 <span class="math inline">\(a≠b\)</span> 时，有 <span class="math inline">\(\sum\limits_{i=0}^{n-1}C_1[a][i]C_2[i][b]=\dfrac{1} {k}\sum\limits_{i=0}^{k-1}x^{ai}x^{-bi}=\dfrac{1}{k}\sum\limits_{i=0}^{k- 1}x^{(a-b)i}\)</span></p>
<p>若 <span class="math inline">\(x\)</span> 的阶恰为 <span class="math inline">\(k\)</span> ，则 <span class="math inline">\(x^{(a-b)}\)</span> 必不为 <span class="math inline">\(1\)</span>。在经典的范德蒙德</p>
<p>矩阵证明中，由此可得上式 <span class="math inline">\(=0\)</span></p>
<p>但是，此时由于无法做除法，等比数列求和公式不再生效，无法证明上式 <span class="math inline">\(=0\)</span>。</p>
<p>但是，仍然恒有 <span class="math inline">\(0=(x^k-1)=(x-1)(1+x+x^2+...+x^k)\)</span> 存在，也就是说，上 面求和的结果虽然可能非 <span class="math inline">\(0\)</span> ，但必然是零因子。</p>
<p>也就是说，我们算得的结果是由 (真实答案)+(零因子的线性组合) 构成 的。</p>
<p>接下来要找到一种合适的扩域方法，这样就能避免零因子问题。</p>
<p>不妨取分圆多项式 <span class="math inline">\(\Phi_k(x)\)</span> ，下面不加证明地给出两个定理 ： （相关知识可见《近世代数乱编》）</p>
<ul>
<li>① 分圆多项式在 <span class="math inline">\(Q\)</span> 上不可约。 这保证了 <span class="math inline">\(\pmod {\Phi_k(x)}\)</span> 意义下的“数”是个域，不存在零因子。 这里注意，还要验证该多项式在 <span class="math inline">\(F_p\)</span> 下是否能够分解，一般情况 下是不能的，此时可以正常使用。 若计算时没有利用 <span class="math inline">\(F_p\)</span> 的性质（如求逆元），则可以看作大整 数计算，最后将答案取模，此时不需要检查 <span class="math inline">\(F_p\)</span> 下是否能够分 解。</li>
<li>② 在 <span class="math inline">\(\pmod {\Phi_k(x)}\)</span> 意义下， <span class="math inline">\(x\)</span> 的阶恰好为 <span class="math inline">\(k\)</span>。 这又保证了我们构造的前提成立。</li>
</ul>
<p>这样，只需在 <span class="math inline">\(\pmod {\Phi_k(x)}\)</span> 下计算，即可得到满足题意的答案。</p>
<p>但是，模多项式的计算较为繁琐，常数较大且不易优化。</p>
<p>而更好的消息是，由于 <span class="math inline">\(\Phi_k(x)|(x^k-1)\)</span> ，则有 <span class="math inline">\(F(x)\bmod \Phi_k(x)=F(x)\bmod (x^k-1)\bmod \Phi_k(x)\)</span></p>
<p>这表明我们可以先用“循环卷积多项式”代替严格的扩域，到最后再对 <span class="math inline">\(\Phi_k(x)\)</span> 取模。</p>
<p>此时任意两个数的乘法就变成 <span class="math inline">\(O(k^2)\)</span> 多项式循环卷积，复杂度升高了 <span class="math inline">\(O(k^2)\)</span>。</p>
<p>观察矩阵可得，每次乘的都是一个单项式，复杂度就只需升高 <span class="math inline">\(O(k)\)</span>。</p>
<p>暴力做的话,总的复杂度是 <span class="math inline">\(O(k^{n+2}n)\)</span> 。</p>
<p>可以用 <span class="math inline">\(\rm FFT\)</span> 优化到 <span class="math inline">\(O(k^{n+1}n\log k)\)</span> ，不过大多数时候不实用。</p>
<ul>
<li><p><strong>例题①</strong> : <a href="https://www.luogu.org/problem/CF1103E">CF1103E Radix sum</a></p>
<p>k<em>k</em> 进制不进位加法卷积快速幂。</p></li>
<li><p><strong>例题②</strong> : [P5577 <a href="https://www.luogu.org/problem/P5577">CmdOI2019]算力训练</a></p></li>
</ul>
<h2 id="x04.子集卷积-集合幂级数">0x04.子集卷积 &amp; 集合幂级数</h2>
<ul>
<li><a href="https://www.luogu.com.cn/problem/P6097">P6097 【模板】子集卷积</a></li>
</ul>
<p>作用 : 求 <span class="math inline">\(S[s]=\sum\limits_{i\subseteq s}F[i]G[s\ {\rm xor}\ i]\)</span></p>
<p>另一种说法 :<span class="math inline">\(S[s]=\sum\limits_{\tiny\begin{matrix}i|j=s\\i\&amp;j=0\end{matrix}}F[i]G[ j]\)</span></p>
<p>组合意义就是每次挑选不交的两个集合拼成新的集合。</p>
<p>好像在某些 <span class="math inline">\({\mathrm{DP}}\)</span> 题目里面见过? 这确实可以用来优化某些毒瘤子集 <span class="math inline">\({\mathrm{DP}}\)</span> 。</p>
<p>使用枚举子集的技巧即可做到 <span class="math inline">\({O\left(3^{n}\right)}\)</span> 计算。考虑使用卷积知识加速计算。</p>
<p>直接套用前面学习的位运算卷积只能求 <span class="math inline">\({S[s]=\sum_{i j=s} F[i] G[j]}\)</span>,无法再满足 <span class="math inline">\({i \ j=0}\)</span> 。</p>
<p>考虑到 <span class="math inline">\({i | j=s, i \ j=0}\)</span> 等价于 <span class="math inline">\({i|j=s,| i|+| j|=| s |}\)</span>,. (其中 <span class="math inline">\({|i|}\)</span> 表示 <span class="math inline">\({i}\)</span> 在二进制下的 1 个数 <span class="math inline">\({)}\)</span></p>
<p>我们可以将原来的 <span class="math inline">\({F[k]}\)</span> 替换成占位多项式 <span class="math inline">\({F[k] x^{|k|}}\)</span> 。</p>
<p>这样, 计算 or 卷积之后, 利用 <span class="math inline">\({x}\)</span> 上的加法卷积, <span class="math inline">\({\left[x^{p}\right] S[k]}\)</span> 就是满足 <span class="math inline">\({i|j=s,| i|+| j |=}\)</span>, 的 <span class="math inline">\({(i, j)}\)</span> 的贡献</p>
<p>我们取出 <span class="math inline">\({\left[x^{|k|}\right] S[k]}\)</span> 即为我们想要的答案。</p>
<p>中间还需要点乘，多项式乘法用暴力实现，是杂度也是 <span class="math inline">\({O\left(2^{n} n^{2}\right)}\)</span> 。</p>
<p>在具体实现中, 可以把 <span class="math inline">\({x}\)</span> 维度放在前面以减小常数。 <span class="math inline">\({}\)</span> (代码中并没有这样做)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;cstdio&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define MaxN </span><span class="dv">1050000</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> mod<span class="op">=</span><span class="dv">1000000009</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> read<span class="op">(){</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> X<span class="op">=</span><span class="dv">0</span><span class="op">;</span><span class="dt">char</span> ch<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(</span>ch<span class="op">&lt;</span><span class="dv">48</span><span class="op">||</span>ch<span class="op">&gt;</span><span class="dv">57</span><span class="op">)</span>ch<span class="op">=</span>getchar<span class="op">();</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span><span class="op">(</span>ch<span class="op">&gt;=</span><span class="dv">48</span><span class="op">&amp;&amp;</span>ch<span class="op">&lt;=</span><span class="dv">57</span><span class="op">)</span>X<span class="op">=</span>X<span class="op">*</span><span class="dv">10</span><span class="op">+(</span>ch<span class="op">^</span><span class="dv">48</span><span class="op">),</span>ch<span class="op">=</span>getchar<span class="op">();</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> X<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Poly</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> a<span class="op">[</span><span class="dv">21</span><span class="op">];</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span> <span class="op">+=</span> <span class="op">(</span><span class="at">const</span> Poly <span class="op">&amp;</span>B<span class="op">){</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      a<span class="op">[</span>i<span class="op">]=(</span>a<span class="op">[</span>i<span class="op">]+</span>B<span class="op">.</span>a<span class="op">[</span>i<span class="op">])%</span>mod<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span> <span class="kw">operator</span> <span class="op">-=</span> <span class="op">(</span><span class="at">const</span> Poly <span class="op">&amp;</span>B<span class="op">){</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      a<span class="op">[</span>i<span class="op">]=(</span>a<span class="op">[</span>i<span class="op">]-</span>B<span class="op">.</span>a<span class="op">[</span>i<span class="op">])%</span>mod<span class="op">;</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  Poly <span class="kw">operator</span> <span class="op">*</span> <span class="op">(</span><span class="at">const</span> Poly <span class="op">&amp;</span>B<span class="op">)</span> <span class="at">const</span><span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    Poly R<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span>R<span class="op">.</span>a<span class="op">[</span>i<span class="op">]=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;=</span>m<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">+</span>j<span class="op">&lt;=</span>m<span class="op">;</span>j<span class="op">++)</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        R<span class="op">.</span>a<span class="op">[</span>i<span class="op">+</span>j<span class="op">]=(</span>R<span class="op">.</span>a<span class="op">[</span>i<span class="op">+</span>j<span class="op">]+</span><span class="dv">1</span><span class="bu">ll</span><span class="op">*</span>a<span class="op">[</span>i<span class="op">]*</span>B<span class="op">.</span>a<span class="op">[</span>j<span class="op">])%</span>mod<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> R<span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> DWT<span class="op">(</span>Poly <span class="op">*</span>f<span class="op">,</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l<span class="op">=</span><span class="dv">1</span><span class="op">;</span>l<span class="op">&lt;</span>n<span class="op">;</span>l<span class="op">&lt;&lt;=</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> p<span class="op">=</span><span class="dv">0</span><span class="op">;</span>p<span class="op">&lt;</span>n<span class="op">;</span>p<span class="op">+=</span>l<span class="op">+</span>l<span class="op">)</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span>k<span class="op">&lt;</span>l<span class="op">;</span>k<span class="op">++)</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        f<span class="op">[</span>p<span class="op">|</span>l<span class="op">|</span>k<span class="op">]+=</span>f<span class="op">[</span>p<span class="op">|</span>k<span class="op">];</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> IDWT<span class="op">(</span>Poly <span class="op">*</span>f<span class="op">,</span><span class="dt">int</span> n<span class="op">)</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l<span class="op">=</span><span class="dv">1</span><span class="op">;</span>l<span class="op">&lt;</span>n<span class="op">;</span>l<span class="op">&lt;&lt;=</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> p<span class="op">=</span><span class="dv">0</span><span class="op">;</span>p<span class="op">&lt;</span>n<span class="op">;</span>p<span class="op">+=</span>l<span class="op">+</span>l<span class="op">)</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k<span class="op">=</span><span class="dv">0</span><span class="op">;</span>k<span class="op">&lt;</span>l<span class="op">;</span>k<span class="op">++)</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        f<span class="op">[</span>p<span class="op">|</span>l<span class="op">|</span>k<span class="op">]-=</span>f<span class="op">[</span>p<span class="op">|</span>k<span class="op">];</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>Poly F<span class="op">[</span>MaxN<span class="op">],</span>G<span class="op">[</span>MaxN<span class="op">],</span>T<span class="op">[</span>MaxN<span class="op">];</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> n<span class="op">,</span>c<span class="op">[</span>MaxN<span class="op">];</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>  m<span class="op">=</span>read<span class="op">();</span>n<span class="op">=(</span><span class="dv">1</span><span class="op">&lt;&lt;</span>m<span class="op">);</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span>c<span class="op">[</span>i<span class="op">]=</span>c<span class="op">[</span>i<span class="op">&gt;&gt;</span><span class="dv">1</span><span class="op">]+(</span>i<span class="op">&amp;</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span>F<span class="op">[</span>i<span class="op">].</span>a<span class="op">[</span>c<span class="op">[</span>i<span class="op">]]=</span>read<span class="op">();</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span>G<span class="op">[</span>i<span class="op">].</span>a<span class="op">[</span>c<span class="op">[</span>i<span class="op">]]=</span>read<span class="op">();</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>  DWT<span class="op">(</span>F<span class="op">,</span>n<span class="op">);</span>DWT<span class="op">(</span>G<span class="op">,</span>n<span class="op">);</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    F<span class="op">[</span>i<span class="op">]=</span>F<span class="op">[</span>i<span class="op">]*</span>G<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>  IDWT<span class="op">(</span>F<span class="op">,</span>n<span class="op">);</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>n<span class="op">;</span>i<span class="op">++)</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> &quot;</span><span class="op">,(</span>F<span class="op">[</span>i<span class="op">].</span>a<span class="op">[</span>c<span class="op">[</span>i<span class="op">]]+</span>mod<span class="op">)%</span>mod<span class="op">);</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>例题</strong> ：<a href="https://www.luogu.org/problem/CF914G">CF914G Sum the Fibonacci</a></p>
<p>这就是一道很好的模板题 (不过值域只有 <span class="math inline">\({2^{17}}\)</span> 所以很多人 <span class="math inline">\({3^{17}}\)</span> 人过去了)。</p>
<p>${ <span class="math inline">\(令\)</span> [i]=_{j}[s[j]=i] }$</p>
<p>求出 <span class="math inline">\({\mathrm{cnt}}\)</span> 和本身的子集卷积 <span class="math inline">\({F 1, \mathrm{cnt}}\)</span> 和本身的异或卷积 <span class="math inline">\({F 2}\)</span> 。</p>
<p>令 <span class="math inline">\({G 1[i]=f i b(F 1[i]), G 2}\)</span> 美似, <span class="math inline">\({ c n t{\prime}[i]=f i b(\operatorname{cnt}[i])}\)</span></p>
<p>最后把 <span class="math inline">\({G 1, G 2, c n t{\prime}}\)</span> 卷在一起就好。</p>
<ul>
<li>半在线子集卷积 给出集合幂级数 <span class="math inline">\({W, C}\)</span>, 求幂级数 <span class="math inline">\({S}\)</span> 使得： <span class="math display">\[
{
S[s]=C[s] \sum_{t \subsetneq s} S[t] W[s-t]
}
\]</span></li>
</ul>
<p>对于 <span class="math inline">\({S[s]}\)</span>, 需要得知所有为 <span class="math inline">\({s}\)</span> 的真子集的位置的 <span class="math inline">\({S}\)</span> 才能计算。</p>
<p>我们可以按照 <span class="math inline">\({|s|}\)</span> 的顺序计算 <span class="math inline">\({S[s]}\)</span>, 这样就能保证需要的值已经被计算好了。</p>
<p>此时为了方便需要将 <span class="math inline">\({x}\)</span> 维度放在前面。具体实现见例题。</p>
<p><strong>例题</strong> : <a href="https://www.luogu.org/problem/P4221">P4221州区划分</a></p>
<ul>
<li><p><strong>集合幂级数运算进阶</strong></p>
<p>需熟知如何在 <span class="math inline">\(O(n^2)\)</span> 内做一系列多项式操作，可见 <a href="https://www.luogu.com.cn/blog/command-block/ntt-yu-duo-xiang-shi-quan-jia-tong">NTT与多项式全家桶</a>。</p>
<p>下面以 <span class="math inline">\(F(x)=\sum\limits_{s}F[s]x^s\)</span> 来描述一个集合幂级数。 注意，其中 <span class="math inline">\(x\)</span> 的上标是一个集合。</p>
<ul>
<li><strong>求逆</strong></li>
</ul>
<p>变换后将占位多项式求逆，然后逆变换回来即可。</p>
<p>集合幂级数卷积的单位元是 <span class="math inline">\(x^{\varnothing}\)</span> ，可以将其视作常数项 <span class="math inline">\(1\)</span>。</p>
<ul>
<li><span class="math inline">\(\bf exp,ln\)</span> 设有集合幂级数 <span class="math inline">\(F\)</span> ，模仿多项式级数来定义其 <span class="math inline">\(\exp,\ln\)</span>。 定义 <span class="math inline">\(\exp F=\sum\limits_{k=0}\dfrac{F^k}{k!}\)</span> ,要求<span class="math inline">\([x^{\varnothing}]F=0\)</span> 。 定义 <span class="math inline">\(\ln F\)</span> 为 <span class="math inline">\(\exp\)</span> 的逆运算，要求 <span class="math inline">\([x^{\varnothing}]F=1\)</span>。 也有定义式 <span class="math inline">\(\ln F=\sum\limits_{k=1}\dfrac{(-1)^{k+1}(F- x^{\varnothing})^k}{k}\)</span> 也只需要变换后对占位多项式进行 <span class="math inline">\(\exp,\ln\)</span> 即可计算。 集合幂级数的运算也有和生成函数类似的组合意义。</li>
</ul></li>
<li><p><strong>例题①</strong> ： <a href="https://www.luogu.com.cn/problem/P6570">P6570 优秀子序列</a></p></li>
</ul>
<p>不难发现，对于序列中的 <span class="math inline">\(A[i]\)</span> 写出集合幂级数<span class="math inline">\((x^{\varnothing}+x^{A[i]})\)</span> ，我们的目标是出所有集合幂级数的卷积。</p>
<p>考虑模仿快速 <span class="math inline">\(01\)</span> 背包的套路，对其先取 <span class="math inline">\(\ln\)</span> 后 <span class="math inline">\(\exp\)</span>。 <span class="math inline">\(P(x)=\prod\limits_{i=1}^n(x^{\varnothing}+x^{A[i]})\)</span> <span class="math inline">\(=\exp\sum\limits_{i=1}^n\ln(x^{\varnothing}+x^{A[i]})\)</span> <span class="math inline">\(=\exp\sum\limits_{i=1}^n\sum\limits_{k=1}\dfrac{(-1)^{k+1}(x^{A[i]})^k}{k}\)</span></p>
<p>而 <span class="math inline">\((x^{A[i]})^k\)</span> 显然只有 <span class="math inline">\(k=1\)</span> 时为 <span class="math inline">\(x^{A[i]}\)</span> ，其他情况为 <span class="math inline">\(0\)</span>。（注 意这是子集卷积） <span class="math inline">\(=\exp\sum\limits_{i=1}^nx^{A[i]}\)</span></p>
<p>似乎变成 <span class="math inline">\(\exp\)</span> 板子了呢……</p>
<p>不过要注意对 <span class="math inline">\(A[i]=0\)</span> 的情况特殊处理。</p>
<ul>
<li><strong>例题②</strong> ： <a href="https://loj.ac/p/154">Loj#154. 集合划分计数</a></li>
</ul>
<p>不难发现“划分“就对应生成无序集合，这即为 <span class="math inline">\({\exp}\)</span> 的组合意义。</p>
<p>本题要求划分的集合数 <span class="math inline">\({\leq k}\)</span>, 则是一个部分 <span class="math inline">\({\exp}\)</span> :</p>
<p><span class="math inline">\({ \sum_{i=0}^{k} \frac{F(x)^{k}}{k !} }\)</span></p>
<p>对占位多项式做部分 <span class="math inline">\({\exp}\)</span> 即可。</p>
<p>有 <span class="math inline">\(\rm ODE\)</span> : <span class="math inline">\(G=\sum\limits_{i=0}^k\dfrac{F^k}{k!}\Rightarrow G&#39;=F&#39;*\big(G-(F^k/k!)\big)\)</span></p>
<p>常数莫名其妙的大，跑不过 <span class="math inline">\({O\left(2^{n} n^{3}\right)}\)</span> 实锤…..</p>
<p><a href="https://loj.ac/s/1001124">评测记录</a></p>
<ul>
<li><strong>例题③</strong> ： <a href="https://uoj.ac/problem/94">Uoj#94. 【集训队互测2015】胡策的统计</a></li>
</ul>
<p>设 <span class="math inline">\(G[s]\)</span> 为点集 <span class="math inline">\(s\)</span> 的联通生成子图个数，<span class="math inline">\(F[s]\)</span> 为点集 <span class="math inline">\(s\)</span> 的生成 子图个数。</p>
<p><span class="math inline">\(F\)</span> 是易求的，有 <span class="math inline">\(F[s]=2^{\text{s内部边数}}\)</span>。</p>
<p>根据 <span class="math inline">\(\exp\)</span> 的组合意义显然有 <span class="math inline">\(F=\exp G\)</span> ，则 <span class="math inline">\(G=\ln F\)</span>。</p>
<p>设 <span class="math inline">\(P[s]\)</span> 为点集 <span class="math inline">\(s\)</span> 的生成子图的连通值之和。</p>
<p>枚举连通块数目则有 <span class="math inline">\(P=\sum\limits_{k=0}\dfrac{G^k}{k!}k!=\dfrac{1}{1- G}\)</span>。</p>
<p>求逆即可。</p>
<p><a href="https://uoj.ac/submission/441128">评测记录</a></p>
<ul>
<li><strong>例题④</strong> ： <a href="https://loj.ac/p/3165">Loj#3165. 「CEOI2019」游乐园</a></li>
</ul>
<p>能够发现无环图所有边反向之后还是无环图，互反的一对图翻转边数和 恰为 <span class="math inline">\(m\)</span>。所以答案为方案数乘以 <span class="math inline">\(m/2\)</span>。</p>
<p>设 <span class="math inline">\(F[s]\)</span> 表示点集 <span class="math inline">\(s\)</span> 内适当反转后无环的方案数。</p>
<p>考虑拆 <span class="math inline">\(\rm DAG\)</span> 为子问题，每次去除入度为 <span class="math inline">\(0\)</span> 的所有点。</p>
<p>钦定入度为 <span class="math inline">\(0\)</span> 的点集 <span class="math inline">\(t\subseteq s\)</span> ，<span class="math inline">\(t\)</span> 内部必须没有边，即 <span class="math inline">\(t\)</span> 为独立集。</p>
<p><span class="math inline">\(t\)</span> 和其余点 <span class="math inline">\(s-t\)</span> 之间的边方向确定。所以方案数为 <span class="math inline">\([t\text{是独立
集}]F[s-t]\)</span></p>
<p>由于我们只能钦定一些点入度为 <span class="math inline">\(0\)</span> ，所以还需容斥。</p>
<p>可得 <span class="math inline">\(F[s]=\sum\limits_{t\subseteq s}(-1)^{|t|-1}[t\text{是独立集}]F[s-t]\)</span>。</p>
<p>设 <span class="math inline">\(G=(-1)^{|t|-1}[t\text{是独立集}]\)</span></p>
<p>即 <span class="math inline">\(F=F*G+1\)</span>。可得 <span class="math inline">\(F=\dfrac{1}{1-G}\)</span>，求逆即可。</p>
<p><a href="https://loj.ac/s/1001418">评测记录</a></p>
<ul>
<li><strong>例题⑤</strong> ： <a href="https://loj.ac/p/6673">#6673. EntropyIncreaser 与山林</a></li>
</ul>
<p>可能要先去 <a href="https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan">多项式计数杂谈</a> 看看怎么数欧拉图。</p>
<p>首先要求出偶度图的集合幂级数，然后求 <span class="math inline">\(\ln\)</span> 即可得到欧拉图。</p>
<p>现在问题变为对每个点集求生成偶度图个数。</p>
<p>找出任意一个生成森林，将其余的边随意选取，此时能得到目前每个点 的奇偶性。</p>
<p>由于森林无环的性质，每种电度奇偶性都能通过恰当地选取森林中 的边得到，且方案数恰好为 <span class="math inline">\(1\)</span>。</p>
<p>因此，偶度图个数为 <span class="math inline">\(2^{\text{边数}-\text{生成森林边数}}\)</span>。</p>
<p><a href="https://loj.ac/s/1032156">评测记录</a></p>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2021-07-16</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://blog.asukakyle.top/post/icpc2014-wfpachinko/">
			下回<br>[ICPC2014 WF]Pachinko
                </a>
                
                
                
                <a class="older-posts" href="https://blog.asukakyle.top/post/cf938g/">
			上回<br>[Codeforces938G]Shortest Path Queries
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                







            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	CC BY-NC-SA 4.0
	
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            }
    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});
</script>

<script src="https://blog.asukakyle.top/js/journal.js"></script>
    </body>
</html>
