<?xml-stylesheet href="/rss.xsl" type="text/xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/</link>
    <description>Recent content on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 05 Aug 2022 23:16:50 +0800</lastBuildDate>
    
        <atom:link href="https://blog.asukakyle.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>【置顶】Notes</title>
        <link>https://blog.asukakyle.top/post/notes/</link>
        <pubDate>Sun, 29 Aug 2021 14:20:06 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/notes/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/notes/ -
- 慎用无符号整数。注意 `0 - 1 = ~0`。
- 注意平衡树之类的数据结构的 0 节点，注意特判。尽量按照指针不建 `Null` 节点的方式写。
- 关于模板的整理：
   - 需要在保证正确性的同时，做好代码长度和效率的平衡。
   - 不能为短而短，刻意压行。
   - 一些常用的操作都尽量封装。
- 对于 $INF$（很大的数） 的处理，需要谨慎，如果图方便，要保证相加不能加爆。否则应该处理 $X + INF = INF$ 之类的情况。在进行 $INF$ 之间的比较时，如果前面图方便，计算时会出现 $X + INF$ 这样的数，这里就要注意诸如 $X + INF \leq INF$ 的比较。（问题出现于决策单调性优化）
- 计算几何随机旋转可以避免很多小错误。
- (CF1638E，学习自jiangly) 维护同色段，可以直接用线段树，也可以用 `std::map&lt;int, Info&gt;`，其中 key 为段的左端点，左闭右开这样 next 就是右端点，value 为段的信息，这种方式非常好写。每次进行区间染色 $[l, r)$ 的时候，先把 $l, r$ 两点加入map，然后就可以直接循环删除中间的，然后处理修改。
- 思路进行不下去的题，多想想根号算法。一些常见的根号分治题，想不到根号就暴毙。
- 非旋转 Treap 的 `merge` 是有返回值的，内部实现时的 `x-&gt;rs = merge(x-&gt;rs, y)` 不要把前面的 `x-&gt;rs =` 漏掉。
- 有时候会把几个名字一样的内层局部变量拿到外面来，但是忘记删掉内层的，导致外层的变量没有被改变。
- 让new变得cache友好，直接把全局的 `operator new` 重载：
```cpp
void *operator new(size_t n) {
  static char *l, *r  
  if (r &lt; l + n) {
     static constexpr int L = 1 &lt;&lt; 24;
    l = (char *)malloc(L), r = l + L;
  }
  return r -= n;
}
```
- 随机点集的凸包点数是 $O(\log n)$。
- 权值线段树求前k小和，要注意在 $l=r$ 的时候返回 $k\cdot l$。
- https://blog.asukakyle.top/post/notes/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>【置顶】Emacs 常用快捷键</title>
        <link>https://blog.asukakyle.top/post/emacs/</link>
        <pubDate>Sun, 27 Feb 2022 22:57:21 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/emacs/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/emacs/ -以下 `C` 代表 `Ctrl`，`M` 代表 `Alt`，`S` 代表 `Shift`。

例如 `C-x C-f` 表示 `Ctrl+x Ctrl+f`，visit new file，访问文件，如果文件不存在则创建新的。

- `C-x C-f`：访问文件
- `C-x C-s`：保存
- `C-x C-c`：关闭emacs
- `C-x C-z`：最小化emacs
- `C-x h`：全选
- `C-x C-p`：全选
- `C-x 1`：关闭其他window
- `C-x 2`：向下分裂window
- `C-x 3`：向右分裂window
- `C-x 0`：关闭当前window
- `C-x o`：切换window
- `C-x k`：关闭buffer
- `M-x shell`：打开shell
- `M-!` 即 `M-S-1` 或 `ESC !`：shell-command
- `M-%`：替换
- `C-s`：向下查找
- `C-r`：向上查找
- `C-a`：移动到行首
- `C-e`：移动到行尾
- `C-k`：剪切当前行光标后的内容
- `C-S-Backspace`：删除当前行
- `C-w`：剪切
- `M-w`：复制
- `C-y`：粘贴
- `C-/`：撤销(undo)

CUA-Keys（在options菜单里）开启的情况下：

- `C-x`：剪切
- `C-c`：复制
- `C-v`：粘贴
- `C-z`：撤销(undo)

想要撤销(redo)上次撤销(undo)操作，可以在上次 `C-/`(`C-z`) 之后进行一次非编辑指令(比如移动一下光标)，然后再按 `C-/`(`C-z`)。- https://blog.asukakyle.top/post/emacs/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>字符串记录</title>
        <link>https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Fri, 05 Aug 2022 23:16:50 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/ -- &lt;a href = &#34;https://www.luogu.com.cn/problem/P5576&#34;&gt;P5576 [CmdOI2019]口头禅&lt;/a&gt;
给定一堆字符串，多次询问**区间字符串最长公共子串**。
广义SAM，用set维护子树内有的连续区间，自底向上启发式合并，增加区间时在线段树上查找可以回答的询问，并且将该询问删除。由于自底向上，保证len越来越小，所以回答完就可以删除。
- &lt;a href = &#34;https://www.luogu.com.cn/problem/P4482&#34;&gt;P4482 [BJWC2018]Border 的四种求法&lt;/a&gt;
多次询问字符串**区间border**。
**parent树上链分治。**先考虑 $node_r$ 暴力向上跳，找 pos 集合区间最大值的方法。HLD 之后把跳的过程拆到重链上。利用轻子树大小和为 $O(n\log n)$，每条重链处理，要求 $pos - len &lt; L$，线段树以 $pos$ 为下标，维护 $\min\{pos-len\}$，然后线段树上二分。
- &lt;a href = &#34;https://www.luogu.com.cn/problem/CF1098F&#34;&gt;CF1098F Ж-function&lt;/a&gt;
多次询问 $f(l, r)$ 表示子串 $s[l, r]$ 每个后缀与该子串的 lcp 的和。
思路同上，用 HLD 优化暴力跳的过程，拆到重链上变成一个三维偏序，然后用 CDQ 分治做。 
- [2022牛客多校6 L Striking String Problem](https://ac.nowcoder.com/acm/contest/33191/L)
给定串 $S, T$，令 $U = S[l_1, r_1] + S[l_2, r_2] + \dots + S[l_k, r_k]$，$q$ 次询问 $T$ 在 $U[x_i, y_i]$ 中的出现次数。**数据结构优化KMP。**
询问可以拆成两个前缀的答案之差，考虑对一个前缀的查询，设它在 $S[l_i, r_i]$ 里，预处理前 $i-1$ 的答案，设 $\operatorname{query}(i, p)$ 表示右端点在 $[l_i, l_i+p)$ 的答案，完全落在 $S[l, r]$ 内的答案可以预处理前缀和。
跨过 $l_i$ 的答案，设超出长度为 $D$，需要满足 $D+p \geq |T|, D+\operatorname{lcp}(S[l:], T[D+1:]) \geq |T|$，对于同一个 $D$，$S[l:]$ 要满足的条件是后缀树上的一个子树。对 $T$ 的 kmp 失配树建可持久化线段树，区间修改单点查询。满足条件的 $D$ 是失配树上的一个祖孙链，需要知道 $S[l_1, r_1]+\dots+S[l_{i-1}, r_{i-1}]$ 和 $T$ 的匹配长度，这个可以预处理，分匹配完全在 $S[l, r]$ 和跨左端点讨论一下，后者还是在失配树上用线段树搞一下。- https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>（半）在线卷积小记</title>
        <link>https://blog.asukakyle.top/post/%E5%8D%8A%E5%9C%A8%E7%BA%BF%E5%8D%B7%E7%A7%AF%E5%B0%8F%E8%AE%B0/</link>
        <pubDate>Fri, 20 May 2022 12:26:31 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E5%8D%8A%E5%9C%A8%E7%BA%BF%E5%8D%B7%E7%A7%AF%E5%B0%8F%E8%AE%B0/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E5%8D%8A%E5%9C%A8%E7%BA%BF%E5%8D%B7%E7%A7%AF%E5%B0%8F%E8%AE%B0/ -
## 前言
本文写于 2021-12-02 14:47，是上学期我研究的对于算法竞赛来说用处很小的东西。

今天想起，需要重新整理好二叉（半）在线卷积的模板，这个东西在考场上还是很有用的。

相关题目：

- [ABC230H](https://atcoder.jp/contests/abc230/submissions/27677271)

## 半在线卷积
&gt; 设 $H = FG$。其中 $G$ 的系数事先给出，$F$ 的系数从低次到高次在线地给出，每次给出 $F$ 的 $x^i$ 系数后，你需要在线地计算 $H$ 的 $x^i$ 系数。

考虑分治，将区间 $[l, r)$ 分为 $T$ 段，每段长度为 $B = 2^k$。
$$
[l=m_0, m_1), [m_1, m_2), \dots, [m_{T-1}, m_T=r)
$$
要分别计算对于 $0 \leq i &lt; j &lt; T$, $F[m_i, m_{i+1})$ 对于 $H[m_j, m_{j+1})$ 的贡献，其中 $A[l,r)$ 表示多项式 $A(x)$ 在 $x^l, x^{l+1}, \dots, x^{r-1}$ 处的系数。

显然 $F[m_i, m_{i+1})$ 要乘上 $G[m_j-m_{i+1}+1, m_{j+1} - m_i)$。

结果有 $3B - 1$ 项，从 0 开始标号，取第 $B-1$ 到 $2B-2$ 项，做长度为 $2B$ 的循环卷积即可。 

存储 $F[m_i, m_{i+1})$ 和 $G[m_j-m_{i+1}+1, m_{j+1} - m_i)$ 的点值，需要做 $T$ 次长度为 $2B$ 的 DFT，两两作点乘，最后再 IDFT，单层复杂度为

$$
O(BT\log B+T^2B+B\log B) = O(n \log \frac{n}{T} + nT)
$$

设总时间复杂度为 $S(n)$，则
$$
S(n) = T\cdot S(\frac{n}{T}) + O(n\log \frac nT + nT)
$$

这里复杂度不会算，但是大家都取 $T = \log n$，然后得到 $O\bigg(\dfrac{n \log^2 n}{\log\log n}\bigg)$。

## 在线卷积
&gt; 设 $H = FG$。$F, G$ 的系数从低次到高次在线地给出，每次给出 $F, G$ 的 $x^i$ 系数后，你需要在线地计算 $H$ 的 $x^i$ 系数。

类似刚刚思路，但是进行到
&gt; $F[m_i, m_{i+1})$ 要乘上 $G[m_j-m_{i+1}+1, m_{j+1} - m_i)$

这一步时，发现了问题：如果 $m_i=0$，那么 $G[m_{j}, m_{j+1})$ 还没给出，无法计算。

于是这里先避开 $F[m_i, m_{i+1}) \times G[m_{j}, m_{j+1})$ 这部分贡献不算，递归到 $[m_{j}, m_{j+1})$ 这个区间时，再把这个补上。

综上所述，对于当前区间 $[l, r)$，如果 $l = 0$，那么需要计算 $F[m_i, m_{i+1}) \times G[m_j-m_{i+1}+1, m_{j+1} - m_i)$；如果 $l &gt; 0$，那么除了 $F[m_i, m_{i+1}) \times G[m_j-m_{i+1}+1, m_{j+1} - m_i)$ 之外，还要计算 $G[m_i, m_{i+1}) \times F[m_j-m_{i+1}+1, m_{j+1} - m_i)$。

其余部分前面的半在线卷积完全相同。

- https://blog.asukakyle.top/post/%E5%8D%8A%E5%9C%A8%E7%BA%BF%E5%8D%B7%E7%A7%AF%E5%B0%8F%E8%AE%B0/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>[Codeforces1677F] Tokitsukaze and Gems</title>
        <link>https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/</link>
        <pubDate>Thu, 12 May 2022 00:35:08 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/ -
[传送门](https://codeforces.com/contest/1677/problem/F)

&gt; 给定 $n, k, p, a_1, a_2, \dots, a_n$，求
&gt; $$
&gt; \sum_{1 \leq l \leq r \leq n}\sum_{l \leq i \leq r, 0 \leq t_i \leq a_i} \left(\left(\sum_{i=1}^np^{t_i}t_i^k\right)\left(\sum_{i=1}^n[t_i&gt;0]\right)\right)
&gt; $$
&gt; 
&gt; 答案对 $998244353$ 取模。
&gt; 
&gt; $1 \leq n, k\leq 10^5, 2 \leq p \leq 998244351, 1 \leq a_i \leq 998244351$。

考虑对固定的 $[l, r]$ 计算答案，它是两个数乘积之和的形式。可以通过维护 $(\sum xy, \sum x, \sum y, \sum 1)$ 四元组来计算答案。

这个玩意是线性变换，写成矩阵形式可以发现，答案最后就是要你求所有区间的矩阵乘积之和。

这个可以直接维护每个位置作为右端点的答案，只要维护当前后缀的四元组即可。

求单个的四元组，可以发现就是要求 $\sum_{i=0}^{a_j} p^ii^k$。

对于这个问题，板子 OJ 有一个 [单次询问的版本](https://judge.yosupo.jp/problem/sum_of_exponential_times_polynomial)，本题解没有参考上面的做法。

本文主要参考 [EI 的评论](https://codeforces.com/blog/entry/102631?#comment-910383) 以及下面 ecnerwala 的解读。

考虑

$$
\begin{aligned}
e^{nx} &amp;= \sum_{i \geq 0}\frac{n^ix^i}{i!}\\
n^k &amp;= [x^k]e^{nx}k!\\
\sum_{i=0}^{n-1}p^ii^k &amp;= [x^k]\sum_{i=0}^{n-1}p^ie^{ix}k!\\
&amp;= [x^k]k!\frac{p^ne^{nx}-1}{pe^x-1}\\
&amp;= [x^k]k!(p^n\frac{e^{nx}-1}{pe^x-1}-\frac{e^{0x}-1}{pe^x-1})
\end{aligned}
$$

设 $S(n)=[x^k]k!\dfrac{e^{nx}-1}{pe^x-1}$，有
$$
\begin{aligned}
p^nS(n) - p^0S(0) &amp;= \sum_{i=0}^{n-1}p^ii^k\\
p^{n+1}S(n+1)-p^nS(n) &amp;= p^nn^k\\
pS(x+1)-S(x) &amp;= x^k
\end{aligned}
$$

考虑用 $S(x)$ 来表示 $S(x+1)$，即将 $S(x + 1)$ 在 $x$ 处展开，得
$$ 
S(x+1) = \sum_{k \geq 0} \frac{1^k}{k!}{\mathrm D}^kS(x) = e^{\mathrm D}S(x)
$$
其中 $\mathrm D$ 表示微分算子。
则
$$
S(x) = \frac{x^k}{pe^{\mathrm D}-1}
$$
这也证明了 $S(x)$ 是一个 $k$ 次多项式（考虑生成函数 $F({\mathrm D}) = \frac{1}{pe^{\mathrm D}-1}$，高于 $k$ 次微分 $x^k$ 就变成 $0$ 了）。

用求逆算出 $S(x)$ 后，多点求值即可。

$O(k\log k + n\log n \log k)$

```cpp
void solve() {
  int n, k, p;
  std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; p;
  Poly f(k + 1), g(k + 1);
  for (int i = 0; i &lt;= k; i++) f[i] = 1LL * ifac[i] * p % P;
  f[0]--;
  f = f.inv(k + 1);
  for (int i = 0; i &lt;= k; i++) {
    g[k - i] = 1LL * fac[k] * ifac[k - i] % P * f[i] % P;
  }
 
  Poly pt(n);
  for (int &amp;x : pt) std::cin &gt;&gt; x, x++;
 
  f = SegTree(pt).eval(g);
  for (int i = 0; i &lt; n; i++) {
    f[i] = (1LL * fpow(p, pt[i]) * f[i] + P - g[0]) % P;
  }
 
  int ans = 0;
  std::array&lt;int, 4&gt; dp = {};
  for (int i = 0; i &lt; n; i++) {
    inc(dp[0], 1);
    auto ndp = dp;
    for (auto &amp;x : ndp) x = 1LL * x * pt[i] % P;
    ndp[1] = (ndp[1] + 1LL * dp[0] * (pt[i] - 1)) % P;
    ndp[2] = (ndp[2] + 1LL * dp[0] * f[i]) % P;
    ndp[3] = (ndp[3] + 1LL * (dp[0] + dp[1]) * f[i] + 1LL * dp[2] * (pt[i] - 1)) % P;
    dp = ndp;
    inc(ans, dp[3]);
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```
- https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>平衡树性能测试</title>
        <link>https://blog.asukakyle.top/post/%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
        <pubDate>Wed, 04 May 2022 01:19:59 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ -
支持两个操作：插入，查询 rank。

## 结果
本机，Intel CPU，Windows，gcc version 10.2.0 (winlibs) 
```text
全随机
Treap 1.866 7479
Treap2::Treap2 1.884 7479
Treap3::Treap3 1.542 7479
SCT::SCT 0.986 7479
SegTree 1.214 7479
SegTree2 1.024 7479
Tree&lt;int&gt; 1.638 7479
部分有序
Treap 0.747 15767
Treap2::Treap2 0.895 15767
Treap3::Treap3 0.661 15767
SCT::SCT 0.817 15767
SegTree 0.626 15767
SegTree2 0.574 15767
Tree&lt;int&gt; 0.903 15767
20000棵树
Treap 0.793 11
Treap2::Treap2 0.656 11
Treap3::Treap3 0.636 11
SCT::SCT 0.664 11
SegTree 1.056 11
SegTree2 0.979 11
Tree&lt;int&gt; 1.314 11
```

CF, G++17 7.3.0
```text
全随机
Treap 1.043 7479
Treap2::Treap2 1.425 7479
Treap3::Treap3 1.081 7479
SCT::SCT 0.72 7479
SegTree 0.877 7479
SegTree2 0.798 7479
Tree&lt;int&gt; 1.065 7479
部分有序
Treap 0.478 15767
Treap2::Treap2 0.764 15767
Treap3::Treap3 0.501 15767
SCT::SCT 0.658 15767
SegTree 0.455 15767
SegTree2 0.454 15767
Tree&lt;int&gt; 0.608 15767
20000棵树
Treap 0.484 11
Treap2::Treap2 0.571 11
Treap3::Treap3 0.469 11
SCT::SCT 0.33 11
SegTree 0.78 11
SegTree2 0.752 11
Tree&lt;int&gt; 0.645 11
```

## 结论
- 指针慢，但是不会慢很多，单点100ms左右。
- 大部分情况下，替罪羊快。
- PBDS效率还挺高的，不卡常可以直接用。

## 代码
```cpp
// Author:  HolyK
// Created: Tue May  3 16:31:05 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
constexpr int N(1e6 + 5), S(2e8);


std::mt19937 rng(123);

int rnd(int l, int r) {
  if (l &gt; r) std::swap(l, r);
  return l + rng() % (r - l + 1);
}

char buf[S], *pBuf = buf + S;

struct Treap {
  struct Node {
    unsigned key;
    int val;
    Node *ch[2], *p;

    int siz;
    Node(int x) : key(rng()), val(x), ch{0, 0}, p(0), siz(1) {}
    
    void *operator new(size_t n) { return pBuf -= n; }
    void pushup() {
      siz = 1;
      if (ch[0]) siz += ch[0]-&gt;siz;
      if (ch[1]) siz += ch[1]-&gt;siz;
    }
    void sch(int d, Node *x) {
      if (ch[d] = x) x-&gt;p = this;
    }
    int dir() {
      return this == p-&gt;ch[1];
    }
    void rotate() {
      Node *f = p;
      int k = dir();
      p = f-&gt;p;
      if (p) p-&gt;ch[f-&gt;dir()] = this;
      f-&gt;sch(k, ch[!k]), sch(!k, f);
      f-&gt;pushup();
    }
  } *root;
  Treap() : root(0) {}
  void insert(int x) {
    Node *p = new Node(x);
    if (!root) {
      root = p;
    } else {
      Node *o = root;
      for (;;) {
        o-&gt;siz++;
        int k = x &gt; o-&gt;val;
        if (o-&gt;ch[k]) {
          o = o-&gt;ch[k];
        } else {
          o-&gt;sch(k, p);
          break;
        }
      }
    }
    while (p-&gt;p &amp;&amp; p-&gt;key &lt; p-&gt;p-&gt;key) p-&gt;rotate();
    p-&gt;pushup();
    if (!p-&gt;p) root = p;
  
  }
  int order_of_key(int x) {
    auto o = root;
    int ans = 0;
    while (o) {
      if (x &gt; o-&gt;val) {
        ans += (o-&gt;ch[0] ? o-&gt;ch[0]-&gt;siz : 0) + 1;
        o = o-&gt;ch[1];
      } else {
        o = o-&gt;ch[0];
      }
    }
    return ans;
  }
};

struct SegTree {
  struct Node {
    Node *ls, *rs;
    int w;
    Node() : ls(0), rs(0), w(0) {}
    void *operator new(size_t n) { return pBuf -= n; }
  };
  void ins(Node *&amp;o, int l, int r, int x) {
    if (!o) o = new Node;
    o-&gt;w++;
    if (l == r) return;
    int m = l + r &gt;&gt; 1;
    if (x &lt;= m) {
      ins(o-&gt;ls, l, m, x);
    } else {
      ins(o-&gt;rs, m + 1, r, x);
    }
  }
  int ask(Node *o, int l, int r, int x) {
    if (!o || x &lt;= l) return 0;
    if (r &lt; x) return o-&gt;w;
    int m = l + r &gt;&gt; 1;
    return ask(o-&gt;ls, l, m, x) + ask(o-&gt;rs, m + 1, r, x);
  }

  Node *root;
  SegTree() : root(0) {}
  void insert(int x) {
    ins(root, 0, 1e6, x);
  }
  int order_of_key(int x) {
    return ask(root, 0, 1e6, x);
  }
};

int cnt;
namespace Treap2 {
struct TreapNode {
  unsigned key;
  int ls, rs, w, siz;
} t[2000005];
void pushup(int o) {
  t[o].siz = t[t[o].ls].siz + t[t[o].rs].siz + 1;
}
int merge(int x, int y) {
  if (!x) return y;
  if (!y) return x;
  return t[x].key &lt; t[y].key ? (t[x].rs = merge(t[x].rs, y), pushup(x), x) : (t[y].ls = merge(x, t[y].ls), pushup(y), y);
}
void split(int o, int k, int &amp;x, int &amp;y) {
  if (!o) {
    x = y = 0;
    return;
  }
  if (t[o].w &lt; k) {
    x = o;
    split(t[o].rs, k, t[o].rs, y);
  } else {
    y = o;
    split(t[o].ls, k, x, t[o].ls);
  }
  pushup(o);
}
int rank(int o, int x) {
  int ans = 0;
  while (o) {
    if (x &gt; t[o].w) {
      ans += t[t[o].ls].siz + 1;
      o = t[o].rs;
    } else {
      o = t[o].ls;
    }
  }
  return ans;
}
struct Treap2 {
  int root;
  Treap2() : root(0) {}
  void insert(int x) {
    t[++cnt] = {(unsigned)rng(), 0, 0, x, 1};
    int a, b;
    split(root, x, a, b);
    root = merge(merge(a, cnt), b);
  }
  int order_of_key(int x) {
    return rank(root, x);
  }
};

}

struct SegNode {
  int ls, rs, w;
} t[10000000];

struct SegTree2 {
  int root;
  SegTree2() : root(0) {}
  void ins(int &amp;o, int l, int r, int x) {
    if (!o) t[o = ++cnt] = {0, 0, 0};
    t[o].w++;
    if (l == r) return;
    int m = l + r &gt;&gt; 1;
    if (x &lt;= m) ins(t[o].ls, l, m, x);
    else ins(t[o].rs, m + 1, r, x);
  }
  int ask(int o, int l, int r, int x) {
    if (!o || x &lt;= l) return 0;
    if (r &lt; x) return t[o].w;
    int m = l + r &gt;&gt; 1;
    return ask(t[o].ls, l, m, x) + ask(t[o].rs, m + 1, r, x);
  }
  void insert(int x) {
    ins(root, 0, 1e6, x);
  }
  int order_of_key(int x) {
    return ask(root, 0, 1e6, x);
  }
};

template &lt;class T&gt;
std::pair&lt;double, int&gt; test(unsigned seed) {
  pBuf = std::end(buf);
  cnt = 0;
  double sta = (double)clock() / CLOCKS_PER_SEC;
  std::mt19937 rng(seed);
  const int n = 20;
  std::vector&lt;T&gt; t(n);
  int ans = 0;
  std::vector&lt;int&gt; a(1e6);
  std::iota(a.begin(), a.end(), 0);
  std::reverse(a.begin(), a.end());
  std::shuffle(a.begin(), a.begin() + a.size()    , rng);
  for (int i = 0; i &lt; 1e6; i++) {                    
    int x = rng() % n;
    if (rng() &amp; 1) {
      t[x].insert(a[i]);
    } else {
      ans ^= t[x].order_of_key(a[i]);
    }
  }                                                  
  return {(double)clock() / CLOCKS_PER_SEC - sta, ans};
}


namespace Treap3 {
struct Node {
  unsigned key;
  int p, ch[2], val, siz;
} t[2000005];
void pushup(int o) {
  t[o].siz = t[t[o].ch[0]].siz + t[t[o].ch[1]].siz + 1;
}
void sch(int o, int d, int x) {
  t[o].ch[d] = x, t[x].p = o;
}
int dir(int o) {
  return o == t[t[o].p].ch[1];
}
void rotate(int o) {
  int p = t[o].p, k = dir(o);
  t[o].p = t[p].p;
  if (t[p].p) t[t[p].p].ch[dir(p)] = o;
  sch(p, k, t[o].ch[!k]), sch(o, !k, p);
  pushup(p);
}

struct Treap3 {
  int root;
  Treap3() : root(0) {}
  void insert(int x) {
    int p = ++cnt;
    t[p] = {(unsigned)rng(), 0, {0, 0}, x, 1};
    if (!root) {
      root = p;
    } else {
      int o = root;
      for (;;) {
        int k = x &gt; t[o].val;
        t[o].siz++;
        if (!t[o].ch[k]) {
          sch(o, k, p);
          break;
        } else {
          o = t[o].ch[k];
        }
      }
    }
    while (t[p].p &amp;&amp; t[p].key &lt; t[t[p].p].key) rotate(p);
    pushup(p);
    if (!t[p].p) root = p;
  }
  int order_of_key(int x) {
    int o = root, ans = 0;
    while (o) {
      if (t[o].val &lt; x) {
        ans += t[t[o].ch[0]].siz + 1;
        o = t[o].ch[1];
      } else {
        o = t[o].ch[0];
      }
    }
    return ans;
  }
};
}

namespace SCT {
#define ls ch[0]
#define rs ch[1]
struct Node {
  int ch[2], val, siz;
} t[N];
void pushup(int o) { t[o].siz = t[t[o].ls].siz + t[t[o].rs].siz + 1; }
bool bad(int o) {
  return t[o].siz * 0.73 &lt; std::max(t[t[o].ls].siz, t[t[o].rs].siz);
}
int a[N], top;
void dfs(int x) {
  if (!x) return;
  dfs(t[x].ls), a[++top] = x, dfs(t[x].rs);
}
int build(int l, int r) {
  if (l &gt; r) return 0;
  int m = l + r &gt;&gt; 1, o = a[m];
  t[o].ls = build(l, m - 1), t[o].rs = build(m + 1, r);
  pushup(o);
  return o;
}

struct SCT {
  int root;
  SCT() : root(0) {}
  void insert(int x) {
    int p = ++cnt;
    t[p] = {{0, 0}, x, 1};
    if (!root) {
      root = p;
    } else {
      int o = root;
      top = 0;
      for (;;) {
        a[++top] = o;
        t[o].siz++;
        int k = x &gt; t[o].val;
        if (t[o].ch[k]) {
          o = t[o].ch[k];
        } else {
          t[o].ch[k] = p;
          break;
        }
      }
      for (int i = 1; i &lt;= top; i++) {
        if (bad(a[i])) {
          int &amp;o = i &gt; 1 ? t[a[i - 1]].ch[a[i] == t[a[i - 1]].ch[1]] : root;
          top = 0;
          dfs(o);
          o = build(1, top);
          break;
        }
      }
    }
  }
  int order_of_key(int x) {
    int o = root, ans = 0;
    while (o) {
      if (t[o].val &lt; x) {
        ans += t[t[o].ls].siz + 1;
        o = t[o].rs;
      } else {
        o = t[o].ls;
      }
    }
    return ans;
  }
};

}
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
template &lt;class T, class U = __gnu_pbds::null_type, class Comp = std::less&lt;T&gt;&gt;
using Tree = __gnu_pbds::tree&lt;T, U, Comp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update&gt;;

void solve() {
  std::vector&lt;unsigned&gt; seeds(3);
  for (int i = 0; i &lt; 3; i++) {
    seeds[i] = rng();
  }
  double t;
  int ans;
#define TEST(T)                                                         \
  t = 0, ans = 0;                                                       \
  for (auto s : seeds) { auto [u, v] = test&lt;T&gt;(s); t += u, ans ^= v; } \
  std::cout &lt;&lt; #T &lt;&lt; &#34; &#34; &lt;&lt; t &lt;&lt; &#34; &#34; &lt;&lt; ans &lt;&lt; &#34;\n&#34;;

  TEST(Treap);
  TEST(Treap2::Treap2);
  TEST(Treap3::Treap3);
  TEST(SCT::SCT);
  TEST(SegTree);
  TEST(SegTree2);
  TEST(Tree&lt;int&gt;);

}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```- https://blog.asukakyle.top/post/%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>全局平衡二叉树小记</title>
        <link>https://blog.asukakyle.top/post/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E8%AE%B0/</link>
        <pubDate>Tue, 05 Apr 2022 23:56:15 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E8%AE%B0/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E8%AE%B0/ -“全局平衡二叉树”实际上是静态 Top Tree(实际上，更接近静态 LCT)。

考虑一条重链，它在树上pushup，维护的信息的方式实际上就是 Compress。

而跳轻边，它实际上就是在 Rake。

对于动态DP的模板，它是树上带权独立集，虚儿子信息（rake信息）是可减的 `f[0] -= max(g[0], g[1]), f[1] -= g[0]`。

如果不可减，就得用平衡树（比如 set 等，复杂的还得手写）维护。

所以全局平衡二叉树实际上就在干 Top Tree 干的事情，只不过不支持 link, cut, evert 之类的动态树操作罢了。

考虑到 Top Tree 的结构，下面的建树过程就比较显而易见了，每个点要把虚儿子子树大小加上。

```cpp
Node *build(int l, int r) {
  if (l &gt; r) return nullptr;
  int m = l - 1, sum = 0, now = 0;
  for (int i = l; i &lt;= r; i++) sum += siz[s[i]] - siz[son[s[i]]];
  while (now * 2 &lt; sum &amp;&amp; m &lt;= r) m++, now += siz[s[m]] - siz[son[s[m]]];
  Node *o = t + s[m];
  o-&gt;ls = build(l, m - 1), o-&gt;rs = build(m + 1, r);
  if (o-&gt;ls) o-&gt;ls-&gt;fa = o;
  if (o-&gt;rs) o-&gt;rs-&gt;fa = o;
  pushup(o);
  return o;
}
```- https://blog.asukakyle.top/post/%E5%85%A8%E5%B1%80%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B0%8F%E8%AE%B0/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>Ynoi 等 lxl 题做题记录</title>
        <link>https://blog.asukakyle.top/post/ynoi/</link>
        <pubDate>Fri, 01 Apr 2022 12:59:27 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/ynoi/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/ynoi/ -## 前言
题目是乱序的。因为太菜了不会卡常，所以很多题是九十几分。

**UPD. 2022.04.27**

发现很多以前写的懒得写题解，感觉又都不太会了，后面还是做一题写一题比较好。

发现刷 Ynoi 收益很小，大部分时间只是在卡常。

不过数据结构题写起来有意思，自己写起来乐在其中，可能刷 Ynoi 对于算法竞赛并没有什么用，更多只是自我满足罢了。

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5047&#34;&gt;P5047	[Ynoi2019 模拟赛] Yuno loves sqrt technology II&lt;/a&gt;

&gt; 给定序列 $a_n$, $m$ 次询问区间逆序对。
&gt; 
&gt; $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$。

莫队二次离线。

求前缀比它小/大的数的个数，用 $O(\sqrt n)$ 修改，$O(1)$ 查询的搞一下就行。

```cpp
#include &lt;bits/stdc++.h&gt;

constexpr int T(512), N(1e5 + 5), S(N / T + 1);
struct Qry {
  int l, r, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return l / T == rhs.l / T ? l / T &amp; 1 ? r &lt; rhs.r : r &gt; rhs.r : l &lt; rhs.l;
  }
};
int n, m;

int a[N], s[S];
void clear() {
  memset(a, 0, sizeof a);
  memset(s, 0, sizeof s);
}
void add(int p) {
  int t = p / T;
  for (int i = t * T; i &lt;= p; i++) a[i]++;
  for (int i = 0; i &lt; t; i++) s[i]++;
}
int ask(int p) {
  p = std::max(p, 0);
  return a[p] + s[p / T];
}


int main() {
  std::ios::sync_with_stdio(0);
  std::cin.tie(0);
  std::cin &gt;&gt; n &gt;&gt; m;
  std::vector&lt;int&gt; a(n);
  for (int &amp;x : a) std::cin &gt;&gt; x;
  auto b = a;
  std::sort(b.begin(), b.end());
  b.resize(std::unique(b.begin(), b.end()) - b.begin());
  for (int &amp;x : a) x = std::lower_bound(b.begin(), b.end(), x) - b.begin();
  std::vector&lt;long long&gt; c(n + 1), d(n + 1);
  
  for (int i = 0; i &lt; n; i++) {
    add(a[i]);
    c[i + 1] = c[i] + ask(a[i + 1] + 1);
    d[i + 1] = d[i] + i + 1 - ask(a[i]);
  }
  std::vector&lt;Qry&gt; q(m);
  for (int i = 0; i &lt; m; i++) {
    std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
    q[i].l--, q[i].r--;
    q[i].id = i;
  }
  std::sort(q.begin(), q.end());
  std::vector&lt;long long&gt; ans(m), out(m);
  std::vector&lt;std::vector&lt;std::array&lt;int, 3&gt;&gt;&gt; g(n), h(n);
  for (int i = 0, x = 1, y = 0; i &lt; m; i++) {
    if (y != q[i].r) {
      ans[i] += c[q[i].r] - c[y];
      if (x) y &lt; q[i].r ? g[x - 1].push_back({y + 1, q[i].r, -i - 1}) : g[x - 1].push_back({q[i].r + 1, y, i});
      y = q[i].r;
    }
    if (x != q[i].l) {
      ans[i] += d[q[i].l] - d[x];
      x &lt; q[i].l ? h[y].push_back({x, q[i].l - 1, -i - 1}) : h[y].push_back({q[i].l, x - 1, i});
      x = q[i].l;
    }
  }
  clear();
  for (int i = 0; i &lt; n; i++) {
    add(a[i]);
    for (auto [l, r, id] : g[i]) {
      int c = id &lt; 0 ? id = -id - 1, -1 : 1;
      for (int j = l; j &lt;= r; j++) {
	ans[id] += c * ask(a[j] + 1);
      }
    }
    for (auto [l, r, id] : h[i]) {
      int c = id &lt; 0 ? id = -id - 1, -1 : 1;
      for (int j = l; j &lt;= r; j++) {
	ans[id] += c * (i + 1 - ask(a[j]));
      }
    }
  }
  for (int i = 1; i &lt; m; i++) ans[i] += ans[i - 1];
  for (int i = 0; i &lt; m; i++) out[q[i].id] = ans[i];
  for (auto x : out) std::cout &lt;&lt; x &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5046&#34;&gt;P5046	[Ynoi2019 模拟赛] Yuno loves sqrt technology I&lt;/a&gt;
&gt; 给定 $1\dots n$ 的 **排列** $a_n$, $m$ 次询问区间逆序对。
&gt; 
&gt; $1 \leq n, m \leq 10^5$。
&gt; 
&gt; 强制在线。

序列分块，块内预处理前缀后缀逆序对，每块预处理该块和原序列前缀的逆序对。

块内用两个前缀相减，再归并计算两个前缀之间的贡献。

整块直接用预处理的计算，然后用归并计算两个散块之间的贡献。

$O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Tue Sep 14 14:01:15 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(1e5 + 5), T(512);
LL cal(PII *a, PII *b, int l1, int r1, PII *c, PII *d, int l2, int r2) {
  LL res = 0;
  for (int now = 0; a &lt; b; a++) {
    if (a-&gt;second &lt; l1 || a-&gt;second &gt;= r1) continue;
    for (; c &lt; d &amp;&amp; *c &lt; *a; c++) {
      if (c-&gt;second &lt; l2 || c-&gt;second &gt;= r2) continue;
      now++;
    }
    res += now;
  }
  return res;
}

int n, m, a[N];
PII b[N], bb[N];
int c[N];
void add(int p, int x) {
  for (; p &lt;= n; p += p &amp; -p) c[p] += x;
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) r += c[p];
  return r;
}
constexpr int S((N - 1 + T) / T);
LL pre[N], suf[N], cnt[S][N];

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin &gt;&gt; n &gt;&gt; m;

  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; a[i];
    bb[i] = b[i] = {a[i], i};
  }
  std::sort(bb, bb + n);
  for (int l = 0, o = 0; l &lt; n; l += T, o++) {
    int r = std::min(n, l + T);
    std::sort(b + l, b + r);
    
    for (int i = 0, j = l; i &lt; n || j &lt; r;) {
      if (j == r || i &lt; n &amp;&amp; bb[i] &lt; b[j]) {
        cnt[o][bb[i].second] += j - l;
        i++;
      } else {
        j++;
      }
    }
    for (int i = 1; i &lt; n; i++) cnt[o][i] += cnt[o][i - 1];
    
    for (int i = l; i &lt; r; i++) {
      pre[i] = i - l - ask(a[i]);
      add(a[i], 1);
    }
    for (int i = l; i &lt; r; i++) {
      add(a[i], -1);      
    }
    for (int i = r - 1; i &gt;= l; i--) {
      suf[i] = ask(a[i]);
      add(a[i], 1);
    }
    for (int i = l; i &lt; r; i++) {
      add(a[i], -1);
    }
    
    for (int i = l + 1; i &lt; r; i++) pre[i] += pre[i - 1];
    for (int i = r - 2; i &gt;= l; i--) suf[i] += suf[i + 1];
  }
  LL ans = 0;
  while (m--) {
    LL l, r;
    cin &gt;&gt; l &gt;&gt; r;
    l ^= ans, r ^= ans;
    l--, r--;
    int bl = l / T, br = r / T;
    if (bl == br) {
      ans = pre[r] - (l == bl * T ? 0 : pre[l - 1]);
      int x = bl * T, y = std::min(n, x + T);
      ans -= cal(b + x, b + y, x, l, b + x, b + y, l, r + 1);
    } else {
      ans = suf[l] + pre[r];
      ans += std::max(0, (br - bl - 1) * T) * (r - br * T + 1LL);
      
      for (int i = bl + 1; i &lt; br; i++) {
        ans += suf[i * T];
        ans += cnt[i][i * T - 1];
        if (l) ans -= cnt[i][l - 1];
        ans -= cnt[i][r] - cnt[i][br * T - 1];
      }
      // std::cerr &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
      ans += cal(b + bl * T, b + bl * T + T, l, bl * T + T,
                 b + br * T, b + std::min(n, br * T + T), br * T, r + 1);
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    // break;
  }
  
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5048&#34;&gt;P5048	[Ynoi2019 模拟赛] Yuno loves sqrt technology III&lt;/a&gt;
&gt; 给定序列 $a_n$, $m$ 次询问区间众数出现的次数。
&gt; 
&gt; $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$。
&gt; 
&gt; 强制在线。

区间众数要么是中间的整块的众数，要么是两边散块的。

预处理整块两两之间区间的众数个数，然后用 vector 存每个数出现的位置。

对于散块每个数，直接看它的位置 +ans 之后还在不在询问区间内，在的话就暴力拓展。拓展次数是 $O(\sqrt n)$ 级别。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Tue Sep 14 17:41:10 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(5e5 + 5), T(512), S((N - 1 + T) / T);
int n, m, a[N], b[N], c[N], pos[N], cnt[S][S];
struct LazyVector {
  std::vector&lt;int&gt; a, b;
  int c;
  LazyVector(int n) : a(n), b(n), c(0) {}
  void clear() { c++; }
  int &amp;operator[](const int &amp;i) {
    if (b[i] != c) b[i] = c, a[i] = 0;
    return a[i];
  }
};
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i];
    b[i] = a[i];
  }
  std::sort(b, b + n);
  int t = std::unique(b, b + n) - b;
  for (int i = 0; i &lt; n; i++) {
    a[i] = std::lower_bound(b, b + t, a[i]) - b;
    c[a[i]]++;
  }
  for (int i = 1; i &lt; t; i++) c[i] += c[i - 1];
  for (int i = n - 1; i &gt;= 0; i--) {
    b[--c[a[i]]] = i;
    pos[i] = c[a[i]];
  }
  LazyVector v(t);
  for (int i = 0; i &lt; n; i += T) {  
    int max = 0;
    v.clear();
    for (int j = i + T; j &lt; n; j += T) {
      for (int k = j - T; k &lt; j; k++) 
        smax(max, ++v[a[k]]);
      cnt[i / T][j / T] = max;
    }
  }
  int ans = 0;
  while (m--) {
    int l, r;
    std::cin &gt;&gt; l &gt;&gt; r;
    l ^= ans, r ^= ans;
    l--, r--;
    int bl = l / T, br = r / T;
    if (bl == br) {
      ans = 0;
      v.clear();
      for (int i = l; i &lt;= r; i++) {
        smax(ans, ++v[a[i]]);
      }
    } else {
      ans = cnt[bl + 1][br];
      int y = bl * T + T, x = br * T;
      for (int i = l; i &lt; y; i++) {
        while (pos[i] + ans &lt; n &amp;&amp; b[pos[i] + ans] &lt;= r &amp;&amp; a[b[pos[i] + ans]] == a[i]) ans++;
      }
      for (int i = x; i &lt;= r; i++) {
        while (pos[i] - ans &gt;= 0 &amp;&amp; b[pos[i] - ans] &gt;= l &amp;&amp; a[b[pos[i] - ans]] == a[i]) ans++;
      }
    }
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P7447&#34;&gt;P7447 [Ynoi2007] rgxsxrs&lt;/a&gt;
&gt; 给定一个序列 $a_n$，$m$ 次操作：
&gt; 
&gt; 区间 $[l, r]$ 大于 $x$ 的数减 $x$；求区间和、最大最小值。
&gt;
&gt; $n, m \leq 5 \times 10^5, 1 \leq a_i, x \leq 10^9$
&gt; 
&gt; 空间限制 64MB，强制在线。

值域倍增分块，$[b^k, b^{k+1})$ 在一个块里，所以有 $\log_b a$ 个块。每一块开一个线段树。

修改时，若 $x &lt; b^k$，则块内所有数都要减 $x$，有些数被减后会掉落到更小的值域块中，掉落操作会发生 $n \log_b a$ 次，每次需要 $\log n$ 的时间定位和修改，均摊下来还是 $O(n\log_b a \log n)$。

若 $b^k \leq x &lt; b^{k+1}$，则块内有些数需要减 $x$。因为 $x \ge b^k$，所以每个数最多减 $b$ 次就会掉落，所以每个数最多会被减 $b\log_b a$ 次，最坏情况下每次需要 $\log n$ 时间定位，所以是 $O(nb\log_b a \log n)$。
 
若 $x \ge b^{k+1}$ 则什么都不用做。

设 $n, m$ 同阶，时间复杂度是 $O(nb \log n \log_b a)$，空间复杂度是 $O(n \log_b a)$，取 $b = 2$ 时间最优，但是空间炸了。

考虑先将原序列分块，块大小 $B = \log_b a$，然后线段树节点数变为 $O(n / B)$，这样线段树定位和修改的复杂度变成了 $O(\log n + B)$，仅仅增加了一点常数。

在实现时，要根据实际情况选取 $b, B$ 的大小，为了 cache 友好，不写 $\log_b a$ 棵线段树，而是每个线段树维护 $O(\log_b a)$ 的信息。

```cpp
// Author:  HolyK
// Created: Fri Aug 27 21:50:45 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
using u64 = uint64_t;
using u32 = uint32_t;
constexpr int N(5e5), T(8), P(32 / T), S(1 &lt;&lt; P), B(32), L((N + B - 1) / B);
int n, m, k;
u32 a[N];
u64 pw[T + 1];
struct Info {
  u32 min, max, siz;
  u64 sum;
  Info &amp;operator+=(const Info &amp;r) {
    smin(min, r.min);
    smax(max, r.max);
    siz += r.siz;
    sum += r.sum;
    return *this;
  }
  void tag(const u32 &amp;x) {
    min -= x, max -= x, sum -= u64(siz) * x;
  }
  void ins(const u32 &amp;x) {
    smin(min, x), smax(max, x), siz++, sum += x;
  }
} t[L * 4][T];
u32 tag[L * 4][T];
u32 pos(u32 x) { return std::__lg(x) / P; }
constexpr Info Null = {~0U, 0U, 0U, 0ULL};
inline Info operator+(const Info &amp;a, const Info &amp;b) { return {std::min(a.min, b.min), std::max(a.max, b.max), a.siz + b.siz, a.sum + b.sum}; }
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
#define APPLY() for (int _ = 0; _ &lt; T; _ += 4) F(_), F(_ + 1), F(_ + 2), F(_ + 3)
void pushup(int o) {
#define F(i) t[o][i] = t[ls][i] + t[rs][i]
  APPLY();
#undef F
}
void add(int o, int i, u32 z) {
  if (t[o][i].siz) {
    t[o][i].tag(z);
    tag[o][i] += z;
  }
}
void pushdown(int o) {
#define F(i) (tag[o][i] ? (add(ls, i, tag[o][i]), add(rs, i, tag[o][i]), tag[o][i] = 0) : 1)
  APPLY();
#undef F
}
u32 max, min;
u64 sum;
void ask(int o, int l, int r, int x, int y) {
  if (r - l == 1) {
    for (int i = l * B; i &lt; r * B &amp;&amp; i &lt; n; i++) {
      a[i] -= tag[o][pos(a[i])];
    }
    memset(tag[o], 0, sizeof tag[o]);
    for (int i = x; i &lt; y; i++) {
      smax(max, a[i]);
      smin(min, a[i]);
      sum += a[i];
    }
    return;
  }
  if (x &lt;= l * B &amp;&amp; r * B &lt;= y) {
#define F(i) (smax(max, t[o][i].max), smin(min, t[o][i].min), sum += t[o][i].sum)
    APPLY();
#undef F
    // std::cerr &lt;&lt; &#34;range-ask: &#34; &lt;&lt; l &lt;&lt; &#34; &#34; &lt;&lt; r &lt;&lt; &#34; &#34; &lt;&lt; sum - pre &lt;&lt; &#34; &#34;;    
    return;
  } 
  pushdown(o);
  int m = l + r &gt;&gt; 1;
  if (y &lt;= m * B) {
    ask(ls, l, m, x, y);
  } else if (x &gt;= m * B) {
    ask(rs, m, r, x, y);
  } else {
    ask(ls, l, m, x, m * B);
    ask(rs, m, r, m * B, y);
  }
}
void update(int o, int l, int r, int x, int y, u32 z, int bitl = 0, int bitr = T - 1) {

  while (bitl &lt;= bitr &amp;&amp; t[o][bitl].max &lt;= z) bitl++;
  while (bitl &lt;= bitr &amp;&amp; t[o][bitr].max &lt;= z) bitr--;
  if (bitl &gt; bitr) return;
  if (r - l == 1) {
    for (int i = l * B; i &lt; r * B &amp;&amp; i &lt; n; i++) {
      a[i] -= tag[o][pos(a[i])];
    }
    memset(tag[o], 0, sizeof tag[o]);
    // std::cerr &lt;&lt; &#34;update-single: &#34;;
    for (int i = x; i &lt; y; i++) {
      if (a[i] &gt; z &amp;&amp; a[i] &lt; pw[bitr + 1]) {
        // std::cerr &lt;&lt; i &lt;&lt; &#34; &#34;;
        a[i] -= z;
      }
    }
    // std::cerr &lt;&lt; &#34;\n&#34;;
    std::fill(t[o], t[o] + T, Null);
    for (int i = l * B; i &lt; r * B &amp;&amp; i &lt; n; i++) {
      t[o][pos(a[i])].ins(a[i]);
    } 
    return;
  }
  if (x &lt;= l * B &amp;&amp; r * B &lt;= y) {
    for (; bitl &lt;= bitr; bitr--) {
      const int &amp;i = bitr;
      if (t[o][i].min &gt; z &amp;&amp; t[o][i].min - z &gt;= pw[i]) {
        add(o, i, z);
        continue;
      }
      break;
    }
    if (bitl &gt; bitr) {
      return;
    }
  }
  
  pushdown(o);
  int m = l + r &gt;&gt; 1;
  if (y &lt;= m * B) {
    update(ls, l, m, x, y, z, bitl, bitr);
  } else if (x &gt;= m * B) {
    update(rs, m, r, x, y, z, bitl, bitr);
  } else {
    update(ls, l, m, x, m * B, z, bitl, bitr);
    update(rs, m, r, m * B, y, z, bitl, bitr);
  }
  pushup(o);

}
void build(int o, int l, int r) {
  if (r - l == 1) {
    std::fill(t[o], t[o] + T, Null);
    int x = l * B, y = std::min(r * B, n);
    for (int i = x; i &lt; y; i++) {
      t[o][pos(a[i])].ins(a[i]);
    }
    return;
  }
  int m = l + r &gt;&gt; 1;
  build(ls, l, m), build(rs, m, r);
  pushup(o);
}
int main() {
  // freopen(&#34;tt.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  pw[0] = 1;
  for (int i = 1; i &lt;= T; i++) pw[i] = pw[i - 1] * S;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
  k = (n + B - 1) / B;
  std::cerr &lt;&lt; &#34;k = &#34; &lt;&lt; k &lt;&lt; &#34;\n&#34;;
  build(1, 0, k);
  int ans = 0;
  while (m--) {
    int opt, l, r;
    cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;
    l ^= ans, r ^= ans;
    assert(l &lt;= r);
    l--;
    if (opt == 1) {
      u32 x;
      cin &gt;&gt; x;
      x ^= ans;
      update(1, 0, k, l, r, x);
    } else {
      max = 0U, min = ~0U, sum = 0ULL;
      ask(1, 0, k, l, r);
      ans = sum % (1 &lt;&lt; 20);
      std::cout &lt;&lt; sum &lt;&lt; &#34; &#34; &lt;&lt; min &lt;&lt; &#34; &#34; &lt;&lt; max &lt;&lt; &#34;\n&#34;;
    }
  }
  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P6578&#34;&gt;P6578	[Ynoi2019] 魔法少女网站&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作，单点修改 $a_x = y$，查询区间 $[l, r]$ 有多少子区间的最大值 $\leq x$。
&gt; 
&gt; $n, m \leq 3 \times 10^5, 1 \leq a_i \leq n$。

将操作分块，块大小为 $B$。

对于每个操作块，被修改的位置只有 $O(B)$ 个。没被修改的位置和询问按值从小到大排序，然后插入，用链表维护连续段。

每次询问，枚举前面的修改操作，暴力插入，询问完之后回滚。

由于是区间询问，还要考虑将序列分块，两边的散块暴力，完整的块要维护块内完整连续段的答案之和，以及左右两边不完整连续段的端点。

设 $n, m$ 同阶，取 $B = \sqrt n$，复杂度是 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Wed Jul 14 11:25:19 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;
// using std::cin;
template &lt;class T&gt;
struct Rec {
  std::vector&lt;std::pair&lt;T*, T&gt;&gt; rec;
  Rec(int n = 0) {
    rec.reserve(n);
  }
  void clear() { rec.clear(); }
  void operator()(T &amp;x) {
    rec.emplace_back(&amp;x, x);
  }
  void recover() {
    while (!rec.empty()) *rec.back().first = rec.back().second, rec.pop_back();
  }
};
constexpr int N(3e5 + 5), T(1024), S(N / T + 1);
struct Qry {
  int l, r, x, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return x &lt; rhs.x || x == rhs.x &amp;&amp; id &lt; rhs.id;
  }
} q[N];
int n, m, tot;
PII a[N &lt;&lt; 1];
int raw[N], val[N], b[N], pos[N], tmp[N];
LL f[N];
LL sum[S], ans[N];
int lp[S], rp[S], cnt[S];
bool vis[N];
struct Info {
  int l, r, x;
} rec[N];
int recs;
void ins(int l, int r, int z) {
  const int bl = l / T, br = r / T;
  if (bl == br) {
    sum[bl] += z * f[r - l + 1];
  } else if (z &gt; 0) {
    rp[bl] = l, lp[br] = r;
  }
}
void add(int x) {
  if (b[x]) return;
  cnt[x / T]++;
  b[x] = 1;
  int l = x, r = x;
  if (x &amp;&amp; b[x - 1]) {
    l = pos[x - 1];
    ins(pos[x - 1], x - 1, -1);
  }
  if (x + 1 &lt; n &amp;&amp; b[x + 1]) {
    r = pos[x + 1];
    ins(x + 1, pos[x + 1], -1);
  }
  pos[l] = r, pos[r] = l;
  ins(l, r, 1);
}
void add_rec(int x) {
  if (b[x]) return;
  cnt[x / T]++, b[x] = 1;
  int l = x, r = x;
  if (x &amp;&amp; b[x - 1]) {
    l = pos[x - 1];
    ins(pos[x - 1], x - 1, -1);
  }
  if (x + 1 &lt; n &amp;&amp; b[x + 1]) {
    r = pos[x + 1];
    ins(x + 1, pos[x + 1], -1);
  }
  pos[l] = r, pos[r] = l;
  ins(l, r, 1);
  rec[++recs] = {l, r, x};
}
void recover() {
  // ri.recover(), rl.recover();
  while (recs) {
    auto &amp;[l, r, x] = rec[recs--];
    cnt[x / T]--, b[x] = 0;
    ins(l, r, -1);
    if (l / T != r / T) rp[l / T] = lp[r / T] = -1;
    if (l &lt; x) ins(l, x - 1, 1), pos[l] = x - 1, pos[x - 1] = l;
    if (x &lt; r) ins(x + 1, r, 1), pos[r] = x + 1, pos[x + 1] = r;
  }
}

LL ask(int l, int r) {
  const int bl = l / T, br = r / T;
  LL ans = 0;
  if (bl == br) {
    int now = 0;
    for (int i = l; i &lt;= r; i++) {
      if (b[i]) {
        now++;
      } else {
        ans += f[now];
        now = 0;
      }
    }
    return ans + f[now];
  }
  int y = bl * T + T, x = br * T, now = 0;
  for (int i = l; i &lt; y; i++) {
    if (b[i]) {
      now++;
    } else {
      ans += f[now];
      now = 0;
    }
  }
  for (int i = bl + 1; i &lt; br; i++, y += T) {
    if (T == cnt[i]) {
      now += T;
      continue;
    }
    if (~lp[i]) {
      now += lp[i] - y + 1;
    }
    ans += f[now] + sum[i];
    now = 0;
    if (~rp[i]) {
      now = y + T - rp[i];
    }
  }
  for (int i = x; i &lt;= r; i++) {
    if (b[i]) {
      now++;
    } else {
      ans += f[now];
      now = 0;
    }
  }
  return ans + f[now];
};
int main() {
  f[0] = 0;
  for (int i = 1; i &lt;= 3e5; i++) {
    f[i] = f[i - 1] + i;
  }
  double sta = (double)clock() / CLOCKS_PER_SEC;
#ifndef ONLINE_JUDGE
  freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  freopen(&#34;tt.out&#34;, &#34;w&#34;, stdout);
#endif
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin &gt;&gt; n &gt;&gt; m, tot = (n - 1) / T + 1;
  
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; raw[i];
    a[i] = {raw[i], i};
  }
  
  int ta = n, tq = 0;
  for (int i = 0; i &lt; m; i++) {
    int opt;
    cin &gt;&gt; opt &gt;&gt; q[i].l &gt;&gt; q[i].r;
    q[i].l--;
    q[i].id = i;
    if (opt == 2) {
      cin &gt;&gt; q[i].x;
      q[i].r--;
      tq++;
    } else {
      a[ta++] = {q[i].r, q[i].l};
      ans[i] = -1;
    }
  }
  std::sort(a, a + ta);
  for (int i = 0, r, d; i &lt; m; i = r) {
    for (; i &lt; m &amp;&amp; !q[i].x; i++) {
      raw[q[i].l] = q[i].r;;
    }
    r = std::min(m, i + 1324);
    // for (int k = step; r &lt; m &amp;&amp; k; r++) k -= !q[r].x;
    std::sort(q + i, q + r);
    for (d = i; d &lt; r &amp;&amp; !q[d].x; d++) ;
    // assert(d - i &lt;= step);
    for (int j = 0; j &lt; n; j++) {
      pos[j] = -1;
      b[j] = 0;
      vis[j] = 0;
      val[j] = raw[j];
    }
   for (int j = 0; j &lt; tot; j++) {
      sum[j] = 0;
      cnt[j] = 0;
      lp[j] = rp[j] = -1;
    }
    for (int j = i; j &lt; d; j++) {
      vis[q[j].l] = 1;
    }
    tmp[0] = 0;
    for (int j = 0; j &lt; n; j++) if (vis[j]) tmp[++tmp[0]] = j;
    for (int j = d, k = 0; j &lt; r; j++) {
      auto [ql, qr, x, id] = q[j];
      for (; k &lt; ta &amp;&amp; a[k].first &lt;= x; k++) {
        if (val[a[k].second] != a[k].first || vis[a[k].second]) continue;
        add(a[k].second);
      }
      for (int t = i; t &lt; d; t++) {
        if (q[t].id &gt; id) continue;
        val[q[t].l] = q[t].r;
      }
      for (int t = 1; t &lt;= tmp[0]; t++) {
        if (val[tmp[t]] &lt;= x) add_rec(tmp[t]);
      }
      ans[id] = ask(ql, qr);
      for (int t = 1; t &lt;= tmp[0]; t++) {
        val[tmp[t]] = raw[tmp[t]];
      }
      recover();
    }
    for (int j = i; j &lt; d; j++) {
      raw[q[j].l] = q[j].r;
    }
  }
  for (int i = 0; i &lt; m; i++) if (~ans[i]) std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  std::cerr &lt;&lt; &#34;time : &#34; &lt;&lt; (double)clock() / CLOCKS_PER_SEC - sta &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5072&#34;&gt;P5072	[Ynoi2015] 盼君勿忘&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次询问给一个区间 $[l_i, r_i]$，对于它的每个子序列 $S$，将 $S$ 去重后求和，答案对 $p_i$ 取模。
&gt; 
&gt; $1 \leq n, m, a_i \leq 10^5, 1 \leq p \leq 10^9$。

莫队。

考虑每个元素对答案的贡献。设元素 $x$ 的出现次数为 $c$，$len = r - l + 1$，那么贡献是 $x(2^c-1)2^{len-c} = x2^{len} - x2^{len - c}$。前者只需要维护不同数的和，后者考虑按照 $c$ 根号分治。

- $c \geq \sqrt n$ 的数，不超过 $\sqrt n$ 个，暴力计算。

- $c &lt; \sqrt n$ 的，每个维护一下 $\sum x$ 即可。

需要 $O(1)$ 计算 $p_i^k$，根号预处理 $p^k, \big(p^{\sqrt n}\big)^k$ 即可。

```cpp
// Author:  HolyK
// Created: Wed Sep  8 16:32:52 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), T(384);
int n, m, a[N];
struct Qry {
  int l, r, p, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return l / T == rhs.l / T ? l / T &amp; 1 ? r &lt; rhs.r : r &gt; rhs.r : l &lt; rhs.l;
  }
} q[N];

int cnt[N];
LL s, sum[N];
void add(int x) {
  if (!cnt[x]) s += x;
  sum[cnt[x]] -= x;
  sum[++cnt[x]] += x;
}
void del(int x) {
  sum[cnt[x]] -= x;
  sum[--cnt[x]] += x;
  if (!cnt[x]) s -= x;
}
std::vector&lt;int&gt; big;
int ans[N], pw[T], ppw[T];
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    cnt[a[i]]++;
  }
  for (int i = 1; i &lt;= 1e5; i++) {
    if (cnt[i] &gt;= T) {
      big.push_back(i);
    }
  }
  for (int i = 1; i &lt;= m; i++) {
    std::cin &gt;&gt; q[i].l &gt;&gt; q[i].r &gt;&gt; q[i].p;
    q[i].id = i;
  }
  std::sort(q + 1, q + 1 + m);
  memset(cnt, 0, sizeof cnt);
  for (int i = 1, x = 1, y = 0; i &lt;= m; i++) {
    while (x &gt; q[i].l) add(a[--x]);
    while (y &lt; q[i].r) add(a[++y]);
    while (x &lt; q[i].l) del(a[x++]);
    while (y &gt; q[i].r) del(a[y--]);
    int len = q[i].r - q[i].l + 1;
    // std::cerr &lt;&lt; &#34;[Q] &#34; &lt;&lt; q[i].l &lt;&lt; &#34; &#34; &lt;&lt; q[i].r &lt;&lt; &#34;:\n&#34;;
    pw[0] = 1;
    const int &amp;p = q[i].p;
    for (int i = 1; i &lt; T; i++) pw[i] = 2LL * pw[i - 1] % p;
    ppw[0] = 1;
    ppw[1] = pw[T - 1] * 2LL % p;
    for (int i = 2; i &lt; T; i++) ppw[i] = 1LL * ppw[i - 1] * ppw[1] % p;
    auto power = [&amp;](int k) {
      return 1LL * ppw[k / T] * pw[k % T] % p;
    };
    auto &amp;r = ans[q[i].id];
    // std::cerr &lt;&lt; s &lt;&lt; &#34;\n&#34;;
    r = s % p * power(len) % p;
    for (int x : big) {
      if (cnt[x] &gt;= T) {
        r = (r - 1LL * x * power(len - cnt[x])) % p;
      }
    }
    for (int i = std::min(T - 1, len), c = power(len - i); i; i--, c = 2LL * c % p) {
      if (sum[i]) {
        r = (r - sum[i] % p * c) % p;
      }
    }
    if (r &lt; 0) r += p;
  }
  for (int i = 1; i &lt;= m; i++) {
    std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5397&#34;&gt;P5397	[Ynoi2018] 天降之物&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作：将所有 $x$ 改成 $y$；找出 $(i, j)$ 满足 $a_i = x, a_j = y$，求 $\min |i - j|$。
&gt; 
&gt; 所有数在 $[1, 10^5]$ 范围内，强制在线。

按照出现次数根号分治，大于等于 $\sqrt n$ 的称为大，否则称为小。

如果没有修改，可以预处理大对其他值的答案 $ans$，询问是有大就查表，否则就归并。

考虑修改，首先用并查集维护每个值的位置集合，每次修改值的时候只要合并并查集就行了，这样方便后面快速得到每个位置的值。

小值维护位置集合，小改为小时，如果合起来还是小，直接归并；否则产生了一个大，$O(n)$ 处理它对其他值的答案。

小改为大（大改为小可以交换两个值）时，直接归并复杂度是 $O(n)$，所以要再摊一下。

对于每个大值维护一个附属位置集合作为缓冲，小值位置集合先向大值附属集合归并，如果归并后大小 $\geq \sqrt n$，则直接 $O(n)$ 重构大值。

此时 $ans$ 只维护大值非附属集合对其他值的答案，附属集合由于大小不超过 $\sqrt n$，它产生的贡献在查询时可以直接归并查询。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Thu Sep 16 08:09:38 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), T(512), S(N / T + 1);

template &lt;int S&gt;
struct LazyArray {
  int a[S], b[S], c;
  void clear() { c++; }
  int &amp;operator[](const int &amp;i) {
    if (b[i] != c) b[i] = c, a[i] = 0;
    return a[i];
  } 
};
int n, m, a[N], s[N];

std::vector&lt;int&gt; g[N], h[N];
int id[N], cnt, trash[N], *cur = trash, val[N], ans[S][N];
int newId() {
  return trash == cur ? ++cnt : *cur--;
}
void del(int x) {
  if (!id[x]) return;
  *++cur = id[x];
  memset(ans[id[x]], 0x3f, sizeof ans[id[x]]);
  val[id[x]] = 0;
  id[x] = 0;
}


int cal(const std::vector&lt;int&gt; &amp;a, const std::vector&lt;int&gt; &amp;b) {
  int res = 1e9;
  for (int i = 0, j = 0; i &lt; a.size() || j &lt; b.size(); ) {
    if (j == b.size() || i &lt; a.size() &amp;&amp; a[i] &lt; b[j]) {
      if (j) smin(res, a[i] - b[j - 1]);
      i++;
    } else {
      if (i) smin(res, b[j] - a[i - 1]);
      j++;
    }
  }
  return res;
}

int fa[N], root[N];
int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}
void update(int x) {
  int y = id[x];
  for (int i = 1, p = 0; i &lt;= n; i++) {
    a[i] = a[find(i)];
    if (a[i] == x) {
      p = i;
    } else if (p) {
      smin(ans[y][a[i]], i - p);
    }
  }
  for (int i = n, p = 0; i; i--) {
    if (a[i] == x) {
      p = i;
    } else if (p) {
      smin(ans[y][a[i]], p - i);
    }
  }
}
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    s[a[i]]++;
  }

  for (int i = 1; i &lt;= 1e5; i++) {
    if (s[i] &gt;= T) {
      id[i] = newId();
      val[id[i]] = i;
    }
  }
  
  for (int i = 1; i &lt;= n; i++) {
    if (s[a[i]] &lt; T) g[a[i]].push_back(i);
    root[a[i]] = i;
  }

  for (int i = 1; i &lt;= n; i++) {
    fa[i] = root[a[i]];
  }
  
  memset(ans, 0x3f, sizeof ans);
  for (int i = 1; i &lt;= cnt; i++) {
    update(val[i]);
  }
  
  int res = 0;
  while (m--) {
    int opt, x, y;
    std::cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;
    x ^= res, y ^= res;
    static int tmp[N];
    
    auto mergeTo = [&amp;](std::vector&lt;int&gt; &amp;a, std::vector&lt;int&gt; &amp;b) {
      std::merge(a.begin(), a.end(), b.begin(), b.end(), tmp);
      b.resize(a.size() + b.size());
      a.clear();
      std::copy_n(tmp, b.size(), b.begin());
    };
    // std::cerr &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; &#34; &#34; &lt;&lt; s[x] &lt;&lt; &#34; &#34; &lt;&lt; s[y] &lt;&lt; &#34;\n&#34;;
    if (opt == 1) {
      if (x == y || !s[x]) continue;
      if (!root[y]) {
        root[y] = root[x];
        a[root[y]] = y;
      } else {
        fa[root[x]] = root[y];
      }
      root[x] = 0;
      for (int i = 1; i &lt;= cnt; i++) {
        smin(ans[i][y], ans[i][x]);
        ans[i][x] = 0x3f3f3f3f;
      }
      if (s[x] &lt; T &amp;&amp; s[y] &lt; T) {
        s[y] += s[x], s[x] = 0;
        if (s[y] &gt;= T) {
          id[y] = newId();
          val[id[y]] = y;
          g[x].clear(), g[y].clear();
          
          update(y);
          
        } else {
          mergeTo(g[x], g[y]);
        }
        continue;
      }
      
      if (s[x] &gt;= T &amp;&amp; s[y] &lt; T || s[x] &lt; T &amp;&amp; s[y] &gt;= T) {
        if (s[x] &gt; s[y]) {
          std::swap(s[x], s[y]);
          std::swap(id[x], id[y]);
          std::swap(g[x], g[y]);
          std::swap(h[x], h[y]);
          val[id[y]] = y;
        }
        if (h[y].size() + s[x] &lt; T) {
          s[y] += s[x], s[x] = 0;
          mergeTo(g[x], h[y]);
          continue;
        }
      }
      g[x].clear(), g[y].clear();
      h[x].clear(), h[y].clear(); 
      del(x);
      s[y] += s[x], s[x] = 0;
      update(y);
    } else {
      if (!s[x] || !s[y]) {
        res = 0;
        std::cout &lt;&lt; &#34;Ikaros\n&#34;;
        continue;
      }
      if (x == y) {
        res = 0;
        std::cout &lt;&lt; &#34;0\n&#34;;
        continue;
      }
      if (s[x] &lt; T &amp;&amp; s[y] &lt; T) {
        res = cal(g[x], g[y]);
      } else if (s[x] &gt;= T &amp;&amp; s[y] &gt;= T) {
        res = std::min(ans[id[x]][y], ans[id[y]][x]);
        smin(res, cal(h[x], h[y]));
      } else {
        if (s[x] &lt; s[y]) std::swap(x, y);
        res = ans[id[x]][y];
        smin(res, cal(h[x], g[y]));
      }
      std::cout &lt;&lt; res &lt;&lt; &#34;\n&#34;;
    }
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5398&#34;&gt;P5398	[Ynoi2018] GOSICK&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次询问，给定区间 $[l, r]$，查询二元组 $(i, j)$ 的个数，满足 $i, j \in [l, r], a_i \mid a_j$。
&gt; 
&gt; $1 \leq n, m, a_i \leq 10^5$。

莫队二次离线。

加入或删除一个数，就查询该数在当前区间内的倍数和约数个数，显然可以通过差分搞成两个前缀之差。

发现枚举倍数复杂度炸了，所以把小数的贡献先搞掉。

令 $T = \sqrt n$，计算每个 $x &lt; T$ 对每个询问的贡献。对于每个 $x$，可以通过前缀和 $O(n + m)$ 完成。

然后大数的因数和倍数都是 $\sqrt n$ 级别的了，直接 $\sqrt n$ 修改 $O(1)$ 查询即可。

```cpp
// Author:  HolyK
// Created: Sun May 30 14:48:18 2021
#include &lt;bits/stdc++.h&gt;
#define dbg(a...) fprintf(stderr, a)
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
inline void pc(char c) {
  static std::streambuf *o = std::cout.rdbuf();
  o-&gt;sputc(c);
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;
struct Putter {
  template &lt;class T&gt;
  Putter &amp;operator&lt;&lt;(T w) {
    if (w == 0) return pc(&#39;0&#39;), *this;
    if (w &lt; 0) pc(&#39;-&#39;), w = -w;
    static char s[20], *t;
    for (t = s; w; w /= 10) *++t = w % 10 + &#39;0&#39;;
    while (t != s) pc(*t--);
    return *this;
  }
  Putter &amp;operator&lt;&lt;(const char *s) {
    while (*s) pc(*s++);
    return *this;
  }
} cout;


constexpr int T = 1024, N(5e5 + 5);
struct Qry {
  int l, r, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return l / T == rhs.l / T ? l / T &amp; 1 ? r &lt; rhs.r : r &gt; rhs.r : l &lt; rhs.l;
  }
} q[N];
int a[N], c[N], d[N], t1[N], t2[N];
LL pre[N], pre1[N], ans[N], out[N];
std::array&lt;int, 4&gt; g[N &lt;&lt; 1];
std::vector&lt;int&gt; fac[N];
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n, m, max = 0;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i], smax(max, a[i]);
  for (int i = 0; i &lt; m; i++) {
    cin &gt;&gt; q[i].l &gt;&gt; q[i].r;
    q[i].l--, q[i].r--;
    q[i].id = i;
  }
  LL min = 1e18, sum = 0;
  int t = 1;
  for (int i = 0; i &lt; n; i++) c[a[i]]++;
  for (int i = max; i; i--) {
    if (smin(min, sum + 1LL * i * n * 3)) t = i;
    sum += (LL)max / i * c[i];
  }
  for (int i = t + 1; i &lt;= max; i++) {
    for (int j = i; j &lt;= max; j += i) {
      fac[j].push_back(i);
    }
  }
  for (int i = 1; i &lt;= t; i++) {
    memset(t1, 0, n &lt;&lt; 2);
    memset(t2, 0, n &lt;&lt; 2);
    for (int j = 0; j &lt; n; j++) {
      t1[j] = a[j] % i == 0;
      t2[j] = a[j] == i;
    }
    for (int j = 1; j &lt; n; j++) {
      t1[j] += t1[j - 1];
      t2[j] += t2[j - 1];
    }
    for (int j = 0; j &lt; m; j++) {
      auto [l, r, id] = q[j];
      out[id] += 1LL * (t1[r] - (l ? t1[l - 1] : 0) - 1) * (t2[r] - (l ? t2[l - 1] : 0));
    }
  }
  for (int i = 0; i &lt; n; i++) if (a[i] &lt;= t) a[i] = 0;
  auto clr = [&amp;]() {
    memset(c, 0, max + 1 &lt;&lt; 2);
  };
  auto add = [&amp;](int x) {
    if (!x) return;
    for (auto i : fac[x]) c[i]++;
    for (int i = x; i &lt;= max; i += x) c[i]++;
  };
  auto ask = [&amp;](int x) {
    return c[x];
  };
  clr();
  for (int i = 0; i &lt; n - 1; i++) {
    add(a[i]);
    pre[i + 1] = ask(a[i]) + pre[i];
    pre1[i + 1] = ask(a[i + 1]) + pre1[i];
  }
  std::sort(q, q + m);
  int x = 1, y = 0, cnt = 0;
  for (int i = 0; i &lt; m; i++) {
    if (x &lt; q[i].l) {
      g[cnt++] = {y, x, q[i].l - 1, -i - 1};
    }
    if (x &gt; q[i].l) {
      g[cnt++] = {y, q[i].l, x - 1, i};
    }
    ans[i] += pre[q[i].l] - pre[x];
    x = q[i].l;
    if (x) {
      if (y &lt; q[i].r) {
	g[cnt++] = {x - 1, y + 1, q[i].r, -i - 1};
      }
      if (y &gt; q[i].r) {
	g[cnt++] = {x - 1, q[i].r + 1, y, i};
      }
    }
    ans[i] += pre1[q[i].r] - pre1[y];
    y = q[i].r;
  }
  std::sort(g, g + cnt);
  clr();
  for (int i = 0, p = 0; i &lt; n &amp;&amp; p &lt; cnt; i++) {
    add(a[i]);
    for (; p &lt; cnt &amp;&amp; g[p][0] == i; p++) {
      auto [k, l, r, id] = g[p];
      LL t = 0;
      for (int j = l; j &lt;= r; j++) t += ask(a[j]);
      if (id &lt; 0) {
	ans[-id - 1] -= t;
      } else {
	ans[id] += t;
      }
    }
  }
  for (int i = 1; i &lt; m; i++) ans[i] += ans[i - 1];
  for (int i = 0; i &lt; m; i++) out[q[i].id] += ans[i] + q[i].r - q[i].l + 1;
  for (int i = 0; i &lt; m; i++) std::cout &lt;&lt; out[i] &lt;&lt; &#34;\n&#34;;
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5399&#34;&gt;P5399	[Ynoi2018] 駄作&lt;/a&gt;
&gt; 给定 $n$ 个节点的树，边权为 1。$m$ 次询问，给定 $p_0, d_0, p_1, d_1$，计算
&gt; $$
&gt; \sum_{d(p_0, a) \leq d_0}\sum_{d(p_1, b) \leq d_1} d(a, b)
&gt; $$
&gt; 
&gt; $1 \leq n, m \leq 10^5$

Top cluster 树分块。

这个题前前后后写了几天，还是常数太大过不了。

每个邻域可以被分成每个块的邻域，只有 $p_0, p_1$ 所在块的起点不是界点，其余都是。

不同块邻域之间的贡献，可以在收缩树上DP，这里需要预处理每个块以界点为起点的邻域的各种信息。

相同块邻域之间的贡献，如果起点不是界点，这样的情况只有 $O(m)$ 次，在块内 DP，复杂度 $O(m \sqrt n)$。

如果起点是界点，将询问离线，对于每个块，处理以界点为起点的邻域之间的答案。可以转换为求 $\sum d(LCA)$，然后搞 $O(B)$ 修改，$O(1)$ 查询。

我的实现用到了预处理块与块的距离，点到界点的距离，块内 $O(1)$ rmq lca 的方式来搞，常数太大了。

**怎么卡常**：通过阅读其他人的代码，可以发现，对于每一块，按照bfs序重新标号，这样每次寻找邻域时用bfs就比较 cache 友好，然后对于收缩树，我的代码中是直接以界点构成的树来DP的，但是好像别人是用块构成的树来DP的，所以我还要处理 rake 块的小情况，十分麻烦。

```cpp
// Author:  HolyK
// Created: Mon Mar 28 17:33:17 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

std::mt19937_64 rng((std::random_device())());
LL rnd(LL l, LL r) {
  if (l &gt; r) std::swap(l, r);
  return std::uniform_int_distribution&lt;LL&gt;(l, r)(rng);
}

constexpr int N(1e5 + 5), T(666), K(N / T + 5), S(N / T * 6 + 5);
std::vector&lt;int&gt; g[N];
int n, m, root, fa[N], dep[N], siz[N], bot[N];

std::vector&lt;int&gt; g1[N], pt[N];
int key[N], keys[N], fa1[N];
int gl[N], gr[N], bel[N], tot, end[N][2];
int in[N], st[10][N], lg[N];

void dfs(int x) {
  int cnt = 0;
  
  static int s[N], t; 
  for (int y : g[x]) {
    fa[y] = x;
    g[y].erase(std::find(g[y].begin(), g[y].end(), x));
    s[t++] = y;
    dep[y] = dep[x] + 1;
    dfs(y);
    siz[x] += siz[y];
    if (bot[y]) {
      bot[x] = bot[y];
      cnt++;
    }
  }

  if (x == root || siz[x] + 1 &gt;= T || cnt &gt; 1) {
    key[x] = ++keys[0];
    keys[keys[0]] = x;
    bot[x] = x;
    siz[x] = 0;

    int r = g[x].size(), c = 0, now = 0;
    for (int i = g[x].size() - 1; i &gt;= 0; i--) {
      int y = g[x][i];
      if (c &amp;&amp; bot[y] || now + siz[y] &gt;= T) {
        int tt = t;
        do {
          bel[s[--t]] = tot;
          in[s[t]] = in[0]--;
        } while (s[t] != g[x][i + 1]);
        pt[tot].assign(s + t, s + tt);
        gl[tot] = i + 1, gr[tot] = r;
        r = i + 1;
        end[tot][0] = x;
        end[tot][1] = c;
        tot++;

        now = c = 0;
      }

      now += siz[y];
      if (bot[y]) {
        c = y = bot[y];
        g1[x].push_back(y);
        g1[y].push_back(x);
        fa1[y] = x;
      }
    }

    int tt = t;
    do {
      bel[s[--t]] = tot;
      in[s[t]] = in[0]--;
      
    } while (s[t] != g[x][0]);
    pt[tot].assign(s + t, s + tt);
    gl[tot] = 0, gr[tot] = r;
    end[tot][0] = x;
    end[tot][1] = c;
    tot++;
  }

  siz[x]++;
}

int get(int x, int y) {
  return in[x] &lt; in[y] ? x : y;
}
int lca(int x, int y) {
  if (x == y) return x;
  x = in[x], y = in[y];
  if (x &gt; y) std::swap(x, y);
  int k = lg[y - x];
  return get(st[k][x], st[k][y - (1 &lt;&lt; k)]);
}
int dis(int x, int y) {
  return dep[x] + dep[y] - dep[lca(x, y)] * 2;
}
void initLCA() {
  for (int i = 1; i &lt;= n; i++) {
    st[0][in[i] - 1] = fa[i];
  }
  
  for (int i = 2; i &lt;= n; i++) {
    lg[i] = lg[i &gt;&gt; 1] + 1;
  }
  for (int i = 1; i &lt; 10; i++) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) {
      st[i][j] = get(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; i - 1)]);
    }
  }
}

int vis[N], cnt[S][T][2], d2k[N][2], dk[K][K];
LL sum[S][T][2][2];

std::vector&lt;PII&gt; pts[S][2];
void init() {
  static PII q[N];
  int l, r;
  for (int i = 1; i &lt;= n; i++) {
    if (!key[i]) continue;
    int o = key[i];
    q[l = r = 1] = {i, 0};
    vis[i] = ++vis[0];    
    while (l &lt;= r) {
      auto [x, z] = q[l++];
      dk[o][key[x]] = z;
      for (int y : g1[x]) {
        if (vis[y] == vis[0]) continue;
        vis[y] = vis[0];
        q[++r] = {y, z + std::abs(dep[x] - dep[y])};
      }
    }
  }

  for (int i = 0; i &lt; tot; i++) {
    int p = end[i][0], p1 = end[i][1];
    static int c[2][T];
    memset(c, 0, sizeof c);
    for (int x : pt[i]) {
      int dx = d2k[x][0] = dep[x] - dep[p];
      c[0][d2k[x][0]]++;
      cnt[i][dx][0]++;
      sum[i][dx][0][0] += dx;
      if (p1) {
        int dy = d2k[x][1] = dis(x, p1);
        c[1][d2k[x][1]]++;
        cnt[i][dy][1]++;
        sum[i][dx][0][1] += dy;
        sum[i][dy][1][0] += dx;
        sum[i][dy][1][1] += dy;
      }
    }
    
    pts[i][0].resize(pt[i].size());
    if (p1) pts[i][1].resize(pt[i].size());
    for (int j = 1; j &lt; T; j++) c[0][j] += c[0][j - 1], c[1][j] += c[1][j - 1];
    for (int u = pt[i].size() - 1; u &gt;= 0; u--){
      int x = pt[i][u];
      pts[i][0][--c[0][d2k[x][0]]] = {x, d2k[x][0]};
      if (p1) pts[i][1][--c[1][d2k[x][1]]] = {x, d2k[x][1]};
    }

    for (int j = 1; j &lt; T; j++) {
      for (int k : {0, 1}) {
        cnt[i][j][k] += cnt[i][j - 1][k];
        sum[i][j][k][0] += sum[i][j - 1][k][0];
        sum[i][j][k][1] += sum[i][j - 1][k][1];        
      }
    }
  }
}

std::array&lt;int, 4&gt; qry[N];


struct Info {
  int c;
  LL s[2];
  void clear() {
    c = 0;
    s[0] = s[1] = 0;
  }
} rake[N][2], comp[N][2];

LL ans[N];
void dp(int x, int id) {
  ans[id] += rake[x][0].c * rake[x][1].s[0] + rake[x][1].c * rake[x][0].s[0];
  
  for (int y : g1[x]) {
    if (y == fa1[x]) continue;
    dp(y, id);

    // compress
    for (int i = 0; i &lt; 2; i++) {
      ans[id] += rake[y][i].c * comp[y][!i].s[1] + rake[y][i].s[0] * comp[y][!i].c;
    } 
    for (int i = 0; i &lt; 2; i++) {
      comp[y][i].c += rake[y][i].c;
      comp[y][i].s[0] += 1LL * rake[y][i].c * (dep[y] - dep[x]) + rake[y][i].s[0];
    }
    
    // rake
    for (int i = 0; i &lt; 2; i++) {
      ans[id] += rake[x][i].c * comp[y][!i].s[0] + rake[x][i].s[0] * comp[y][!i].c;

    } 
    for (int i = 0; i &lt; 2; i++) {
      rake[x][i].c += comp[y][i].c;
      rake[x][i].s[0] += comp[y][i].s[0];
    }
  }
}

void split(int x, int d, int k) {
  if (x == root) {
    rake[root][k].c++;
    for (int i = 0; i &lt; tot; i++) {
      auto &amp;f = end[i][1] ? comp[end[i][1]][k] : rake[end[i][0]][k];
      
      int q = dep[end[i][0]];
      if (q &gt; d) continue;
      q = std::min(T - 1, d - q);
      f.c += cnt[i][q][0];
      f.s[0] += sum[i][q][0][0];
      f.s[1] += sum[i][q][0][1];
    }
    return;
  }
  
  int o = bel[x], ou = key[end[o][0]], od = key[end[o][1]];
  if (dep[x] &lt;= d) rake[root][k].c++;
  for (int i = 0; i &lt; tot; i++) {
    auto &amp;f = end[i][1] ? comp[end[i][1]][k] : rake[end[i][0]][k];
    if (i == o) {
      if (key[x] || d &gt;= T - 1) {
        int r = key[x] ? 1 : 0, q = std::min(d, T - 1);
        f.c += cnt[i][q][r];
        f.s[0] += sum[i][q][r][0];
        f.s[1] += sum[i][q][r][1];
      } else {
        for (auto v : pt[i]) {
          if (dis(x, v) &gt; d) continue;
          f.c++;
          f.s[0] += d2k[v][0];
          f.s[1] += d2k[v][1];
        }
      }
      continue;
    }

    int iu = key[end[i][0]], id = key[end[i][1]];
    int r = 0, q = dk[ou][iu] + d2k[x][0];
    if (od) smin(q, dk[od][iu] + d2k[x][1]);
    if (id) {
      int qq = dk[ou][id] + d2k[x][0];
      if (od) smin(qq, dk[od][id] + d2k[x][1]);
      if (smin(q, qq)) r = 1;
    }

    if (q &gt; d) continue;
    q = std::min(T - 1, d - q);

    f.c += cnt[i][q][r];
    f.s[0] += sum[i][q][r][0];
    f.s[1] += sum[i][q][r][1];
  }
}


LL val[N], s[N], ss, cc;

void getS(int x) {
  if (key[x]) return;
  for (int y : g[x]) {
    if (y == fa[x]) continue;
    s[y] = s[x] + val[y];
    getS(y);
  }
}
void update(int x, int y) {
  while (!key[fa[x]]) {
    val[x] += y;
    x = fa[x];
  }
  s[x] = val[x] += y;
  getS(x);  
  // std::cerr &lt;&lt; &#34;update &#34; &lt;&lt; x &lt;&lt; &#34;\n&#34;;
}

struct Node {
  int d, id;
  PII a2;
};

void cal(int o) {
  int p = end[o][0], p1 = end[o][1], ou = key[p], od = key[p1];

  int coef = p1 ? 1 : 0;

  std::vector&lt;Node&gt; b[2];
  for (int i = 1; i &lt;= m; i++) {
    PII a[2];
    for (int k : {0, 1}) {
      int x = qry[i][k * 2], d = qry[i][k * 2 + 1];
      if (x == root) {
        if (d &lt;= dep[p]) goto ed;
        a[k] = {0, d - dep[p]};
      } else if (bel[x] == o) {
        if (d &gt;= T - 1 || key[x]) {
          a[k] = {key[x] ? 1 : 0, d};
        } else {
          a[k] = {-x, d};
        }
      } else {
        int r = 0, i = bel[x], iu = key[end[i][0]], id = key[end[i][1]], q = dk[ou][iu] + d2k[x][0];
        if (id) smin(q, dk[ou][id] + d2k[x][1]);
        if (od) {
          int qq = dk[od][iu] + d2k[x][0];
          if (id) smin(qq, dk[od][id] + d2k[x][1]);
          if (smin(q, qq)) r = 1;
        }
        if (q &gt; d || q == d &amp;&amp; !r) goto ed;
        a[k] = {r, d - q};
      }

      if (a[k].first &gt;= 0) {
        smin(a[k].second, pts[o][a[k].first].back().second);
      }
    }
    
    if (a[0].first &lt; 0) {
      std::swap(a[0], a[1]);
    }
    
    if (a[0].first &lt; 0) {
      // std::cerr &lt;&lt; &#34;AA\n&#34;;
      int x1 = -a[0].first, d1 = a[0].second, x2 = -a[1].first, d2 = a[1].second;
      static int c[N][2];

      c[p][0] = c[p][1] = 0;
      for (int x : pt[o]) {
        c[x][0] = dis(x, x1) &lt;= d1;
        c[x][1] = dis(x, x2) &lt;= d2;
      }
      if (p1) {
        static LL s[N][2];
        s[p][0] = s[p][1] = 0;
        for (int x : pt[o]) s[x][0] = s[x][1] = 0;
        for (int j = pts[o][0].size() - 1; j &gt;= 0; j--) {
          int x = pts[o][0][j].first, y = fa[x];
          s[x][0] += c[x][0], s[x][1] += c[x][1];
          ans[i] += c[x][0] * s[y][1] + s[x][0] * c[y][1] +
                    c[x][1] * s[y][0] + s[x][1] * c[y][0];

          c[y][0] += c[x][0], c[y][1] += c[x][1];
          s[y][0] += s[x][0], s[y][1] += s[x][1];
        }
      } else {
        for (int j = pts[o][0].size() - 1; j &gt;= 0; j--) {
          int x = pts[o][0][j].first, y = fa[x];
          ans[i] -= 2LL * c[x][0] * c[x][1];
          c[y][0] += c[x][0], c[y][1] += c[x][1];
        }
      }
      
    } else {
      b[a[0].first].push_back({a[0].second, i, a[1]});
    }
    
    ed:;
  }

  for (int z : {0, 1}) {
    if (b[z].empty()) continue;
    int m = 0;
    for (auto &amp;v : b[z]) smax(m, v.d);
    std::vector&lt;int&gt; c(m + 1);
    for (auto &amp;v : b[z]) c[v.d]++;
    for (int i = 1; i &lt;= m; i++) c[i] += c[i - 1];
    std::vector&lt;Node&gt; bb(b[z].size());
    for (auto &amp;v : b[z]) bb[--c[v.d]] = v;

    for (int i = 0, j, k = 0; i &lt; bb.size(); i = j) {
      int d = bb[i].d, m[2] = {};
      static LL sum[2][T];

      for (j = i; j &lt; bb.size() &amp;&amp; d == bb[j].d; j++) {
        if (bb[j].a2.first &gt;= 0) smax(m[bb[j].a2.first], bb[j].a2.second);
      }
      while (k &lt; pts[o][z].size() &amp;&amp; pts[o][z][k].second &lt;= d) {
        int x = pts[o][z][k++].first;
        update(x, 1);
        ss += d2k[x][0];
        cc += 1;
      }
      for (int i = 0; i &lt;= m[0]; i++) sum[0][i] = 0;
      for (int i = 0; i &lt;= m[1]; i++) sum[1][i] = 0;
      for (auto [x, d] : pts[o][0]) {
        if (d &gt; m[0]) break;
        sum[0][d] += coef * (ss + 1LL * cc * d) - s[x] * 2;
      }
      for (int i = 1; i &lt;= m[0]; i++) sum[0][i] += sum[0][i - 1];
      for (auto [x, d] : pts[o][1]) {
        if (d &gt; m[1]) break;
        sum[1][d] += coef * (ss + 1LL * cc * d2k[x][0]) - s[x] * 2;
      }
      for (int i = 1; i &lt;= m[1]; i++) sum[1][i] += sum[1][i - 1];

      for (int k = i; k &lt; j; k++) {
        auto [x, d] = bb[k].a2;
        if (x &gt;= 0) {
          // assert(d &lt;= m[x]);
          ans[bb[k].id] += sum[x][d];
        } else {
          for (int v : pt[o]) {
            if (dis(v, -x) &lt;= d) {
              ans[bb[k].id] += coef * (ss + 1LL * cc * d2k[v][0]) - s[v] * 2;
            }
          }
        }
      }
    }
    for (int x : pt[o]) s[x] = val[x] = 0, ss = cc = 0;
  }
}

void solve() {
  cin &gt;&gt; n;
  for (int i = 2, x; i &lt;= n; i++) {
    cin &gt;&gt; x;
    g[x].push_back(i);
    g[i].push_back(x);
  }

  root = rnd(1, n);
  bel[root] = -1;
  in[0] = n, in[root] = 1;
  dfs(root);

  // for (int i = 1; i &lt;= n; i++) {
  //   std::cerr &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; bel[i] &lt;&lt; &#34;\n&#34;;
  // }
  initLCA();

  // std::cerr &lt;&lt; &#34;??\n&#34;;
  
  for (int i = 1; i &lt;= n; i++) {
    if (i != root)
      g[i].push_back(fa[i]);
  }

  init();

  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; i++) {
    int x1, d1, x2, d2;
    cin &gt;&gt; x1 &gt;&gt; d1 &gt;&gt; x2 &gt;&gt; d2;
    qry[i] = {x1, d1, x2, d2};
    for (int j = 1; j &lt;= keys[0]; j++) {
      int x = keys[j];
      rake[x][0].clear();
      rake[x][1].clear();
      comp[x][0].clear();
      comp[x][1].clear();
    }

    split(x1, d1, 0), split(x2, d2, 1);
    dp(root, i);
  }

  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  for (int i = 0; i &lt; tot; i++) {
    cal(i);
  }
  
  for (int i = 1; i &lt;= m; i++) {
    std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  }
  
  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
}
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t1.out&#34;, &#34;w&#34;, stdout);

  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4119&#34;&gt;P4119	[Ynoi2018] 未来日记&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作，区间 $[l, r]$ 所有 $x$ 改成 $y$；查区间 $[l, r]$ 的第 $k$ 小值。
&gt; 
&gt; $1 \leq n, m, a_i \leq 10^5$

序列分块+值域分块。

每个值、每个值域块维护序列块中出现次数的前缀和。

用并查集维护每个序列快中每个值的位置集合。

修改时重新计算对应的 $O(1)$ 个值和值域块的前缀和。

查询时两边散块重新统计值和值域块的出现次数，中间整块直接查表。

然后先确定答案所在的值域块，再确定具体的值。

复杂度 $O(n \sqrt n)$。

```cpp
// Author:  HolyK
// Created: Fri Sep 17 08:24:37 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), T(512), S(N / T + 1);
int n, m, tot, a[N], fa[N], rt[S][N];
int b[N][S], c[S][S]; // Inter-block(single, block) prefix

int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cin &gt;&gt; n &gt;&gt; m;
  tot = (n - 1 + T) / T;
  
  memset(rt, -1, sizeof rt);
  int max = 0;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i];
    rt[i / T][a[i]] = i;
    b[a[i]][i / T]++;
    c[a[i] / T][i / T]++;
    smax(max, a[i]);
  }
  for (int i = 1; i &lt;= max; i++) {
    for (int j = 1; j &lt; tot; j++) {
      b[i][j] += b[i][j - 1];
    }
  }
  for (int i = 0; i &lt;= max / T; i++) {
    for (int j = 1; j &lt; tot; j++) {
      c[i][j] += c[i][j - 1];
    }
  }
  for (int i = 0; i &lt; n; i++) {
    fa[i] = rt[i / T][a[i]];
  }

  while (m--) {
    int opt, l, r, x, y;
    std::cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; x;
    l--;
    
    if (opt == 1) {
      std::cin &gt;&gt; y;
      if (x == y) continue;
      static int tmp[S];
      for (int o = l / T, i = o * T, j; i &lt; r; o++, i += T) {
        j = std::min(n, T + i);  
        int &amp;u = rt[o][x], &amp;v = rt[o][y];
        if (u == -1) continue;
        if (i &lt; l || r &lt; j) {
          for (int k = i; k &lt; j; k++) {
            a[k] = a[find(k)];
          }
          u = v = -1;

          for (int k = std::max(l, i); k &lt; j &amp;&amp; k &lt; r; k++) {
            if (a[k] == x) a[k] = y, tmp[o]++;
          }
          for (int k = i; k &lt; j; k++) {
            if (a[k] == x) {
              u = k;
            } else if (a[k] == y) {
              v = k;
            }
          }

          for (int k = i; k &lt; j; k++) {
            fa[k] = rt[o][a[k]];
          }
          
        } else {
          tmp[o] = b[x][o] - (o ? b[x][o - 1] : 0);
          if (~v) {
            fa[u] = v;
          } else {
            a[v = u] = y;
          }
          u = -1;
        }        
      }

      for (int i = l / T; i &lt; tot; i++) {
        if (i) tmp[i] += tmp[i - 1];
        b[x][i] -= tmp[i];
        b[y][i] += tmp[i];
        c[x / T][i] -= tmp[i];
        c[y / T][i] += tmp[i];
      }
      for (int i = l / T; i &lt; tot; i++) {
        tmp[i] = 0;
      }
    } else {
      static int tmp[N], blo[S];
      if (r - l &lt;= T * 2) {
        for (int i = l; i &lt; r; i++) tmp[i] = a[find(i)];
        // for (int i = l; i &lt; r; i++) std::cerr &lt;&lt; tmp[i] &lt;&lt; &#34; \n&#34;[i + 1 == r];
        std::nth_element(tmp + l, tmp + l + x - 1, tmp + r);
        std::cout &lt;&lt; tmp[l + x - 1] &lt;&lt; &#34;\n&#34;;
        for (int i = l; i &lt; r; i++) tmp[i] = 0;
        continue;
      }
      r--;
      int bl = l / T, br = r / T;
      assert(bl + 1 &lt; br);
      
      for (int i = l; i &lt; bl * T + T; i++) {
        a[i] = a[find(i)];
        tmp[a[i]]++;
        blo[a[i] / T]++;
      }
      for (int i = br * T; i &lt;= r; i++) {
        a[i] = a[find(i)];
        tmp[a[i]]++;
        blo[a[i] / T]++;
      }
      int d = 0;
      auto calSig = [&amp;](int i) {
        return tmp[i] + b[i][br - 1] - b[i][bl];
      };
      auto calBlo = [&amp;](int i) {
        return blo[i] + c[i][br - 1] - c[i][bl];
      };
      int z;
      while (x &gt; (z = calBlo(d))) {
        x -= z, d++;
      }
      d *= T;
      while (x &gt; (z = calSig(d))) {
        x -= z, d++;
      }
      std::cout &lt;&lt; d &lt;&lt; &#34;\n&#34;;

      for (int i = l; i &lt; bl * T + T; i++) {
        tmp[a[i]] = 0;
        blo[a[i] / T] = 0;
      }
      for (int i = br * T; i &lt;= r; i++) {
        tmp[a[i]] = 0;
        blo[a[i] / T] = 0;
      }
    }
  }
  return 0;
}
```


## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4117&#34;&gt;P4117	[Ynoi2018] 五彩斑斓的世界&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作，区间大于 $x$ 的减 $x$；区间查询 $x$ 的出现次数。
&gt; 
&gt; $1 \leq n \leq 10^6, 1 \leq m \leq 5 \times 10^5, 0 \leq a, x \leq 10^5 + 1$。
&gt; 
&gt; 空间限制 64MB。

序列分块，每个块对答案的贡献是独立的，所以可以考虑将询问离线，每个块单独处理贡献，这样空间就比较小。

用并查集维护每个值出现的位置集合，然后考虑当前块的最大值 $max$，

如果 $x &gt; max / 2$，那么操作之后最大值会变成 $&lt; x$，如果 $x \leq max / 2$，那么操作之后最大值会减少 $x$。

即操作一次，最大值至少会减少 $\min\{max - x, x\}$。

- 如果 $\min\{max-x, x\} \leq \sqrt m$，我们用 $O(\min\{max-x, x\})$ 的时间来搞这个操作就行。
   - 如果 $max - x &lt; x$，那么直接枚举 $x + 1\cdots max$ 并查集合并就行。
   - 如果 $max - x &gt; x$，可以先把 $1 \cdots x$ 这些数加 $x$，然后再整体打标记减 $x$。
   
   这样上面的操作不会超过 $m$ 次，复杂度 $O(m\sqrt n)$。
- 如果 $\min\{max-x, x\} &gt; \sqrt m$，那么最多 $\sqrt m$ 次就会把最大值减到 1，所以每次暴力减就行，复杂度 $O(n\sqrt m)$。

总复杂度 $O(n\sqrt m + m\sqrt n)$。

```cpp
// Author:  HolyK
// Created: Fri Sep 10 15:54:37 2021
#include &lt;bits/stdc++.h&gt;
template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(1e6 + 5), T(888), M(2e5 + 5);
struct Option {
  int opt, l, r, x;
} q[N];

int n, m, a[N], ans[N];
int pos[M];
int fa[T], siz[T];
int find(int x) {
  while (x != fa[x]) x = fa[x] = fa[fa[x]];
  return x;
}
int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 0; i &lt; n; i++) cin &gt;&gt; a[i];
  for (int i = 1; i &lt;= m; i++) {
    cin &gt;&gt; q[i].opt &gt;&gt; q[i].l &gt;&gt; q[i].r &gt;&gt; q[i].x;
    q[i].l--;
  }
  memset(pos, -1, sizeof pos);
  for (int x = 0; x &lt; n; x += T) {
    int y = std::min(n, x + T), max, tag;
    
    auto build = [&amp;] {
      max = tag = 0;
      memset(siz, 0, sizeof siz);
      for (int i = x; i &lt; y; i++) {
        smax(max, a[i]);
        pos[a[i]] = i - x;
      }
      for (int i = x; i &lt; y; i++) {
        fa[i - x] = pos[a[i]];
        siz[fa[i - x]]++;
      }
    };
    build();
    for (int i = 1; i &lt;= m; i++) {
      if (q[i].l &gt;= y || q[i].r &lt;= x) continue;
      if (q[i].l &lt;= x &amp;&amp; y &lt;= q[i].r) {
        if (q[i].opt == 2) {
          if (~pos[q[i].x + tag]) {
            ans[i] += siz[pos[q[i].x + tag]];
          }
          continue;
        }
        if (max &lt;= q[i].x || !q[i].x) continue;
        if (std::min(max - q[i].x, q[i].x) &lt;= T) {
          if (max &lt;= q[i].x * 2) {
            for (int j = q[i].x + 1 + tag; j &lt;= max + tag; j++) {
              if (pos[j] == -1) continue;
              int &amp;u = pos[j], &amp;v = pos[j - q[i].x];
              if (v == -1) {
                v = u, a[x + u] -= q[i].x;
              } else {
                fa[u] = v;
                siz[v] += siz[u];
                siz[u] = 0;
              }
              u = -1;
            }
            max = q[i].x;
          } else {
            for (int j = q[i].x + tag; j &gt;= tag; j--) {
              if (pos[j] == -1) continue;
              int &amp;u = pos[j], &amp;v = pos[j + q[i].x];
              if (v == -1) {
                v = u, a[x + u] += q[i].x;
              } else {
                fa[u] = v;
                siz[v] += siz[u];
                siz[u] = 0;
              }
              u = -1;
            }
            tag += q[i].x;
            max -= q[i].x;
          }
          continue;
        }
      }
      if (q[i].opt == 1 &amp;&amp; max &lt;= q[i].x) continue;
      if (q[i].opt == 2 &amp;&amp; pos[q[i].x + tag] == -1) continue;
      for (int j = x; j &lt; y; j++) {
        a[j] = a[x + find(j - x)];
      }
      for (int j = x; j &lt; y; j++) {
        pos[a[j]] = -1;
        a[j] -= tag;
      }
      int l = std::max(q[i].l, x), r = std::min(q[i].r, y);
      
      if (q[i].opt == 1) {   
        for (int j = l; j &lt; r; j++) {
          if (a[j] &gt; q[i].x) a[j] -= q[i].x;
        }
      } else {
        for (int j = l; j &lt; r; j++) {
          if (a[j] == q[i].x) ans[i]++;
        }
      }
      build();
    }
    for (int i = x; i &lt; y; i++) {
      if (fa[i - x] == i - x) pos[a[i]] = -1;
    }
  }
  for (int i = 1; i &lt;= m; i++) {
    if (q[i].opt == 2) {
      std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
    }
  }
  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  return 0;
}
```


## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4689&#34;&gt;P4689	[Ynoi2016] 这是我自己的发明&lt;/a&gt;
&gt; $n$ 个点的树，有点权，初始根是 1，$m$ 次操作，换根为 $x$；给两个点 $x, y$，求从 $x$ 子树内和 $y$ 子树中分别选一个点，求两个点点权相等的情况数。
&gt; 
&gt; $1 \leq n \leq 10^5, 1 \leq m \leq 5\times 10^5, 1 \leq a_i \leq 10^9$



## &lt;a href = &#34;https://www.luogu.com.cn/problem/P7897&#34;&gt;P7897	[Ynoi2006] spxmcq&lt;/a&gt;


## &lt;a href = &#34;https://www.luogu.com.cn/problem/P8204&#34;&gt;P8204	[Ynoi2005] tdnmo&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5068&#34;&gt;P5068	[Ynoi2015] 我回来了&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4688&#34;&gt;P4688	[Ynoi2016] 掉进兔子洞&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5355&#34;&gt;P5355	[Ynoi2017] 由乃的玉米田&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5607&#34;&gt;P5607	[Ynoi2013] 无力回天 NOI2017&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5356&#34;&gt;P5356	[Ynoi2017] 由乃打扑克&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5309&#34;&gt;P5309	[Ynoi2011] 初始化&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5071&#34;&gt;P5071	[Ynoi2015] 此时此刻的光辉&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5610&#34;&gt;P5610	[Ynoi2013] 大学&lt;/a&gt;

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P8205&#34;&gt;P8205 [Ynoi2005] vti&lt;/a&gt;
&gt; $n$ 个点的有根树，有边权，$m$ 次询问，每次给出 $t_i$ 个点，求它们的虚树包含的边的祖孙顺序对。
&gt; 
&gt; $1 \leq n \leq 10^5, 1 \leq m \leq 10^6, \sum t_i \leq 10^6$.

可以通过一些简单计算，将问题转换为 $O(\sum t_i)$ 次祖孙链查询。

树分块之后，因为都是祖孙链查询，考虑二次离线莫队。

左端点在同一块的，按照右端点dfs序排序，然后和普通莫队差不多。

需要讨论左右端点是否在同一块里面，两个需要分开计算。

二次离线莫队最后要根据前缀和计算答案，因为最后忘记区分这俩，调了一会。

需要求树上前缀的答案，这个用树状数组就行。

还要 $O(1)$ 查询某个前缀比某个点小的数的个数，经典问题，搞一个 $O(\sqrt n)$ 修改，$O(1)$ 查询的数据结构。

```cpp
// Author:  HolyK
// Created: Sat Apr  2 20:50:00 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), M(1e6 + 5);
int n, m;
std::vector&lt;int&gt; g[N];

int a[N], fa[N], in[N], out[N], dep[N], dfn;
namespace RMQLCA {
int st[17][N], lg[N];
int get(int x, int y) {
  return in[x] &lt; in[y] ? x : y;
}

void init() {
  for (int i = 1; i &lt;= n; i++) st[0][in[i] - 1] = fa[i];
  for (int i = 2; i &lt;= n; i++) lg[i] = lg[i &gt;&gt; 1] + 1;
  for (int i = 1; i &lt; 17; i++) {
    for (int j = 1; j + (1 &lt;&lt; i) - 1 &lt;= n; j++) {
      st[i][j] = get(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; i - 1)]);
    }
  }
}

int lca(int x, int y) {
  if (x == y) return x;
  x = in[x], y = in[y];
  if (x &gt; y) std::swap(x, y);
  int k = lg[y - x];
  return get(st[k][x], st[k][y - (1 &lt;&lt; k)]);
}
}

using RMQLCA::lca;

LL pre1[N], pre2[N];
int c[N];
void dfs(int x) {

  in[x] = ++dfn;
  for (int p = a[x]; p &lt;= n; p += p &amp; -p) c[p]++;
  for (int p = a[x] - 1; p; p -= p &amp; -p) pre1[x] += c[p];
  pre2[x] += dep[x];
  for (int p = a[x]; p; p -= p &amp; -p) pre2[x] -= c[p];

  for (int y : g[x]) {
    pre1[y] = pre1[x];
    pre2[y] = pre2[x];
    dep[y] = dep[x] + 1;
    dfs(y);
  }

  out[x] = dfn;
  for (int p = a[x]; p &lt;= n; p += p &amp; -p) c[p]--;
}


int siz[N], bot[N], bel[N], tot;
bool key[N];

struct Qry {
  int l, r, k, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return bel[l] == bel[rhs.l] ? in[r] &lt; in[rhs.r] : bel[l] &lt; bel[rhs.l];
  }
} q[M * 2];
int qcnt, B;
LL ans[M * 2], oans[M];

struct Block {
  int top, bot;
} b[N];

void build(int x) {
  static int q[N], r;
  auto add = [&amp;](int d) {
    int o = tot++;
    b[o] = {x, d};
    for (int i = 1; i &lt;= r; i++) {
      int u = q[i];
      bel[u] = o;
      if (key[u]) continue;
      for (int v : g[u]) q[++r] = v;
    }
  };

  int s = 0, c = 0;
  for (int y : g[x]) {
    build(y);
    s += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }

  if (1 + s &gt;= B || c &gt; 1 || !x) {
    std::sort(g[x].begin(), g[x].end(), [](int i, int j) {
      return siz[i] &lt; siz[j];
    });

    siz[x] = 1;
    bot[x] = x;
    key[x] = true;
    s = c = r = 0;

    for (int y : g[x]) {
      if (c &amp;&amp; bot[y] || siz[y] + s &gt;= B) {
        add(c);
        s = c = r = 0;
      }

      c |= bot[y];
      s += siz[y];
      q[++r] = y;
    }

    add(c);
  } else {
    siz[x] = 1 + s;
  }
}

std::vector&lt;Qry&gt; q0[N], q1[N], q2[N];

constexpr int T(256);
struct SumDS {
  int tot, s0[N], s1[N / T + 1];
  void add(int p, int x) {
    int k = p / T + 1, r = std::min(k * T, n + 1);
    while (p &lt; r) s0[p++] += x;
    while (k &lt; tot) s1[k++] += x;
  }
  int ask(int p) {
    return s0[p] + s1[p / T];
  }
} sumDS;

void dfsq(int x) {

  sumDS.add(a[x], 1);
  for (auto &amp;[l, r, k, id] : q0[x]) {
    LL s = 0;
    while (r != l) s += sumDS.ask(a[r] - 1), r = fa[r];
    oans[id] += s * k;
  }
  for (auto &amp;[l, r, k, id] : q1[x]) {
    LL s = 0;
    while (r != l) s += sumDS.ask(a[r] - 1), r = fa[r];
    ans[id] += s * k;
  }
  for (auto &amp;[l, r, k, id] : q2[x]) {
    LL s = 0;
    while (r != l) s += dep[x] - sumDS.ask(a[r]), r = fa[r];
    ans[id] += s * k;
  }
  
  for (int y : g[x]) {
    dfsq(y);
  }
  sumDS.add(a[x], -1);
}

void solve() {
  std::cin &gt;&gt; n;
  a[1] = n;
  for (int i = 2; i &lt;= n; i++) {
    std::cin &gt;&gt; fa[i] &gt;&gt; a[i];
    g[fa[i]].push_back(i);
  }

  dep[1] = 1;
  dfs(1);
  
  RMQLCA::init();
  
  std::cin &gt;&gt; m;
  for (int i = 1; i &lt;= m; i++) {
    int t;
    std::cin &gt;&gt; t;
    std::vector&lt;int&gt; p(t);
    for (int j = 0; j &lt; t; j++) std::cin &gt;&gt; p[j];
    std::sort(p.begin(), p.end(), [](int i, int j) {
      return in[i] &lt; in[j];
    });
    for (int j = 0; j + 1 &lt; t; j++) {
      p.push_back(lca(p[j], p[j + 1]));
    }

    std::sort(p.begin(), p.end(), [](int i, int j) {
      return in[i] &lt; in[j];
    });
    p.erase(std::unique(p.begin(), p.end()), p.end());

    t = p.size();
    std::vector&lt;int&gt; s = {0}, c(t);
    for (int j = 1, x, u; j &lt; t; j++) {
      x = p[j];
      for (;;) {
        u = p[s.back()];
        if (in[u] &lt;= in[x] &amp;&amp; in[x] &lt;= out[u]) break;
        s.pop_back();
      }
      c[s.back()]++;
      s.push_back(j);
    }

    for (int j = 1; j &lt; t; j++) {
      q[++qcnt] = {p[0], p[j], 1 - c[j], i};
    }
  }

  B = n / sqrt(qcnt) * 1.5;
  
  g[0] = {1};
  build(0);
  
  std::sort(q + 1, q + 1 + qcnt);
  for (int i = 1, j; i &lt;= qcnt; i = j) {
    int o = bel[q[i].l];
    for (j = i + 1; j &lt;= qcnt &amp;&amp; o == bel[q[j].l]; j++) ;

    for (int k = i, x = b[o].bot, y = b[o].bot; k &lt; j; k++) {
      if (bel[q[k].r] == o) {
        q0[q[k].l].push_back({q[k].l, q[k].r, -q[k].k, q[k].id});
        oans[q[k].id] += q[k].k * (pre1[q[k].r] - pre1[q[k].l]);
      } else {
        int l = q[k].l, r = q[k].r, t = lca(y, r);
        if (t != y) {
          ans[k] -= pre1[y] - pre1[t];
          q1[x].push_back({t, y, 1, k});
          y = t;
        }
        if (y != r) {
          ans[k] += pre1[r] - pre1[y];
          q1[x].push_back({y, r, -1, k});
          y = r;
        }
        if (x != l) {
          if (in[x] &lt; in[l]) {
            ans[k] += pre2[l] - pre2[x];
            q2[y].push_back({x, l, -1, k});
          } else {
            ans[k] -= pre2[x] - pre2[l];
            q2[y].push_back({l, x, 1, k});
          }
          x = l;
        }
      }
    }
  }

  sumDS.tot = n / T + 1;
  dfsq(1);

  for (int i = 1; i &lt;= qcnt; i++) {

    if (i &gt; 1 &amp;&amp; bel[q[i].l] == bel[q[i - 1].l]) {
      ans[i] += ans[i - 1];
    }

    if (bel[q[i].l] != bel[q[i].r]) oans[q[i].id] += ans[i] * q[i].k;
  }

  for (int i = 1; i &lt;= m; i++) {
    std::cout &lt;&lt; oans[i] &lt;&lt; &#34;\n&#34;;
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P6778&#34;&gt;P6778 [Ynoi2009] rpdq&lt;/a&gt;
&gt; 给定 $n$ 个点的无根有边权的树，$m$ 次询问，求
&gt; $$
&gt; \sum_{l \leq i &lt; j \leq r} \operatorname{dis}(i, j)
&gt; $$
&gt; 
&gt; $1 \leq n, m, d \leq 2\times 10^5$。
&gt; 
&gt; 答案对 $2^{32}$ 取模。

二次离线莫队之后转换成求一个点到前缀 $1\dots k$ 的距离之和。转换成求它们的 lca 的深度之和。变成经典的链加链和，可以用树分块做到 $O(\sqrt n)$ 修改，$O(1)$ 查询。

这里树分块比较简单，只需要求出关键点，使得每个点向上最多跳 $\sqrt n$ 步就能到达某个关键点。

之前卡常卡魔怔了，这个代码貌似用bfs序重新标了一下号，感觉很毒瘤。

```cpp
// Author:  HolyK
// Created: Mon Apr 11 10:09:33 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(2e5 + 5), T(512), S(T * 4 + 5);
int n, m, B, siz[N], bot[N], fa[N], val[N], bup[N], bdn[N], kp[S];
int que[N], out[N], id[N], key[N], kid[S], kcnt;
unsigned dis[N], dep[N];
std::vector&lt;PII&gt; g[N];
void build(int x) {
  static int l = 1, r = 0;
  int c = 0;
  for (auto [y, z] : g[x]) {
    if (x) g[y].erase(std::find(g[y].begin(), g[y].end(), PII{x, z}));
    fa[y] = x;
    dep[y] = dep[x] + z;
    build(y);
    siz[x] += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }
  if (!x || siz[x] + 1 &gt;= B || c &gt; 1) {
    key[x] = ++kcnt;
    bot[x] = kcnt;
    siz[x] = 0;
    for (auto [y, z] : g[x]) {
      que[++r] = y;
      val[r] = z;
      if (bot[y]) {
        dis[r] = z;
        kp[bot[y]] = kcnt;
      }
      int u = r, bu = kcnt, bd = bot[y];
      for (; l &lt;= r; l++) {
        int x = que[l];
        bup[l] = bu;
        bdn[l] = bd;
        if (key[x]) continue;
        for (auto [y, z] : g[x]) {
          que[++r] = y;
          val[r] = z;
          dis[r] = dis[l];
          if (bot[y]) dis[r] += z;
        }
      }
      out[u] = r;
    }
  }
  siz[x]++; 
}

void relabel() {
  static int tmp[N];
#define R(a) for (int i = 0; i &lt;= n; i++) tmp[i] = a[que[i]]; memcpy(a, tmp, sizeof tmp)
  R(bot);
  R(fa);
  R(key);
  for (int i = 1; i &lt;= n; i++) id[que[i]] = i;
  for (int i = 1; i &lt;= n; i++) {
    fa[i] = id[fa[i]];
    if (key[i]) {
      kid[key[i]] = i;
    }
  }
}

unsigned v[N], s[N], ks[S], tag[S];
void add(int x) {
  while (!key[fa[x]]) {
    v[x] += val[x];
    x = fa[x];
  }
  assert(out[x]);
  s[x] = v[x] += val[x];
  for (int i = x + 1; i &lt;= out[x]; i++) {
    s[i] = v[i] + s[fa[i]];
  }
  x = bup[x];
  while (x &lt; kcnt) {
    tag[x]++;
    x = kp[x];
  }
  for (int i = kcnt - 1; i; i--) {
    ks[i] = ks[kp[i]] + dis[kid[i]] * tag[i] + s[kid[i]];
  }
}

unsigned ask(int x) {
  return key[x] ? ks[key[x]] : dis[x] * tag[bdn[x]] + s[x] + ks[bup[x]];
}

unsigned pre[N], ans[N], oans[N];
struct Qry {
  int l, r, id;
  bool operator&lt;(const Qry &amp;rhs) const {
    return l / T == rhs.l / T ? l / T &amp; 1 ? r &lt; rhs.r : r &gt; rhs.r : l &lt; rhs.l;
  }
} q[N];

struct Q {
  int l, r, k, id;
};
std::vector&lt;Q&gt; qq[N];
void solve() {
  cin &gt;&gt; n &gt;&gt; m;
  B = 1.5 * sqrt(n);
  for (int i = 1, x, y, z; i &lt; n; i++) {
    cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
    g[x].push_back({y, z});
    g[y].push_back({x, z});
  }
  g[0].push_back({n + 1 &gt;&gt; 1, 0});
  build(0);
  relabel();
  unsigned sum = 0;
  for (int i = 1; i &lt;= n; i++) {
    add(id[i]);
    sum += dep[i];
    pre[i] = pre[i - 1] + sum + i * dep[i] - 2 * ask(id[i]);
  }
  
  for (int i = 1; i &lt;= m; i++) {
    int l, r;
    cin &gt;&gt; l &gt;&gt; r;
    q[i] = {l, r, i};
  }
  std::sort(q + 1, q + 1 + m);
  for (int i = 1, x = 1, y = 0; i &lt;= m; i++) {
    if (y != q[i].r) {
      ans[i] += pre[q[i].r] - pre[y];
      if (y &lt; q[i].r) {
        qq[x - 1].push_back({y + 1, q[i].r, -1, i});
      } else {
        qq[x - 1].push_back({q[i].r + 1, y, 1, i});
      }
      y = q[i].r;
    }
    if (x != q[i].l) {
      ans[i] += pre[q[i].l - 1] - pre[x - 1];
      if (x &lt; q[i].l) {
        qq[y].push_back({x, q[i].l - 1, -1, i});
      } else {
        qq[y].push_back({q[i].l, x - 1, 1, i});
      }
      x = q[i].l;
    }
  }
  memset(v, 0, sizeof v);
  memset(s, 0, sizeof s);
  memset(ks, 0, sizeof ks);
  memset(tag, 0, sizeof tag);

  sum = 0;
  for (int i = 1; i &lt;= n; i++) {
    add(id[i]);
    sum += dep[i];
    for (auto &amp;[l, r, k, t] : qq[i]) {
      LL s = 0;
      for (int j = l; j &lt;= r; j++) {
        s += sum + i * dep[j] - 2 * ask(id[j]);
      }
      ans[t] += k * s;
    }
  }
  for (int i = 1; i &lt;= m; i++) {
    ans[i] += ans[i - 1];
    oans[q[i].id] = ans[i];
  }
  for (int i = 1; i &lt;= m; i++) {
    std::cout &lt;&lt; oans[i] &lt;&lt; &#34;\n&#34;;
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5064&#34;&gt;P5064 [Ynoi2014] 等这场战争结束之后&lt;/a&gt;

&gt; 给你一个图，每个点有点权，最开始没有边。
&gt; 
&gt; 有一些操作：
&gt; 
&gt; 1. 添加一条 $x$ 与 $y$ 之间的双向边。
&gt; 2. 回到第 $x$ 次操作后的状态（注意这里的 $x$ 可以是 0，即回到初始状态）。
&gt; 3. 查询 $x$ 所在联通块能到的点中点权第 $y$ 小的值，如果不存在，那么输出 -1。
&gt; 
&gt; $1 \leq n, m \leq 10^5, 0 \leq a_i \leq 10^9$

zx2003 的论文题，复杂度是 $O(m\sqrt n)$ 时间，$O(n)$ 空间，但是跑不过暴力。

先离散化，注意到这里的离散化不需要去重。

建出操作树，然后可以预处理每个操作涉及到的点在当时所属并查集的根（因为要回滚，所以并查集是按秩合并），这个是 $O(m\log n)$ 的。

值域分块，对于每个询问，我们先求出它属于哪个值域块。

对于每个值域块，用 01 表示某个点是否属于这个值域块，然后用并查集维护每个联通块的和，就可以知道每个联通块里面 1 的个数。注意到并查集的合并是 $O(1)$ 的，而查询在前面已经预处理过。

所以这步总共是 $O(m \sqrt n)$。

然后要求出每个询问的具体答案，需要支持 $O(1)$ 询问一个点是否和当前的点联通。

将操作树分块，只需要求出关键点。每个关键点处理整张图的连通性，每个操作距离关键点最多只会连 $O(\sqrt n)$ 条边，将这些边用前向星存下来之后，每次操作bfs一下就可求出当前联通块有哪些点了。

我在实现的时候，为了方便，在关键点处改用了路径压缩并查集。

```cpp
// Author:  HolyK
// Created: Tue Apr 12 00:19:05 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), T(512);
int n, m, a[N], ch[N], g[N], fa[N];
PII b[N];
struct Option {
  int opt, x, y;
} q[N];
bool key[N];
int ans[N], siz[N], bot[N];
int f[N], s[N];
int find(int x) {
  while (x != f[x]) x = f[x];
  return x;
}
int find2(int x) {
  while (x != f[x]) x = f[x] = f[f[x]];
  return x;
}

int seq[N * 2], scnt;
void dfs1(int x) {
  if (q[x].opt == 1) {
    int &amp;u = q[x].x, &amp;v = q[x].y;
    u = find(u), v = find(v);
    if (u != v) {
      seq[scnt++] = x;
      if (s[u] &gt; s[v]) std::swap(u, v);
      s[v] += s[u];
      f[u] = v;
    }
    
  } else if (q[x].opt == 3) {
    q[x].x = find(q[x].x);
    seq[scnt++] = x;
  }
  
  for (int i = ch[x], y; y = g[i], i &lt; ch[x + 1]; i++) {
    dfs1(y);
  }
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      seq[scnt++] = x;
      s[v] -= s[u];
      f[u] = u;
    }
  }
}

int head[N], to[N], next[N], tot;
void add(int x, int y) {
  to[++tot] = y, next[tot] = head[x], head[x] = tot;
}
void del(int x, int y) {
  head[x] = next[tot--];
}

int tmp[N];
void dfs3(int x) {
  if (key[x]) return;
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      add(u, v), add(v, u);
    }
  } else if (q[x].opt == 3) {
    // std::cerr &lt;&lt; &#34;! dfs3 &#34; &lt;&lt; q[x].x &lt;&lt; &#34; &#34; &lt;&lt; q[x].y &lt;&lt; &#34;\n&#34;;
    static int que[N], r, vis[N], vcnt;
    que[r = 1] = q[x].x;
    vcnt++;
    for (int i = 1; i &lt;= r; i++) {
      int x = que[i];
      vis[x] = vcnt;
      for (int j = head[x]; j; j = next[j]) {
        int y = to[j];
        if (vis[y] == vcnt) continue;
        que[++r] = y;
      } 
    }
    while (ans[x] &lt; n) {
      if (vis[find2(b[ans[x]].second)] == vcnt &amp;&amp; !q[x].y--) break; 
      ans[x]++;
    }
  }
  for (int i = ch[x], y; y = g[i], i &lt; ch[x + 1]; i++) {
    dfs3(y);
  }
  if (q[x].opt == 1) {
    int u = q[x].x, v = q[x].y;
    if (u != v) {
      del(v, u), del(u, v);
    }
  }
}
void work(int x) {
  // std::cerr &lt;&lt; &#34;key &#34; &lt;&lt; x &lt;&lt; &#34;\n&#34;;
  memcpy(tmp, f, sizeof f);
  if (q[x].opt == 3) {
    while (ans[x] &lt; n) {
      if (find2(b[ans[x]].second) == q[x].x &amp;&amp; !q[x].y--) break; 
      ans[x]++;
    }
  }
  for (int i = ch[x], y; y = g[i], i &lt; ch[x + 1]; i++) dfs3(y);
  memcpy(f, tmp, sizeof f);
}

void dfs2(int x) {
  if (q[x].opt == 1 &amp;&amp; q[x].x != q[x].y) f[q[x].x] = q[x].y;
  int c = 0;
  for (int i = ch[x], y; y = g[i], i &lt; ch[x + 1]; i++) {
    dfs2(y);
    siz[x] += siz[y];
    if (bot[y]) {
      c++;
      bot[x] = bot[y];
    }
  }
  if (!x || siz[x] + 1 &gt;= T || c &gt; 1) {
    key[x] = true;
    bot[x] = x;
    siz[x] = 0;
    work(x);
  }
  siz[x]++;
  if (q[x].opt == 1 &amp;&amp; q[x].x != q[x].y) f[q[x].x] = q[x].x;
}

void solve() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i];
    b[i] = {a[i], i};
  }
  std::sort(b, b + n);
  for (int i = 0; i &lt; n; i++) {
    a[b[i].second] = i;
  }
  for (int i = 1; i &lt;= m; i++) {
    int opt, x, y = 0, &amp;f = fa[i];
    std::cin &gt;&gt; opt &gt;&gt; x;
    if (opt == 2) {
      f = x;
    } else {
      f = i - 1;
      std::cin &gt;&gt; y;
      x--, y--;
    }
    ch[f]++;
    q[i] = {opt, x, y};
  }
  for (int i = 1; i &lt;= m; i++) ch[i] += ch[i - 1];
  for (int i = 1; i &lt;= m; i++) g[--ch[fa[i]]] = i;
  for (int i = 0; i &lt; n; i++) f[i] = i, s[i] = 1;
  dfs1(0);
  int tot = (n - 1) / T + 1;
  for (int i = 0; i &lt; tot; i++) {
    for (int j = 0; j &lt; n; j++) {
      s[j] = a[j] / T == i;
    }
    for (int j = 0; j &lt; scnt; j++) {
      auto &amp;[opt, x, y] = q[seq[j]];
      if (opt == 1) {
        if (f[x] == x) {
          f[x] = y;
          s[y] += s[x];
        } else {
          f[x] = x;
          s[y] -= s[x];
        }
      } else {
        if (ans[seq[j]] / T != i) continue;
        if (s[x] &lt;= y) {
          y -= s[x];
          ans[seq[j]] += T;
        }
      }
    }
  }
  for (int i = 0; i &lt; n; i++) {
    assert(f[i] == i);
  }
  dfs2(0);
  for (int i = 1; i &lt;= m; i++) {
    if (q[i].opt == 3) {
      std::cout &lt;&lt; (ans[i] &gt;= n ? -1 : b[ans[i]].first) &lt;&lt; &#34;\n&#34;;
    }
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```


## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4690&#34;&gt;P4690 [Ynoi2016] 镜中的昆虫&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作。区间赋值，区间数颜色。
&gt; 
&gt; $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$
&gt; 
&gt; 空间 64MB。

数颜色的套路，数 $pre &lt; l, l \leq i \leq r$ 的个数，再加一维时间，是三维偏序问题。

用 set 维护区间同色段之后就变成单点修改了，用 CDQ 分治搞一下三维偏序就行，但是这毒瘤空间那么小，我好像搞了多次 CDQ 才卡过，但是后来一次也搞过了，忘了为啥。

时间复杂度 $O(n\log^2 n)$，空间复杂度 $O(n)$。


```cpp
// Author:  HolyK
// Created: Tue Apr 12 15:02:43 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), Q(N * 15);
int n, m, a[N], la, ans[N];
std::map&lt;int, std::set&lt;int&gt;&gt; g;
std::set&lt;int&gt; p;

struct Option {
  int x, l, r, id;
  bool operator&lt;(const Option &amp;rhs) const {
    return x &lt; rhs.x || x == rhs.x &amp;&amp; id &lt; rhs.id;
  }
} s[Q], t[Q];
int cnt;

namespace Fenwick {
int c[N];
void add(int p, int x) {
  for (; p &lt;= n; p += p &amp; -p) {
    c[p] += x;
  }
}
int ask(int p) {
  int r = 0;
  for (; p; p -= p &amp; -p) {
    r += c[p];
  }
  return r;
}
}
int st[Q];

void solve(int l, int r) {
  if (l == r) return;
  int m = l + r &gt;&gt; 1;
  solve(l, m), solve(m + 1, r);
  using namespace Fenwick;
  int i = l, j = m + 1;
  for (int k = l; k &lt;= r; k++) {
    if (j &gt; r || i &lt;= m &amp;&amp; s[i] &lt; s[j]) {
      if (!s[i].id) {
        add(s[i].l, s[i].r);
        st[++st[0]] = i;
      }
      t[k] = s[i++];
    } else {
      if (s[j].id) {
        ans[s[j].id] += ask(s[j].r) - ask(s[j].l - 1);
      }
      t[k] = s[j++];
    }
  }
  while (st[0]) {
    i = st[st[0]--];
    add(s[i].l, -s[i].r);
  }
  for (int k = l; k &lt;= r; k++) s[k] = t[k];
}

void add(int p, int i) {
  s[++cnt] = {p, i, 1, 0};
}
void del(int p, int i) {
  s[++cnt] = {p, i, -1, 0};
}
void ask(int l, int r, int id) {
  s[++cnt] = {l - 1, l, r, id};
}

std::set&lt;int&gt;::iterator split(int x) {
  auto u = p.insert(x);
  if (u.second) {
    int p = *std::prev(u.first);
    a[x] = a[p];
    auto &amp;v = g[a[x]];
    auto it = v.insert(x).first;
    add(p, x);
    if (++it != v.end()) del(p, *it), add(x, *it);
  }
  return u.first;
}


void solve() {
  std::cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; i++) {
    std::cin &gt;&gt; a[i];
    p.insert(i);
  }
  p.insert(n + 1);

  for (int i = 1; i &lt;= n; i++) {
    auto &amp;v = g[a[i]];
    auto it = v.insert(i).first;
    int p = it == v.begin() ? 0 : *std::prev(it);
    add(p, i);
  }

  for (int i = 1; i &lt;= m; i++) {
    int opt, l, r, x;
    std::cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;
    if (opt == 1) {
      split(++r);
      for (auto it = split(l); *it != r; it = p.erase(it)) {
        x = *it;
        auto &amp;v = g[a[x]];
        auto t = v.find(x);
        assert(t != v.end());
        int p = t == v.begin() ? 0 : *std::prev(t);
        t = v.erase(t);
        del(p, x);
        if (t != v.end()) {
          del(x, *t);
          add(p, *t);
        }
      }
      std::cin &gt;&gt; x;
      auto &amp;v = g[x];
      a[l] = x;
      p.insert(l);
      auto it = v.insert(l).first;
      int p = it == v.begin() ? 0 : *std::prev(it);
      add(p, l);
      if (++it != v.end()) {
        del(p, *it);
        add(l, *it);
      }
    } else {
      split(l);
      ask(l, r, ++la);
    }
  }
  solve(1, cnt);
  for (int i = 1; i &lt;= la; i++) {
    std::cout &lt;&lt; ans[i] &lt;&lt; &#34;\n&#34;;
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P5073&#34;&gt;P5073 [Ynoi2015] 世上最幸福的女孩&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作，全局加，区间求最大子段和。
&gt; 
&gt; $1 \leq n \leq 3\times 10^5, 1 \leq m \leq 6\times 10^5$。
&gt; 
&gt; 空间 128MB。

考虑经典线段树做法维护前后缀以及答案。

对于全局加了 $a$，设原先长度为 $a$ 的答案为 $b$，那么新的答案是 $ax + b$，是经典的维护凸包问题。

对于合并左子树后缀和右子树前缀的情况，可以发现是闵可夫斯基和。

线段树维护一下几个凸包就行。

然后将询问离线，把 $x$ 从小到大排序，就可以不用在凸包上二分。

但是这样空间炸了。

考虑可以一层一层做，在线段树上从底向上做，每次只存一层的信息即可。

但我还是没卡过去空间，所以经典卡空间方法：考虑将序列分块，每块都重新建线段树算一遍，又好写又快。

实现的时候，把线段树底层改成暴力会有很明显的优化效果。

写这个的时候，维护凸包用的是 kactl 里面那个 lineContainer 的方法，有除法，有点不优，不如直接维护算了。

```cpp
// Author:  HolyK
// Created: Mon Apr 25 10:14:03 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

namespace {
inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

constexpr int N(3e5 + 5), B(N &gt;&gt; 2), T(16);
constexpr LL INF(LLONG_MAX);
struct Line {
  int x;
  LL y, p;
  bool operator&lt;(LL r) const { return p &lt; r; }

  LL eval(LL z) { return x * z + y; } 
};
using C = std::vector&lt;Line&gt;;

LL div(LL a, LL b) {
  return a / b - ((a ^ b) &lt; 0 &amp;&amp; a % b);
}
void get(Line &amp;a, const Line &amp;b) {
  if (a.x == b.x) {
    a.p = a.y &gt; b.y ? INF : -INF;
  } else {
    a.p = div(a.y - b.y, b.x - a.x);
  }
}
void add(C &amp;c, int x, LL y) {
  Line o = {x, y, INF};
  if (c.empty()) {
    c.push_back(o);
    return;
  }
  while (c.size() &gt; 1) {
    get(c.back(), o);
    if (c[c.size() - 2].p &lt; c.back().p) break;
    c.pop_back();
  }
  get(c.back(), o);
  c.push_back(o);
}


int n, m, a[N];
LL b[N];
struct Node {
  C pre, suf, ans;
  LL sum;
  int pl, sl, al;
} t[B &gt;&gt; 2];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1

C msum(const C &amp;a, const C &amp;b) {
  C c = {Line{a[0].x + b[0].x, a[0].y + b[0].y, INF}};
  for (int i = 0, j = 0; i + 1 &lt; a.size() || j + 1 &lt; b.size(); ) {
    Line &amp;o = c.back();
    if (j + 1 == b.size() || i + 1 &lt; a.size() &amp;&amp; a[i].p &lt; b[j].p) {
      add(c, o.x + a[i + 1].x - a[i].x, o.y + a[i + 1].y - a[i].y);
      i++;
    } else {
      add(c, o.x + b[j + 1].x - b[j].x, o.y + b[j + 1].y - b[j].y);
      j++;
    }
  }
  return c;
}
C merge(const C &amp;a, const C &amp;b) {
  C c;
  for (int i = 0, j = 0; i &lt; a.size() || j &lt; b.size(); ) {
    if (j == b.size() || i &lt; a.size() &amp;&amp; a[i].x &lt; b[j].x) {
      add(c, a[i].x, a[i].y);
      i++;
    } else {
      add(c, b[j].x, b[j].y);
      j++;
    }
  }
  return c;
}

void build(int o, int l, int r) {
  t[o].pl = t[o].sl = t[o].al = 0;
  if (r - l + 1 &lt;= T) {
    t[o].pre.clear();
    t[o].suf.clear();
    t[o].ans.clear();
    LL s = 0;
    add(t[o].pre, 0, 0);
    for (int i = 1; i &lt;= r - l + 1; i++) {
      s += a[l + i - 1];
      add(t[o].pre, i, s);
    }
    s = 0;
    add(t[o].suf, 0, 0);
    for (int i = 1; i &lt;= r - l + 1; i++) {
      s += a[r - i + 1];
      add(t[o].suf, i, s);
    }
    add(t[o].ans, 0, 0);
    for (int i = 1; i &lt;= r - l + 1; i++) {
      LL max = -INF;
      for (int j = l + i - 1; j &lt;= r; j++) {
        smax(max, b[j] - b[j - i]);
      }
      add(t[o].ans, i, max);
    }
    t[o].sum = s;
    return;
  }
  int m = l + r &gt;&gt; 1;
  build(ls, l, m);
  build(rs, m + 1, r);

  t[o].pre = t[ls].pre;
  for (auto &amp;[x, y, _] : t[rs].pre) {
    add(t[o].pre, x + m - l + 1, y + t[ls].sum);
  }
  t[o].suf = t[rs].suf;
  for (auto &amp;[x, y, _] : t[ls].suf) {
    add(t[o].suf, x + r - m, y + t[rs].sum);
  }
  t[o].ans = merge(merge(t[ls].ans, t[rs].ans), msum(t[ls].suf, t[rs].pre));
  t[o].sum = t[ls].sum + t[rs].sum;
}

struct Info {
  LL r, a;
  void apply(LL pre, LL suf, LL ans, LL sum) {
    smax(a, ans);
    smax(a, r + pre);
    r = std::max(suf, r + sum);
  }
} qans[N * 2];

LL ask(const C &amp;c, LL x) {
  auto l = std::lower_bound(c.begin(), c.end(), x);
  assert(l != c.end());
  return l-&gt;x * x + l-&gt;y;
}

void ask(int o, int l, int r, int x, int y, LL z, int id) {
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    auto &amp;pl = t[o].pl, &amp;sl = t[o].sl, &amp;al = t[o].al;
    while (t[o].pre[pl].p &lt; z) pl++;
    while (t[o].suf[sl].p &lt; z) sl++;
    while (t[o].ans[al].p &lt; z) al++;
    qans[id].apply(t[o].pre[pl].eval(z), t[o].suf[sl].eval(z), t[o].ans[al].eval(z), t[o].sum + z * (r - l + 1));
    return;
  }
  if (r - l + 1 &lt;= T) {
    LL pre, suf, ans, sum, max = 0;
    pre = suf = ans = sum = 0;
    for (int i = std::max(x, l); i &lt;= r &amp;&amp; i &lt;= y; i++) {
      sum += a[i] + z;
      smax(pre, sum);
      smax(ans, sum + max);
      smax(max, -sum);
    }
    sum = 0;
    for (int i = std::min(r, y); i &gt;= l &amp;&amp; i &gt;= x; i--) {
      sum += a[i] + z;
      smax(suf, sum);
    }
    qans[id].apply(pre, suf, ans, sum);
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) ask(ls, l, m, x, y, z, id);
  if (y &gt; m) ask(rs, m + 1, r, x, y, z, id);
}


struct Qry {
  int l, r, id;
  LL x;
  bool operator&lt;(const Qry &amp;rhs) const {
    return x &lt; rhs.x;
  }
} q[N * 2];
int qq;
void solve() {
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], b[i] = a[i] + b[i - 1];
  LL d = 0;
  while (m--) {
    int opt, l, r;
    cin &gt;&gt; opt;
    if (opt == 1) {
      cin &gt;&gt; l;
      d += l;
    } else {
      cin &gt;&gt; l &gt;&gt; r;
      q[qq] = {l, r, qq, d};
      qq++;
    }
  }
  std::sort(q, q + qq);
  for (int l = 1, r; l &lt;= n; l += B) {
    r = std::min(l + B - 1, n);
    build(1, l, r);
    for (int i = 0; i &lt; qq; i++) {
      if (q[i].r &lt; l || q[i].l &gt; r) continue;
      ask(1, l, r, q[i].l, q[i].r, q[i].x, q[i].id);
    }
  }
  for (int i = 0; i &lt; qq; i++) {
    std::cout &lt;&lt; qans[i].a &lt;&lt; &#34;\n&#34;;
  }
}
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}
```

## &lt;a href = &#34;https://www.luogu.com.cn/problem/P4118&#34;&gt;P4118 [Ynoi2018] 末日时在做什么？有没有空？可以来拯救吗？&lt;/a&gt;
&gt; 给定序列 $a_n$，$m$ 次操作，区间加，区间求最大子段和。
&gt; 
&gt; $1 \leq n, m \leq 10^5$。
&gt; 
&gt; 空间 64 MB。

上面那题的进阶版本，1秒时限太毒瘤了，卡不过去，所以这题是 80 分。

顺着上题思路，分块之后每块处理。

修改和询问会变成 $O(m\sqrt n)$ 次全局操作和 $O(m)$ 次区间操作。

对于全局加全局查询，按照上题的做法，把询问按照 $x$ 基数排序，每次做凸包指针移动次数是 $O(\sqrt n)$。

对于区间修改，会使得把全局查询的凸包指针失效，但是只会修改 $O(m)$ 次，所以每次修改之后重置指针，复杂度是 $O(m\sqrt n)$。

区间修改，在线段树上更新凸包，这样做的复杂度是 $O(\sqrt n+ \sqrt n/2+ \sqrt n/4+\dots) = O(\sqrt n)$，所以每次直接在线段树上搞，复杂度是 $O(m\sqrt n)$。

区间查询，每次查询可以是 $O(\sqrt n)$ 的，但是这样写可能常数比较大，我写的是在线段树上查询，每个凸包二分一下，复杂度是 $O(m \log^2 n)$。

线段树底层仍然要暴力。

对于信息合并，直接归并的复杂度太高了，观察这个凸包，发现 $x$ 坐标的范围是 $1 \dots len$，所以说可以类似桶排序，对于每个 $x$ 坐标存一下 $y$ 坐标的最大值，这样 cache 友好，卡常效果明显。

这个信息，本来是用 vector 存，后面卡常把 vector 扔掉了，最后还是没卡过去，真是尽力了。

```cpp
// Author:  HolyK
// Created: Wed Apr 27 14:32:40 2022
#include &lt;bits/stdc++.h&gt;

inline char gc() {
  static constexpr int BufferSize = 1 &lt;&lt; 22 | 5;
  static char buf[BufferSize], *p, *q;
  static std::streambuf *i = std::cin.rdbuf();
  return p == q ? p = buf, q = p + i-&gt;sgetn(p, BufferSize), p == q ? EOF : *p++ : *p++;
}
struct Reader {
  template &lt;class T&gt;
  Reader &amp;operator&gt;&gt;(T &amp;w) {
    char c, p = 0;
    for (; !std::isdigit(c = gc());) if (c == &#39;-&#39;) p = 1;
    for (w = c &amp; 15; std::isdigit(c = gc()); w = w * 10 + (c &amp; 15)) ;
    if (p) w = -w;
    return *this;
  }
} cin;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int N(1e5 + 5), T(8), B(T &lt;&lt; 6);
constexpr LL INF(LLONG_MAX / 3);
struct Pt {
  int x;
  LL y;
  Pt operator+(const Pt &amp;r) const { return {x + r.x, y + r.y}; }
  Pt operator-(const Pt &amp;r) const { return {x - r.x, y - r.y}; }
  LL operator*(const Pt &amp;r) const { return x * r.y - y * r.x; }
  LL cross(const Pt &amp;a, const Pt &amp;b) const { return (a - *this) * (b - *this); }
  LL eval(LL z) const { return x * z + y; }
} pt[B * 30], s[B + 5];
int ptr;

struct Hull {
  int l, r;
  Pt *begin() const { return pt + l; }
  Pt *data() const { return begin(); }
  Pt *end() const { return pt + r; }
  int size() const { return r - l; }
  void assign(Pt *s, Pt *e) {
    r = l + (e - s);
    memcpy(pt + l, s, (e - s) * sizeof(*s));
  }
  Pt &amp;operator[](const int &amp;i) const {
    // assert(0 &lt;= i &amp;&amp; i &lt; size());
    return pt[l + i];
  }
};
using C = Hull;
// using C = std::vector&lt;Pt&gt;;

void fwd(const C &amp;c, int &amp;p, LL x) {
  while (p + 1 &lt; c.size() &amp;&amp; c[p].y - c[p + 1].y &lt; x * (c[p + 1].x - c[p].x)) p++;
}

int top;
void add(Pt x) {
  while (top &gt; 1 &amp;&amp; s[top - 2].cross(s[top - 1], x) &gt;= 0) top--;
  s[top++] = x;
}

LL val[B + 5];
void update(const Pt &amp;x) { smax(val[x.x], x.y); }
void cal(int n) {
  top = 0;
  for (int i = 1; i &lt;= n; i++) if (val[i] != -INF) add({i, val[i]});
}

struct Node {
  C pre, suf, ans;
  LL sum;
} t[B &lt;&lt; 2];
LL tag[B &lt;&lt; 2];
#define ls o &lt;&lt; 1
#define rs o &lt;&lt; 1 | 1
void pushup(int o, int len) {
  int ll = len - len / 2, rr = len / 2, tmp = ptr;
  LL l = t[ls].sum + tag[ls] * ll, r = t[rs].sum + tag[rs] * rr;
  C lsuf, rpre;
  lsuf.l = ptr -= t[ls].suf.size();
  lsuf.assign(t[ls].suf.begin(), t[ls].suf.end());
  rpre.l = ptr -= t[rs].pre.size();
  rpre.assign(t[rs].pre.begin(), t[rs].pre.end());
  // auto lsuf = t[ls].suf, rpre = t[rs].pre;
  
  // pre
  top = t[ls].pre.size();
  memcpy(s, t[ls].pre.data(), top * sizeof(*s));
  for (int i = 0; i &lt; top; i++) s[i].y += s[i].x * tag[ls];
  int cur = top;
  for (auto &amp;[x, y] : rpre) {
    y += x * tag[rs];
    s[cur++] = {x + ll, y + l};
  }
  for (int i = top; i &lt; cur; i++) add(s[i]);
  t[o].pre.assign(s, s + top);

  // suf
  top = t[rs].suf.size();
  memcpy(s, t[rs].suf.data(), top * sizeof(*s));
  for (int i = 0; i &lt; top; i++) s[i].y += s[i].x * tag[rs];
  cur = top;
  for (auto &amp;[x, y] : lsuf) {
    y += x * tag[ls];
    s[cur++] = {x + rr, y + r};
  }
  for (int i = top; i &lt; cur; i++) add(s[i]);
  t[o].suf.assign(s, s + top);

  // ans: lr
  for (int i = 1; i &lt;= len; i++) val[i] = -INF;
  for (auto &amp;[x, y] : t[ls].ans) smax(val[x], y + x * tag[ls]);
  for (auto &amp;[x, y] : t[rs].ans) smax(val[x], y + x * tag[rs]);

  // ans: merge
  update(lsuf[0] + rpre[0]);
  for (int i = 0, j = 0; i + 1 &lt; lsuf.size() || j + 1 &lt; rpre.size(); ) {
    if (j + 1 == rpre.size() || i + 1 &lt; lsuf.size() &amp;&amp; (lsuf[i + 1] - lsuf[i]) * (rpre[j + 1] - rpre[j]) &lt; 0) {
      i++;
    } else {
      j++;
    }
    update(lsuf[i] + rpre[j]);
  }
  cal(len);
  t[o].ans.assign(s, s + top);
  
  t[o].sum = l + r;
  
  ptr = tmp;
}

LL a[N];
void init(int o, int l, int r) {
  LL sum = 0;
  top = 0;
  for (int i = l; i &lt;= r; i++) {
    sum += a[i];
    add({i - l + 1, sum});
  }
  t[o].pre.assign(s, s + top);
  top = 0, sum = 0;
  for (int i = r; i &gt;= l; i--) {
    sum += a[i];
    add({r - i + 1, sum});
  }
  t[o].suf.assign(s, s + top);
  t[o].sum = sum;
  for (int i = 1; i &lt;= r - l + 1; i++) val[i] = -INF;
  for (int i = l; i &lt;= r; i++) {
    sum = 0;
    for (int j = i; j &lt;= r; j++) {
      sum += a[j];
      smax(val[j - i + 1], sum);
    }
  }
  cal(r - l + 1);
  t[o].ans.assign(s, s + top);
}

void build(int o, int l, int r) {
  t[o].pre.l = ptr -= r - l + 1;
  t[o].suf.l = ptr -= r - l + 1;
  t[o].ans.l = ptr -= r - l + 1;
  tag[o] = 0;
  if (r - l + 1 &lt;= T) {
    init(o, l, r);
    return;
  }
  int m = l + r &gt;&gt; 1;
  build(ls, l, m);
  build(rs, m + 1, r);
  pushup(o, r - l + 1);
}


void update(int o, int l, int r, int x, int y, LL z) {
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    tag[o] += z;
    return;
  }
  if (r - l + 1 &lt;= T) {
    // std::cerr &lt;&lt; &#34;updateI &#34; &lt;&lt; l &lt;&lt; &#34; &#34; &lt;&lt; r &lt;&lt; &#34; &#34; &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; &#34;\n&#34;;
    for (int i = std::max(l, x); i &lt;= r &amp;&amp; i &lt;= y; i++) a[i] += z;
    init(o, l, r);
    return;
  }
  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) update(ls, l, m, x, y, z);
  if (y &gt; m) update(rs, m + 1, r, x, y, z);
  pushup(o, r - l + 1);
}

struct Info {
  LL r, a;
  void apply(LL pre, LL suf, LL ans, LL sum) {
    smax(a, ans);
    smax(a, r + pre);
    r = std::max(suf, r + sum);
  }
} qans[N];


LL ask(const C &amp;c, LL x) {
  int l = 0, r = c.size() - 1;
  while (l &lt; r) {
    int m = l + r &gt;&gt; 1;
    if (c[m].y - c[m + 1].y &lt; x * (c[m + 1].x - c[m].x)) {
      l = m + 1;
    } else {
      r = m;
    }
  }
  return c[l].eval(x);
}

void ask(int o, int l, int r, int x, int y, int id, LL z) {
  z += tag[o];
  if (x &lt;= l &amp;&amp; r &lt;= y) {
    qans[id].apply(ask(t[o].pre, z), ask(t[o].suf, z), ask(t[o].ans, z), t[o].sum + z * (r - l + 1));
    return;
  }
  if (r - l + 1 &lt;= T) {
    LL pre, suf, ans, sum, max;
    pre = suf = ans = sum = max = 0;
    for (int i = std::max(x, l); i &lt;= r &amp;&amp; i &lt;= y; i++) {
      sum += a[i] + z;
      smax(pre, sum);
      smax(ans, sum + max);
      smax(max, -sum);
    }
    sum = 0;
    for (int i = std::min(r, y); i &gt;= l &amp;&amp; i &gt;= x; i--) {
      sum += a[i] + z;
      smax(suf, sum);
    }
    qans[id].apply(pre, suf, ans, sum);
    return;
  }

  int m = l + r &gt;&gt; 1;
  if (x &lt;= m) ask(ls, l, m, x, y, id, z);
  if (y &gt; m) ask(rs, m + 1, r, x, y, id, z);
}


struct Operation {
  int opt, l, r, x;
} op[N];
struct Qry {
  LL x;
  int id;
} q[N], nq[N];

void solve() {
  int n, m;
  cin &gt;&gt; n &gt;&gt; m;
  for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];
  for (int i = 0; i &lt; m; i++) {
    int opt, l, r, x = 0;
    cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r;
    if (opt == 1) cin &gt;&gt; x;
    op[i] = {opt, l, r, x};
  }

  for (int l = 1; l &lt;= n; l += B) {
    ptr = B * 30;
    int r = std::min(l + B - 1, n);
    build(1, l, r);
    int pl, sl, al, qn;

    auto init = [&amp;] { pl = sl = al = qn = 0; };

    auto run = [&amp;] {
      if (!qn) return;
      if (qn &gt; 800) {
        LL min = LLONG_MAX;
        for (int i = 0; i &lt; qn; i++) smin(min, q[i].x);
        for (int i = 0; i &lt; qn; i++) q[i].x -= min;
        static int c[256];
#define SORT(a, b, n, d)                                                \
        memset(c, 0, sizeof c);                                         \
        for (int i = 0; i &lt; n; i++) c[a[i].x &gt;&gt; d &amp; 0xff]++;            \
        for (int i = 1; i &lt; 256; i++) c[i] += c[i - 1];                 \
        for (int i = qn - 1; i &gt;= 0; i--) b[--c[a[i].x &gt;&gt; d &amp; 0xff]] = a[i];

        SORT(q, nq, qn, 0);
        SORT(nq, q, qn, 8);
        SORT(q, nq, qn, 16);
        SORT(nq, q, qn, 24);
        
        for (int i = 0; i &lt; qn; i++) q[i].x += min;
      } else {
        std::sort(q, q + qn, [&amp;](const Qry &amp;i, const Qry &amp;j) { return i.x &lt; j.x; });
      }
      for (int i = 0; i &lt; qn; i++) {
        fwd(t[1].pre, pl, q[i].x);
        fwd(t[1].suf, sl, q[i].x);
        fwd(t[1].ans, al, q[i].x);
        qans[q[i].id].apply(t[1].pre[pl].eval(q[i].x), t[1].suf[sl].eval(q[i].x), t[1].ans[al].eval(q[i].x), t[1].sum + (r - l + 1) * q[i].x);
      }
    };
    
    init();
    for (int i = 0; i &lt; m; i++) {
      if (op[i].r &lt; l || op[i].l &gt; r) continue;
      if (op[i].l &lt;= l &amp;&amp; r &lt;= op[i].r) {
        if (op[i].opt == 1) {
          tag[1] += op[i].x;
        } else {
          q[qn++] = {tag[1], i};
        }
      } else {
        if (op[i].opt == 1) {
          run();
          init();
          update(1, l, r, op[i].l, op[i].r, op[i].x);
        } else {
          ask(1, l, r, op[i].l, op[i].r, i, 0);
        }
      }
    }
    run();
  }
  for (int i = 0; i &lt; m; i++) {
    if (op[i].opt == 2) {
      std::cout &lt;&lt; qans[i].a &lt;&lt; &#34;\n&#34;;
    }
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  // freopen(&#34;t.out&#34;, &#34;w&#34;, stdout);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }

  std::cerr &lt;&lt; (double)clock() / CLOCKS_PER_SEC &lt;&lt; &#34;\n&#34;;
  return 0;
}
```- https://blog.asukakyle.top/post/ynoi/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>常系数齐次线性递推小记</title>
        <link>https://blog.asukakyle.top/post/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%B0%8F%E8%AE%B0/</link>
        <pubDate>Mon, 21 Feb 2022 23:11:13 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%B0%8F%E8%AE%B0/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%B0%8F%E8%AE%B0/ -## 常系数齐次线性递推
对于 $n \geq k$，$\sum_{i=0}^kq_ia_{n-i}=0$，其中 $q_0 \neq 0$。

数列 $a_n$ 的生成函数为 $A(x)$。

上式左边看作卷积，右边看作生成函数 $P(x)$ 的 $n \geq k$ 时的系数。

$$
Q(x)A(x) = P(x)
$$
$$
A(x) = \frac{P(x)}{Q(x)}
$$

$P(x)$ 为 $k-1$ 次多项式，$Q(x)$ 为 $k$ 次多项式。

然后就是解决 $[x^n]\dfrac{P(x)}{Q(x)}$ 的问题。

使用 EI 提到的方法，考虑
$$
\frac{P(x)}{Q(x)} = \frac{P(x)Q(-x)}{Q(x)Q(-x)}
$$
由于 $Q(x)Q(-x) = Q(-x)Q(x)$，所以它只有偶次项有值，设 $U(x^2) = Q(x)Q(-x)$，
$$
\frac{P(x)}{Q(x)} = \frac{E(x^2)}{U(x^2)}+x\frac{O(x^2)}{U(x^2)}
$$
只需要递归到一侧即可。

朴素实现只需要写多项式乘法，优化的实现已经在多项式板子里。

```cpp
int divAt(Poly p, Poly q, LL n) {
  for (; n; n &gt;&gt;= 1) {
    Poly r(q);
    for (int i = 1; i &lt; r.size(); i += 2) r[i] = P - r[i];
    Poly u = p * r, v = q * r;
    p.clear();
    for (int i = n &amp; 1; i &lt; u.size(); i += 2) p.push_back(u[i]);
    for (int i = 0; i &lt; q.size(); i++) q[i] = v[i * 2];
  }
  return 1LL * p[0] * fpow(q[0]) % P;
}
```


## Berlekamp Massey 算法
懒得学，直接拖 tourist 的板子。

```cpp
template &lt;typename T&gt;
std::vector&lt;T&gt; bm(std::vector&lt;T&gt; a) {
  std::vector&lt;T&gt; p = {1}, q = {1};
  int l = 0;
  for (int r = 1; r &lt;= (int) a.size(); r++) {
    T delta = 0;
    for (int j = 0; j &lt;= l; j++) {
      delta += a[r - 1 - j] * p[j];
    }
    q.insert(q.begin(), 0);
    if (delta != 0) {
      vector&lt;T&gt; t = p;
      if (q.size() &gt; t.size()) {
        t.resize(q.size());
      }
      for (int i = 0; i &lt; (int) q.size(); i++) {
        t[i] -= delta * q[i];
      }
      if (2 * l &lt;= r - 1) {
        q = p;
        T od = 1 / delta;
        for (T&amp; x : q) {
          x *= od;
        }
        l = r - l;
      }
      swap(p, t);
    }
  }
  assert((int) p.size() == l + 1);
  reverse(p.begin(), p.end());
  return p;
}
```
- https://blog.asukakyle.top/post/%E5%B8%B8%E7%B3%BB%E6%95%B0%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%80%92%E6%8E%A8%E5%B0%8F%E8%AE%B0/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
    
        <item>
        <title>2022 Ptz winter camp</title>
        <link>https://blog.asukakyle.top/post/2022ptzwinter/</link>
        <pubDate>Sun, 13 Feb 2022 19:25:10 +0800</pubDate>
        
        <guid>https://blog.asukakyle.top/post/2022ptzwinter/</guid>
        <description>HolyK&#39;s Blog https://blog.asukakyle.top/post/2022ptzwinter/ -Ptz camp 的部分题。

题目是乱序的。

## E3 Mountains
&gt; 求 $n \times m$ 的非负矩阵个数，满足 $(1, 1)$ 到 $(n, m)$ 的最大路径和不超过 $k$。答案对 $10^9 + 7$ 取模。
&gt; 
&gt; $1 \leq n, m, k \leq 100$

最大路径和，有个经典DP。

$$
dp_{i, j} = a_{i, j} + \max \{ dp_{i - 1, j}, dp_{i, j - 1} \}
$$

由 $a_{i, j} \geq 0$，得到 $dp_{i, j} \geq dp_{i - 1, j}, dp_{i, j} \geq dp_{i, j - 1}$。

然后还有 $dp_{n, m} \leq k$。

由上面的等式可知a和dp数组可以相互转化，所以问题转化为求dp矩阵的个数。

画出三维的方块图，$dp_{i, j}$ 表示 (i, j) 上有 $dp_{i, j}$ 个方块，然后可以转化为不相交路径计数，用LGV引理解决。

![](e3.png)

```cpp
void solve() {
  int n, m, k;
  std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
  std::vector&lt;std::vector&lt;Z&gt;&gt; bin(k + m + 1, std::vector&lt;Z&gt;(k + m + 1));
  for (int i = 0; i &lt;= k + m; i++) {
    bin[i][0] = 1;
    for (int j = 1; j &lt;= i; j++) {
      bin[i][j] = bin[i - 1][j] + bin[i - 1][j - 1];
    }
  }
  std::vector&lt;std::vector&lt;Z&gt;&gt; a(n, std::vector&lt;Z&gt;(n));
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      a[i][j] = m + j - i &lt; 0 || j - i &gt; k ? 0 : bin[k + m][m + j - i];
    }
  }

  Z ans = 1;
  for (int i = 0; i &lt; n; i++) {
    for (int j = i; j &lt; n; j++) {
      if (a[j][i]) {
        std::swap(a[i], a[j]);
        break;
      }
    }
    if (!a[i][i]) {
      ans = 0;
      break;
    }
    ans *= a[i][i];
    for (int j = i + 1; j &lt; n; j++) {
      if (a[j][i]) {
        Z c = a[j][i] / a[i][i];
        for (int k = 0; k &lt; n; k++) {
          a[j][k] -= c * a[i][k];
        }
      }
    }
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```

## I3 Box Packing

&gt; 给定 $n$ 个二元组 $(a_i, b_i)$，按字典序有序。
&gt; 
&gt; 求最长的子序列长度，满足该子序列可以划分成不超过k个a,b均单调不降的子序列。
&gt; 
&gt; $1 \leq n \leq 10^5, 1 \leq k \leq 100$

[Young tableau](https://oi-wiki.org/math/young-tableau/)

杨表。科技题，证明还non-trival，难搞哦。

19年集训队论文《浅谈杨氏矩阵在信息学竞赛中的应用》


```cpp
void solve() {
  int n, k;
  std::cin &gt;&gt; n &gt;&gt; k;
  std::vector&lt;PII&gt; a(n);
  for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; a[i].first &gt;&gt; a[i].second;
  std::sort(a.begin(), a.end());
  std::vector&lt;std::vector&lt;int&gt;&gt; p;
  for (auto [_, x] : a) {
    for (int i = 0; i &lt;= p.size() &amp;&amp; i &lt; k; i++) {
      if (i == p.size()) {
        p.push_back({x});
        break;
      }
      auto it = std::upper_bound(p[i].begin(), p[i].end(), x);
      if (it == p[i].end()) {
        p[i].push_back(x);
        break;
      }
      std::swap(x, *it);
    }
  }
  p.resize(k);
  int ans = 0;
  for (int i = 0; i &lt; k; i++) {
    ans += p[i].size();
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```

## K3 Fancy Arrays
&gt; 求长度为 $n$ 的序列 $a$ 的数量，满足 $a_i | m, \operatorname{gcd}(a_i, a_{i+1})&gt;1$。$q$ 次询问 $n$。
&gt; 
&gt; $m \leq 10^{16}, q \leq 150, n \leq 10^{18}$。

$m$ 质因数分解后，指数相同的质因子是等价的，划分成一个类，状态表示为等价类内选择了多少个质因子。

状态数 $N$ 不超过256个，预处理出转移矩阵的幂 $M, M^2, M^4, M^8, \dots$。

这样每次矩阵乘一个向量是 $O(N^2)$ 的。

总复杂度 $O(N^3\log n + qN^2\log n)$

这题还可以直接 BM，下面是牛逼群友的解释：

You need to count some number of paths in graph, number of paths is equal to sum of A^n * v, where A is transition matrix and v is initial vector. Any element of A^n*v follows linear recurrence defined by minimal polynomial of A, so answer for the problem also follows linear recurrence.

```cpp
// Author:  HolyK
// Created: Sun Feb 13 22:37:24 2022
#include &lt;bits/stdc++.h&gt;

template &lt;class T, class U&gt;
inline bool smin(T &amp;x, const U &amp;y) {
  return y &lt; x ? x = y, 1 : 0;
}
template &lt;class T, class U&gt;
inline bool smax(T &amp;x, const U &amp;y) {
  return x &lt; y ? x = y, 1 : 0;
}

using LL = long long;
using PII = std::pair&lt;int, int&gt;;

constexpr int P(1e9 + 7);
inline void inc(int &amp;x, int y) {
  x += y;
  if (x &gt;= P) x -= P;
}
inline void dec(int &amp;x, int y) {
  x -= y;
  if (x &lt; 0) x += P;
}
inline int mod(LL x) { return x % P; }
int fpow(int x, int k = P - 2) {
  int r = 1;
  for (; k; k &gt;&gt;= 1, x = 1LL * x * x % P) {
    if (k &amp; 1) r = 1LL * r * x % P;
  }
  return r;
}
struct Z {
  int x;
  Z() : x(0) {}
  Z(int v) : x(v &lt; 0 ? v + P : v &gt;= P ? v - P : v) {}
  Z(LL v) : x((v %= P) &lt; 0 ? v + P : v) {}
  explicit operator bool() { return !!x; }
  Z inv() const { return Z(fpow(x)); }
  Z pow(int k) const { return Z(fpow(x, k)); }
  Z operator-() const { return Z(P - x); }
  Z &amp;operator+=(const Z &amp;r) { return inc(x, r.x), *this; }
  Z &amp;operator-=(const Z &amp;r) { return dec(x, r.x), *this; }
  Z &amp;operator*=(const Z &amp;r) { return x = LL(x) * r.x % P, *this; }
  Z &amp;operator/=(const Z &amp;r) { return x = LL(x) * fpow(r.x) % P, *this; }
  inline friend Z operator+(const Z &amp;a, const Z &amp;b) { return Z(a) += b; }
  inline friend Z operator-(const Z &amp;a, const Z &amp;b) { return Z(a) -= b; }
  inline friend Z operator*(const Z &amp;a, const Z &amp;b) { return Z(a) *= b; }
  inline friend Z operator/(const Z &amp;a, const Z &amp;b) { return Z(a) /= b; }
  inline friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Z &amp;r) {
    return os &lt;&lt; r.x;
  }
};

constexpr int N(233 + 5);
int fac[N], ifac[N];
int bin(int n, int m) {
  if (m &lt; 0 || m &gt; n) return 0;
  return 1LL * fac[n] * ifac[m] % P * ifac[n - m] % P;
}
void init(int n) {
  fac[0] = ifac[0] = 1;
  for (int i = 1; i &lt;= n; i++) fac[i] = 1LL * fac[i - 1] * i % P;
  ifac[n] = fpow(fac[n]);
  for (int i = n - 1; i &gt; 0; i--) ifac[i] = 1LL * ifac[i + 1] * (i + 1) % P;
}

using Poly = std::vector&lt;int&gt;;
using Matrix = std::vector&lt;Poly&gt;;
Matrix operator*(const Matrix &amp;a, const Matrix &amp;b) {
  int n = a.size();
  Matrix c(n, Poly(n));
  for (int i = 0; i &lt; n; i++) {
    for (int k = 0; k &lt; n; k++) {
      for (int j = 0; j &lt; n; j++) {
        c[i][j] = (c[i][j] + 1LL * a[i][k] * b[k][j]) % P;
      }
    }
  }
  return c;
}
Poly operator*(const Poly &amp;a, const Matrix &amp;b) {
  int n = a.size();
  Poly r(n);
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      r[j] = (r[j] + 1LL * a[i] * b[i][j]) % P;
    }
  }
  return r;
}

using LLL = __int128_t;
LL fpow(LL x, LL k, LL p) {
  LL r = 1;
  for (; k; k &gt;&gt;= 1, x = (LLL)x * x % p) {
    if (k &amp; 1) r = (LLL)r * x % p;
  }
  return r;
}
bool isPrime(LL p) {
  if (p &lt; 2) return false;
  if (p == 2 || p == 3) return true;
  LL d = p - 1, r = 0;
  static std::mt19937 rnd(19260817);
  for (; d &amp; 1 ^ 1; d &gt;&gt;= 1) r++;
  for (LL k = 0; k &lt; 10; k++) {
    LL a = rnd() % (p - 2) + 2, x = fpow(a, d, p);
    if (x == 1 || x == p - 1) continue;
    for (int i = 0; i &lt; r - 1 &amp;&amp; x != p - 1; i++) {
      x = (LLL)x * x % p;
    }
    if (x != p - 1) return false;
  }
  return true;
}
LL pr(LL n) {
  auto f = [&amp;](LL x) { return (LLL)x * x % n + 1; };
  LL p = 2, q;
  for (LL i = 1, x = 0, y = 0, t = 30; t++ % 40 || std::gcd(p, n) == 1; x = f(x), y = f(f(y))) {
    if (x == y) x = ++i, y = f(x);
    q = (LLL)p * (x - y &gt; 0 ? x - y : y - x) % n;
    if (q) p = q;
  }
  return std::gcd(p, n);
}
std::vector&lt;LL&gt; factor(LL n) {
  if (n == 1) return {};
  if (isPrime(n)) return {n};
  LL x = pr(n);
  auto l = factor(x), r = factor(n / x);
  l.insert(l.end(), r.begin(), r.end());
  return l;
}

void solve() {
  LL m, q, n;
  std::cin &gt;&gt; m &gt;&gt; q;

  auto fac = factor(m);
  std::sort(fac.begin(), fac.end());
  std::map&lt;int, int&gt; cnt;
  for (int i = 0, j; i &lt; fac.size(); i = j) {
    for (j = i + 1; j &lt; fac.size() &amp;&amp; fac[i] == fac[j]; j++) ;
    cnt[j - i]++;
  }
  // for (auto [x, y] :cnt) {
  //   std::cerr &lt;&lt; &#34;!cnt &#34; &lt;&lt; x &lt;&lt; &#34; &#34; &lt;&lt; y &lt;&lt; &#34;\n&#34;;
  // }
  
  init(200);
  
  std::vector&lt;PII&gt; a(cnt.begin(), cnt.end());

  LL tot = 1;
  for (auto [x, y] : a) tot *= y + 1;

  // std::cerr &lt;&lt; tot &lt;&lt; &#34;\n&#34;;
  
  Matrix mat(tot, Poly(tot));
  for (int i = 0; i &lt; tot; i++) {
    for (int j = 0; j &lt; tot; j++) {
      int x = i, y = j;
      Z coef = 1, del = 1, sum = 1;
      for (auto [c, k] : a) {
        int u = x % (k + 1), v = y % (k + 1);
        coef *= fpow(c, v);
        sum *= bin(k, v);
        del *= bin(k - u, v);
        x /= k + 1, y /= k + 1;
      }
      coef *= sum - del;
      mat[i][j] = coef.x;
    }
  }

  std::vector&lt;Matrix&gt; pw(64);
  pw[0] = mat;
  for (int i = 1; i &lt; 64; i++) {
    pw[i] = pw[i - 1] * pw[i - 1];
  }
  while (q--) {
    std::cin &gt;&gt; n;
    Poly v(tot);
    v.back() = 1;
    for (int i = 0; i &lt; 64; i++) {
      if (n &gt;&gt; i &amp; 1) {
        v = v * pw[i];
      }
    }
    int ans = 0;
    for (int x : v) inc(ans, x);
    if (n == 1) inc(ans, 1);
    std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
  }
}

int main() {
  // freopen(&#34;t.in&#34;, &#34;r&#34;, stdin);
  
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  
  int t = 1;
  
  // std::cin &gt;&gt; t;
  
  while (t--) {
    solve();
  }
  return 0;
}

```

## G3 Maximal Subsequence
&gt; 给定序列 $a_n$，求最长的子序列，满足其严格 LIS 小于原序列。
&gt; 
&gt; $1 \leq n \leq 5 \times 10^5, 1 \leq a_i \leq 10^9$。

https://dmoj.ca/problem/coci21c1p5/editorial

问题可以转化为求 $n$ - 可以拿出多少个LIS。

直接按照字典序贪心的拿就是对的，证明见上面的链接。

```cpp
void solve() {
  int n;
  std::cin &gt;&gt; n;
  std::vector&lt;int&gt; a(n), b, f(n);
  
  for (int i = 0; i &lt; n; i++) {
    std::cin &gt;&gt; a[i];
    auto it = std::lower_bound(b.begin(), b.end(), a[i]);
    f[i] = it - b.begin();
    if (it == b.end()) {
      b.push_back(a[i]);
    } else {
      *it = a[i];
    }
  }

  int k = b.size(), ans = 0;
  std::vector&lt;std::vector&lt;int&gt;&gt; g(k);
  for (int i = n - 1; i &gt;= 0; i--) g[f[i]].push_back(i);
  
  std::function&lt;bool(int, int)&gt; dfs = [&amp;](int l, int v) {    
    while (!g[l].empty()) {
      int i = g[l].back();
      if (a[i] &lt;= v) return false;
      g[l].pop_back();
      if (l + 1 == k) return true;
      
      while (!g[l + 1].empty() &amp;&amp; g[l + 1].back() &lt; i) {
        g[l + 1].pop_back();
      }
      if (g[l + 1].empty() || a[g[l + 1].back()] &lt;= a[i]) {
        continue;
      }

      if (dfs(l + 1, a[i])) return true;
    }

    return false;
  };

  
  while (!g[0].empty()) {
    if (dfs(0, -1)) ans++;
  }
  std::cout &lt;&lt; n - ans &lt;&lt; &#34;\n&#34;;
}
```

## C3 Inversions
&gt; $n$ 的排列 $p$ 的逆序对个数为 $\operatorname{inv}(p)$，求 $\operatorname{inv}(p) ^k \bmod 998244353$。
&gt; 
&gt; $1 \leq n \leq 10^{18}, 1 \leq k \leq 1000$。

设 $g(n, k)$ 表示答案。

$$
\begin{aligned}
g(n+1, k) &amp;= \sum_{i = 0}^n \sum_p (i + \operatorname{inv}(p))^k\\
&amp;= \sum_{i=0}^n\sum_{j=0}^k \sum_p \operatorname{inv}(p)^j i^{k-j} \frac{k!}{j!(k-j)!}\\
\frac{g(n+1, k)}{k!} &amp;= \sum_{j = 0}^k \frac{g(n, j)}{j!}\sum_{i=0}^n \frac{i^{k-j}}{(k - j)!}\\
G_{n + 1}(x) &amp;= G_n(x) A_n(x)\\
A_n(x) &amp;= \sum_{k\geq 0} \frac{x^k}{k!} \sum_{i = 0}^n i^k\\
&amp;= \sum_{i = 0}^n e^{ix}\\
&amp;= \frac{1 - e^{(n + 1)x}}{1 - e^x}\\
G_n(x) &amp;= \prod_{k = 1}^n\frac{1 - e^{kx}}{1 - e^x}
\end{aligned}
$$

结论是 $\dfrac{g(n, k)}{n!}$ 是关于 $n$ 的 $2k$ 次多项式，插值出这个多项式就行了。

需要算大数阶乘 $n!$，可以分段打表。

```cpp
void solve() { 
  init();
  LL n, k;
  std::cin &gt;&gt; n &gt;&gt; k;

  if (n &gt;= P) {
    std::cout &lt;&lt; &#34;0\n&#34;;
    return;
  }
  
  int len = k * 2 + 1;
  Poly a(len), p = {1}, v(k + 1);
  p.resize(k + 1);

  for (int i = 0; i &lt;= k; i++) {
    v[i] = ifac[i + 1];
  }
  v = v.inv(k + 1);
  
  int s = norm(k * 2 + 1);
  v.resize(s);
  dft(v);
  
  a[0] = p[k];
  for (int i = 1; i &lt; len; i++) {
    Poly q(k + 1);
    for (int j = 0, pw = 1; j &lt;= k; j++) {
      pw = 1LL * pw * i % P;
      q[j] = 1LL * ifac[j + 1] * pw % P;
    }
    q.resize(s);
    dft(q);
    q ^= v;
    idft(q);
    q.resize(k + 1);
    p = p * q;
    p.resize(k + 1);
    a[i] = 1LL * p[k] * fac[k] % P * ifac[i] % P;
    // std::cerr &lt;&lt; i &lt;&lt; &#34; &#34; &lt;&lt; a[i] &lt;&lt; &#34;\n&#34;;
  }

  Poly b(len);
  std::iota(b.begin(), b.end(), 0);
  Poly f = SegTree(b).interpolate(a);
  // for (int x : f) std::cerr &lt;&lt; x &lt;&lt; &#34; &#34;;
  // std::cerr &lt;&lt; &#34;\n&#34;;
  
  int ans = 0;
  for (int i = f.size() - 1; i &gt;= 0; i--) {
    ans = (ans * n + f[i]) % P;
  }

  auto it = --map.upper_bound(n);
  ans = 1LL * ans * it-&gt;second % P;
  for (int i = it-&gt;first + 1; i &lt;= n; i++) {
    ans = 1LL * ans * i % P;
  }
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```

### **UPD 2022.05.11**

反转了，上面这个做法实在是太菜了，令 $F(x) = \dfrac{e^x-1}{x}$，则 $\displaystyle{G(x) = n!\prod_{i=1}^n\frac{F(ix)}{F(x)}}$，先 $\ln$ 再 $\exp$ 即可，需要处理 $n^i(i = 0, 1, \dots, k)$ 的自然数幂和，用 $e^{ax}$ 等比数列求和即可。

复杂度 $O(k\log k)$.

```cpp
void solve() {
  init();
  LL n;
  int k;
  std::cin &gt;&gt; n &gt;&gt; k;
  if (n &gt;= P) {
    std::cout &lt;&lt; &#34;0\n&#34;;
    return;
  }

  Poly p(k + 1), q(k + 1);
  for (int i = 0; i &lt;= k; i++) {
    p[i] = 1LL * ifac[i + 1] * (fpow(n + 1, i + 1) + P - 1) % P;
    q[i] = ifac[i + 1];
  }
  p = (p * q.inv(k + 1)).pre(k + 1);
  
  Poly f = q.log(k + 1);
  for (int i = 0; i &lt;= k; i++) {
    p[i] = 1LL * p[i] * fac[i] % P;
    f[i] = 1LL * f[i] * (p[i] + P - n) % P;
  }
  f = f.exp(k + 1);

  int ans = f[k];
  auto it = --map.upper_bound(n);
  ans = 1LL * ans * it-&gt;second % P;
  for (int i = it-&gt;first + 1; i &lt;= n; i++) {
    ans = 1LL * ans * i % P;
  }
  std::cout &lt;&lt; 1LL * ans * fac[k] % P &lt;&lt; &#34;\n&#34;;
}
```

## K1 King&#39;s Palace
&gt; $n$ 个物品，每个物品可以染RGB三种颜色。有 $m$ 个限制，形如 $(a, x, b, y)$，表示第 $a$ 个物品的颜色是 $x$，第 $b$ 个物品的颜色是 $y$ 的情况是不合法的。
&gt; 
&gt; 求合法染色方案数。
&gt; 
&gt; $1 \leq n \leq 22, 1 \leq m \leq 9n(n-1)/2, 1 \leq a &lt; b \leq n$。

Meet in the middle.

分成 $t, n - t$ 两个部分，对于跨两个部分的限制，将第 $i$ 个物品的第 $j$ 个颜色是否可以使用压成 $3t$ 位二进制，使用高维前缀和计算。

取 $t = 7$ 可以通过。

复杂度可以是 $O(3^t + 3^{n - t} + (n - t)2^{3(n-t)})$，前半部分图方便随便写了，后半部分 $3^{n-t}$ 是关键。

```cpp
void solve() {
  int n, m;
  std::cin &gt;&gt; n &gt;&gt; m;
  int t = std::min(n, 7);
  std::vector&lt;std::array&lt;int, 4&gt;&gt; lim(m);
  for (int i = 0; i &lt; m; i++) {
    int a, b, c, d;
    std::string s, t;
    std::cin &gt;&gt; a &gt;&gt; s &gt;&gt; b &gt;&gt; t;
    c = s[0] == &#39;R&#39; ? 0 : s[0] == &#39;G&#39; ? 1 : 2;
    d = t[0] == &#39;R&#39; ? 0 : t[0] == &#39;G&#39; ? 1 : 2;
    a--, b--;
    lim[i] = {a, c, b, d};
    // std::cerr &lt;&lt; a &lt;&lt; &#34; &#34; &lt;&lt; b &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; &#34; &#34; &lt;&lt; d &lt;&lt; &#34;\n&#34;;
  }

  std::vector&lt;int&gt; pw(n + 1);
  pw[0] = 1;
  for (int i = 1; i &lt;= n; i++) pw[i] = pw[i - 1] * 3;

  std::vector&lt;int&gt; s(1 &lt;&lt; t * 3);
  
  for (int i = 0; i &lt; pw[t]; i++) {
    bool ok = true;
    for (auto &amp;[a, b, c, d] : lim) {
      if (a &gt;= t || c &gt;= t) continue;
      if (i / pw[a] % 3 == b &amp;&amp; i / pw[c] % 3 == d) {
        ok = false;
        break;
      }
    }
    if (!ok) continue;
    int sta = 0;
    for (int j = 0, k = i; j &lt; t; j++, k /= 3) {
      sta |= 1 &lt;&lt; 3 * j + k % 3;
    }
    s[sta]++;
  }

  for (int i = 1; i &lt; s.size(); i *= 2) {
    for (int j = 0; j &lt; s.size(); j += i * 2) {
      for (int k = 0; k &lt; i; k++) {
        s[i + j + k] += s[j + k];
      }
    }
    
  }

  std::vector&lt;int&gt; banl((n - t) * 3);
  std::vector&lt;std::vector&lt;PII&gt;&gt; banr((n - t) * 3);
  for (auto &amp;[a, b, c, d] : lim) {
    if (c &gt;= t) {
      if (a &lt; t) {
        banl[(c - t) * 3 + d] |= 1 &lt;&lt; a * 3 + b;
      } else {
        banr[(a - t) * 3 + b].push_back({c - t, d});
      }
    }
  }

  LL ans = 0;
  std::vector ban(n - t, std::vector&lt;int&gt;(3));
  // std::cerr &lt;&lt; n - t &lt;&lt; &#34;\n&#34;;
  std::function&lt;void(int, int)&gt; dfs = [&amp;](int p, int sta) {
    // std::cerr &lt;&lt; p &lt;&lt; &#34; &#34; &lt;&lt; sta &lt;&lt; &#34;\n&#34;;
    if (p == n - t) {
      // assert(sta &lt; s.size() &amp;&amp; sta &gt;= 0);
      ans += s[s.size() - 1 ^ sta];
      return;
    }
    for (int i = 0; i &lt; 3; i++) {
      if (!ban[p][i]) {
        // assert(p * 3 + i &lt; banl.size());
        // assert(p * 3 + i &lt; banr.size());
        for (auto &amp;[x, y] : banr[p * 3 + i]) {
          // assert(y &lt; 3);
          ban[x][y]++;
        }
        dfs(p + 1, sta | banl[p * 3 + i]);
        for (auto &amp;[x, y] : banr[p * 3 + i]) {
          ban[x][y]--;
        }
      }
    }
  };

  dfs(0, 0);
  std::cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
}
```

## M1 Math String
&gt; 求长度为 $n$ 的所有合法的只包含`+` `*`运算和数字 $1 \dots 9$ 的算术表达式的结果之和。
&gt; 
&gt; $1 \leq n \leq 10^{18}$。

tourist 的方法是暴力搜出表达式的形状，后面再填数计算结果，这个大概是比 $3^n$ 小的。

算出 20 项之后直接 BM。

递推式是6阶的。

这个暴力是比较容易想的一个做法，但是为啥是 linear recurrence 呢。

TG 老哥给出了生成函数的思路：

纯数字的答案，
$$
\begin{aligned}
a_n &amp;= 9a_{n - 1} + (1 + 2 + \dots + 9) \times 10^{n-1}\times 9^{n-1}\\
A(x) &amp;= 9xA(x) + \frac{45x}{1 - 90x}\\
A(x) &amp;= \frac{45x}{(1-90x)(1-9x)}
\end{aligned}
$$

带 * 的答案
$$
\begin{aligned}
B(x) &amp;= A(x) + A^2(x)x + A^3(x)x^2 + \cdots\\
&amp;= \dfrac{A(x)}{1 - xA(x)}\\
&amp;= \dfrac{45x}{1-99x+765x^2}
\end{aligned}
$$

表达式的方案数，
$$
\begin{aligned}
c_0 &amp;= 0,c_1 = 9,\\
c_n &amp;= 9c_{n-1}+18c_{n-2}, \\
C(x) &amp;= 9x + 9xC(x) + 18x^2C(x)\\
C(x) &amp;= \frac{9x}{1 - 9x - 18x^2}
\end{aligned}
$$

最终答案（没有+的表达式，在边上的表达式的贡献，在中间的表达式的贡献）
$$
\begin{aligned}
F(x) &amp;= B(x) + 2B(x)xC(x) + B(x) x^2C(x)\\
&amp;= B(x)(1 + xC(x))^2
\end{aligned}
$$

综上所述， $F(x) = \dfrac{P(x)}{Q(x)}$ 且 $P(x), Q(x)$ 均为多项式，符合线性递归的形式。

```cpp
void solve() {
  Poly p = {1, P - 9, P - 9}, q = {1, P - 9, P - 18};
  p = p * p * Poly{0, 45}, q = q * q * Poly{1, P - 99, 765};
  LL n;
  std::cin &gt;&gt; n;
  std::cout &lt;&lt; divAt(p, q, n) &lt;&lt; &#34;\n&#34;;
}
```- https://blog.asukakyle.top/post/2022ptzwinter/ - CC BY-NC-SA 4.0</description>
        </item>
    
    
  </channel>
</rss> 