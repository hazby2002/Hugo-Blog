<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>题解 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/categories/%E9%A2%98%E8%A7%A3/</link>
    <description>Recent content in 题解 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 05 Aug 2022 23:16:50 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/categories/%E9%A2%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>字符串记录</title>
      <link>https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Fri, 05 Aug 2022 23:16:50 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AE%B0%E5%BD%95/</guid>
      <description>- P5576 [CmdOI2019]口头禅 给定一堆字符串，多次询问**区间字符串最长公共子串**。 广义SAM，用set维护子树内有的连续区间，自底向上启发式合并，增加区间时在线段树上查找可以回答的询问，并且将该询问删除。由于自底向上，保证len越来越小，所以回答完就可以删除。 - P4482 [BJWC2018]Border 的四种求法 多次询问字符串**区间border**。 **parent树上链分治。**先考虑 $node_r$ 暴力向上跳，找 pos 集合区间最大值的方法。HLD 之后把跳的过程拆到重链上。利用轻子树大小和为 $O(n\log n)$，每条重链处理，要求 $pos - len &lt; L$，线段树以 $pos$ 为下标，维护 $\min\{pos-len\}$，然后线段树上二分。 - CF1098F Ж-function 多次询问 $f(l, r)$ 表示子串 $s[l, r]$ 每个后缀与该子串的 lcp 的和。 思路同上，用 HLD 优化暴力跳的过程，拆到重链上变成一个三维偏序，然后用 CDQ 分治做。 - [2022牛客多校6 L Striking String Problem](https://ac.nowcoder.com/acm/contest/33191/L) 给定串 $S, T$，令 $U = S[l_1, r_1] + S[l_2, r_2] + \dots + S[l_k, r_k]$，$q$ 次询问 $T$ 在 $U[x_i, y_i]$ 中的出现次数。**数据结构优化KMP。** 询问可以拆成两个前缀的答案之差，考虑对一个前缀的查询，设它在 $S[l_i, r_i]$ 里，预处理前 $i-1$ 的答案，设 $\operatorname{query}(i, p)$ 表示右端点在 $[l_i, l_i+p)$ 的答案，完全落在 $S[l, r]$ 内的答案可以预处理前缀和。 跨过 $l_i$ 的答案，设超出长度为 $D$，需要满足 $D+p \geq |T|, D+\operatorname{lcp}(S[l:], T[D+1:]) \geq |T|$，对于同一个 $D$，$S[l:]$ 要满足的条件是后缀树上的一个子树。对 $T$ 的 kmp 失配树建可持久化线段树，区间修改单点查询。满足条件的 $D$ 是失配树上的一个祖孙链，需要知道 $S[l_1, r_1]+\dots+S[l_{i-1}, r_{i-1}]$ 和 $T$ 的匹配长度，这个可以预处理，分匹配完全在 $S[l, r]$ 和跨左端点讨论一下，后者还是在失配树上用线段树搞一下。</description>
    </item>
    
    <item>
      <title>[Codeforces1677F] Tokitsukaze and Gems</title>
      <link>https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/</link>
      <pubDate>Thu, 12 May 2022 00:35:08 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1677ftokitsukaze-and-gems/</guid>
      <description>[传送门](https://codeforces.com/contest/1677/problem/F) &gt; 给定 $n, k, p, a_1, a_2, \dots, a_n$，求 &gt; $$ &gt; \sum_{1 \leq l \leq r \leq n}\sum_{l \leq i \leq r, 0 \leq t_i \leq a_i} \left(\left(\sum_{i=1}^np^{t_i}t_i^k\right)\left(\sum_{i=1}^n[t_i&gt;0]\right)\right) &gt; $$ &gt; &gt; 答案对 $998244353$ 取模。 &gt; &gt; $1 \leq n, k\leq 10^5, 2 \leq p \leq 998244351, 1 \leq a_i \leq 998244351$。 考虑对固定的 $[l, r]$ 计算答案，它是两个数乘积之和的形式。可以通过维护 $(\sum xy, \sum x, \sum y, \sum 1)$ 四元组来计算答案。 这个玩意是线性变换，写成矩阵形式可以发现，答案最后就是要你求所有区间的矩阵乘积之和。 这个可以直接维护每个位置作为右端点的答案，只要维护当前后缀的四元组即可。 求单个的四元组，可以发现就是要求 $\sum_{i=0}^{a_j} p^ii^k$。 对于这个问题，板子 OJ 有一个 [单次询问的版本](https://judge.</description>
    </item>
    
    <item>
      <title>Ynoi 等 lxl 题做题记录</title>
      <link>https://blog.asukakyle.top/post/ynoi/</link>
      <pubDate>Fri, 01 Apr 2022 12:59:27 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/ynoi/</guid>
      <description>## 前言 题目是乱序的。因为太菜了不会卡常，所以很多题是九十几分。 **UPD. 2022.04.27** 发现很多以前写的懒得写题解，感觉又都不太会了，后面还是做一题写一题比较好。 发现刷 Ynoi 收益很小，大部分时间只是在卡常。 不过数据结构题写起来有意思，自己写起来乐在其中，可能刷 Ynoi 对于算法竞赛并没有什么用，更多只是自我满足罢了。 ## P5047	[Ynoi2019 模拟赛] Yuno loves sqrt technology II &gt; 给定序列 $a_n$, $m$ 次询问区间逆序对。 &gt; &gt; $1 \leq n, m \leq 10^5, 1 \leq a_i \leq 10^9$。 莫队二次离线。 求前缀比它小/大的数的个数，用 $O(\sqrt n)$ 修改，$O(1)$ 查询的搞一下就行。 ```cpp #include constexpr int T(512), N(1e5 + 5), S(N / T + 1); struct Qry { int l, r, id; bool operator&lt;(const Qry &amp;rhs) const { return l / T == rhs.</description>
    </item>
    
    <item>
      <title>[AGC036D] Negative Cycle</title>
      <link>https://blog.asukakyle.top/post/agc036d-negative-cycle/</link>
      <pubDate>Thu, 13 Jan 2022 20:31:35 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/agc036d-negative-cycle/</guid>
      <description>&gt; 题意：$n$ 个点的有向图，初始有边 $i \to i + 1$，边权为 0，不可删除。有边 $i \to j(i \neq j)$，边权为 $\begin{cases}1, &amp;i &gt; j\\-1, &amp;i &gt; $1 \leq n \leq 500$ 有向图上没有负环，则存在最短路，则差分约束有解。 每个点设变量 $x_i$，那么一条 $i \to j$ 边权为 $w$ 的边就代表 $x_j - x_i \leq w$。 所以初始 $i \to i + 1$ 的边表示 $x_i \geq x_{i+1}$。 设 $d_i = x_{i-1} - x_i \geq 0$。 对于边 $i \to j$，$i &lt; j$ 时为第一类边，表示 $\sum\limits_{k = i + 1}^jd_k \geq 1$，则对于一串 $d_k = 0$上的此类边都需要删除； $i &gt; j$ 时为第二类边，表示 $\sum\limits_{k=i+1}^jd_k \leq 1$，跨过多于一个1的边需要删除。 设 $dp(i, j)$ 表示考虑了前 $i$ 个变量，最后两个 1 分别在 $i, j$ 的最小代价，用二维前缀和计算区间删边的代价，时间复杂度 $O(n^3)$。 ```cpp void solve() { int n; std::cin &gt;&gt; n; std::vector a(n + 1, std::vector(n + 1)), b = a; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { if (i &lt; j) { std::cin &gt;&gt; a[i][j]; } else if (i &gt; j) { std::cin &gt;&gt; b[i][j]; } a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]; b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; } } std::vector dp(n + 1, std::vector(n + 1, 1e18)); for (int i = 0; i &lt;= n; i++) { dp[i][0] = a[i][i]; for (int j = 1; j &lt; i; j++) { for (int k = 0; k &lt; j; k++) { smin(dp[i][j], dp[j][k] + b[i][k] - b[j][k]); } dp[i][j] += a[i][i] - a[i][j] - a[j][i] + a[j][j]; } } LL ans = 1e18; for (int i = 0; i &lt; n; i++) { smin(ans, dp[n][i]); } std::cout &lt;&lt; ans &lt;&lt; &#34;</description>
    </item>
    
    <item>
      <title>2021CCPC网络赛</title>
      <link>https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/</link>
      <pubDate>Tue, 31 Aug 2021 09:15:07 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021ccpc%E7%BD%91%E7%BB%9C%E8%B5%9B/</guid>
      <description>| Pro. ID | Problem Title | Solved | | ------- | ------------------------------------------------------------ | ------------------------------------------------------------ | | 7100 | [ Cut The Wire](https://acm.hdu.edu.cn/showproblem.php?pid=7100) | ![ You has solved this problem :-)	](https://acm.hdu.edu.cn/images/ac.gif)（赛时） | | 7101 | [ Time-division Multiplexing](https://acm.hdu.edu.cn/showproblem.php?pid=7101) | ![ You has solved this problem :-)	](https://acm.hdu.edu.cn/images/ac.gif)（赛时） | | 7102 | [ Pattern Recognition](https://acm.hdu.edu.cn/showproblem.php?pid=7102) | ![ You has solved this problem :-)	](https://acm.hdu.edu.cn/images/ac.gif)（赛后） | | 7103 | [ Depth First Search](https://acm.</description>
    </item>
    
    <item>
      <title>2021牛客多校10</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder10/</link>
      <pubDate>Wed, 18 Aug 2021 22:13:07 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder10/</guid>
      <description>| 题号 | 标题 | 团队的状态 | | :--: | :----------------------------------------------------------: | :--------: | | A | [Browser Games](https://ac.nowcoder.com/acm/contest/11261/A) | 通过 | | B | [Child&#39;s play](https://ac.nowcoder.com/acm/contest/11261/B) | 未通过 | | C | [Dance Party](https://ac.nowcoder.com/acm/contest/11261/C) | 未通过 | | D | [Diameter Counting](https://ac.nowcoder.com/acm/contest/11261/D) | 未通过 | | E | [More Fantastic Chess Problem](https://ac.nowcoder.com/acm/contest/11261/E) | 通过 | | F | [Train Wreck](https://ac.nowcoder.com/acm/contest/11261/F) | 通过 | | G | [Game of Death](https://ac.nowcoder.com/acm/contest/11261/G) | 通过 | | H | [War of Inazuma (Easy Version)](https://ac.</description>
    </item>
    
    <item>
      <title>2021牛客多校9</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder9/</link>
      <pubDate>Sat, 14 Aug 2021 18:36:09 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder9/</guid>
      <description>| 题号 | 标题 | 团队的状态 | | :--: | :----------------------------------------------------------: | :--------: | | A | [A Math Challenge](https://ac.nowcoder.com/acm/contest/11260/A) | 通过 | | B | [Best Subgraph](https://ac.nowcoder.com/acm/contest/11260/B) | 未通过 | | C | [Cells](https://ac.nowcoder.com/acm/contest/11260/C) | 通过 | | D | [Divide-and-conquer on Tree](https://ac.nowcoder.com/acm/contest/11260/D) | 未通过 | | E | [Eyjafjalla](https://ac.nowcoder.com/acm/contest/11260/E) | 通过 | | F | [Financial Order Execution](https://ac.nowcoder.com/acm/contest/11260/F) | 未通过 | | G | [Glass Balls](https://ac.nowcoder.com/acm/contest/11260/G) | 通过 | | H | [Happy Number](https://ac.</description>
    </item>
    
    <item>
      <title>2021牛客多校7</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder7/</link>
      <pubDate>Sat, 07 Aug 2021 19:38:21 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder7/</guid>
      <description>| 题号 | 标题 | 团队的状态 | | :--: | :----------------------------------------------------------: | :--------: | | A | [xay loves connected graphs](https://ac.nowcoder.com/acm/contest/11258/A) | 通过 | | B | [xay loves monotonicity](https://ac.nowcoder.com/acm/contest/11258/B) | 通过 | | C | [xay loves jumping](https://ac.nowcoder.com/acm/contest/11258/C) | 未通过 | | D | [xay loves matrices](https://ac.nowcoder.com/acm/contest/11258/D) | 通过 | | E | [xay loves nim](https://ac.nowcoder.com/acm/contest/11258/E) | 通过 | | F | [xay loves trees](https://ac.nowcoder.com/acm/contest/11258/F) | 通过 | | G | [xay loves KDT](https://ac.</description>
    </item>
    
    <item>
      <title>2021牛客多校6</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder6/</link>
      <pubDate>Sat, 07 Aug 2021 09:53:25 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder6/</guid>
      <description>| 题号 | 标题 | 团队的状态 | | ---- | ------------------------------------------------------------ | ---------- | | A | [Contracting Convex Hull](https://ac.nowcoder.com/acm/contest/11257/A) | 未通过 | | B | [Defend Ponyville](https://ac.nowcoder.com/acm/contest/11257/B) | 通过 | | C | [Delete Edges](https://ac.nowcoder.com/acm/contest/11257/C) | 通过 | | D | [Gambling Monster](https://ac.nowcoder.com/acm/contest/11257/D) | 通过 | | E | [Growing Tree](https://ac.nowcoder.com/acm/contest/11257/E) | 通过 | | F | [Hamburger Steak](https://ac.nowcoder.com/acm/contest/11257/F) | 通过 | | G | [Hasse Diagram](https://ac.nowcoder.com/acm/contest/11257/G) | 通过 | | H | [Hopping Rabbit](https://ac.</description>
    </item>
    
    <item>
      <title>2021牛客多校3</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder3/</link>
      <pubDate>Sat, 31 Jul 2021 11:28:53 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder3/</guid>
      <description>| 题号 | 标题 | 团队的状态 | | :--: | :----------------------------------------------------------: | :--------: | | A | [Guess and lies](https://ac.nowcoder.com/acm/contest/11254/A) | 通过 | | B | [Black and white](https://ac.nowcoder.com/acm/contest/11254/B) | 通过 | | C | [Minimum grid](https://ac.nowcoder.com/acm/contest/11254/C) | 通过 | | D | [Count](https://ac.nowcoder.com/acm/contest/11254/D) | 通过 | | E | [Math](https://ac.nowcoder.com/acm/contest/11254/E) | 通过 | | F | [24dian](https://ac.nowcoder.com/acm/contest/11254/F) | 通过 | | G | [Yu Ling(Ling YueZheng) and Colorful Tree](https://ac.nowcoder.com/acm/contest/11254/G) | 通过 | | H | [Ling Qiu, Luna and Triple Backpack](https://ac.</description>
    </item>
    
    <item>
      <title>[NOI2021] 密码箱</title>
      <link>https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/</link>
      <pubDate>Fri, 30 Jul 2021 20:54:17 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/noi2021-%E5%AF%86%E7%A0%81%E7%AE%B1/</guid>
      <description>## 题面 ![](statement.png) ## 题解 设向量 $\begin{pmatrix}x \\ y\end{pmatrix}$ 表示分数 $\dfrac x y$。 那么整数加分数的运算 $a+\dfrac x y = \dfrac{x + ay}{y}$ 可以表示为 $$ \begin{pmatrix} 1 &amp; a\\ 0 &amp; 1 \end{pmatrix} \begin{pmatrix} x\\y \end{pmatrix} = \begin{pmatrix} x+ay\\ y \end{pmatrix} $$ 设 $a_k = \dfrac{x}{y}$，则 $a_{k-1}&#39;=a_{k-1}+\dfrac y x$，写成矩阵形式为 $$ \begin{pmatrix} a_{k-1} &amp; 1\\ 1 &amp; 0 \end{pmatrix} \begin{pmatrix} x\\y \end{pmatrix} = \begin{pmatrix} a_{k-1}x+y\\ x \end{pmatrix} $$ 记 $$ F = \begin{pmatrix} a_{0} &amp; 1\\ 1 &amp; 0 \end{pmatrix} \begin{pmatrix} a_{1} &amp; 1\\ 1 &amp; 0 \end{pmatrix} \dots \begin{pmatrix} a_{k} &amp; 1\\ 1 &amp; 0 \end{pmatrix} $$ 则 $$ f(a_0, a_1, \dots, a_n) = F_{0, 0} $$ 考虑维护矩阵 $F$。 操作`W`相当于右乘矩阵 $\begin{pmatrix}1 &amp; 0\\1 &amp; 1\end{pmatrix}$ $$ \begin{pmatrix} a_{k} &amp; 1\\ 1 &amp; 0 \end{pmatrix} \begin{pmatrix} 1 &amp; 0\\ 1 &amp; 1 \end{pmatrix} = \begin{pmatrix} a_{k} + 1 &amp; 1\\ 1 &amp; 0 \end{pmatrix} $$ 操作`E`先考虑第二种情况，可以发现是右乘矩阵 $\begin{pmatrix}1 &amp; 0\\-1 &amp; 1\end{pmatrix}\begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}^2=\begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix}$ $$ \begin{pmatrix}a_{k} &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix} = \begin{pmatrix}2a_{k}-1 &amp; a_k\\2 &amp; 1\end{pmatrix} $$ 验证 $a_k=1$ 时是否也符合题意： 一方面 $$ \begin{pmatrix}a_{k-1} &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}2a_{k}-1 &amp; a_k\\2 &amp; 1\end{pmatrix}= \begin{pmatrix}a_{k-1} &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}1 &amp; 1\\2 &amp; 1\end{pmatrix}= \begin{pmatrix}a_{k-1}+2 &amp; a_{k-1}+1\\1 &amp; 1\end{pmatrix} $$ 另一方面 $$ \begin{pmatrix}a_{k-1}+1 &amp; 1\\1 &amp; 0\end{pmatrix} \begin{pmatrix}1 &amp; 1\\1 &amp; 0\end{pmatrix}=\begin{pmatrix}a_{k-1}+2 &amp; a_{k-1}+1\\1 &amp; 1\end{pmatrix} $$ 所以操作`E`就是右乘矩阵 $\begin{pmatrix}2 &amp; 1\\-1 &amp; 0\end{pmatrix}$ 平衡树维护即可。 ```cpp // Author: HolyK // Created: Fri Jul 30 19:13:22 2021 #include #define dbg(a.</description>
    </item>
    
    <item>
      <title>2021牛客多校2</title>
      <link>https://blog.asukakyle.top/post/2021nowcoder2/</link>
      <pubDate>Wed, 21 Jul 2021 13:31:31 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/2021nowcoder2/</guid>
      <description>## 总览 | 题号 | 标题 | 团队的状态 | | :--: | :----------------------------------------------------------: | :--------: | | A | [Arithmetic Progression](https://ac.nowcoder.com/acm/contest/11253/A) | 通过 | | B | [Cannon](https://ac.nowcoder.com/acm/contest/11253/B) | 通过 | | C | [Draw Grids](https://ac.nowcoder.com/acm/contest/11253/C) | 通过 | | D | [Er Ba Game](https://ac.nowcoder.com/acm/contest/11253/D) | 通过 | | E | [Gas Station](https://ac.nowcoder.com/acm/contest/11253/E) | 通过 | | F | [Girlfriend](https://ac.nowcoder.com/acm/contest/11253/F) | 通过 | | G | [League of Legends](https://ac.nowcoder.com/acm/contest/11253/G) | 通过 | | H | [Olefin](https://ac.</description>
    </item>
    
    <item>
      <title>[UOJ91]最大异或和</title>
      <link>https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</link>
      <pubDate>Mon, 12 Jul 2021 08:17:49 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/uoj91%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C/</guid>
      <description>&gt; 有一个数列 $a_1,a_2,\dots,a_n$，每个 $a_i$ 都是小于 $2^m$ 的非负整数。 &gt; &gt; 现在需要实现三种操作，格式说明如下： &gt; &gt; - 1 *x* *y* *w*：对于所有 $x≤i≤y$，将 $a_i$ 修改为 $a_i\oplus w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。 &gt; - 2 *x* *y* *w*：对于所有 $x≤i≤y$，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。 &gt; - 3：从 $a_1,a_2,⋯,a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。 &gt; &gt; 这里 $\oplus$ 表示按位异或运算，$x_1,x_2,⋯,x_l$ 的异或和是指 $x_1\oplus x_2\oplus \cdots\oplus x_l$。 &gt; &gt; $n,m,q≤2000$。 将原序列差分，线性基不变。 然后每次操作就是单点插入和删除，下面给出两种可删除线性基的写法。 ## 离线 记录存活时间，贪心。 ```cpp using BS = std::bitset&lt;2000&gt;; using PBI = std::pair; PBI base[2000]; void ins(PBI x) { for (int i = 1999; i &gt;= 0; i--) { if (!</description>
    </item>
    
    <item>
      <title>[ICPC2014 WF]Pachinko</title>
      <link>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</link>
      <pubDate>Mon, 12 Jul 2021 08:12:01 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</guid>
      <description>&gt; 有一个 $h×w$ 的方格表，有些格子是墙，有些格子是终点，剩下的格子是空地。 &gt; &gt; 你现在要在这里进行随机游走，其中，每一轮向上、下、左、右的概率分别为 $u\%,d\%,l\%,r\%$，如果移动后超过方格表或到达墙，则这次移动失效，保持原地不动。 &gt; &gt; 当你到达终点时，游戏就结束了。现在，在**方格表第一行**的所有空地中均匀随机一个作为起点，求你就进入每个终点的概率。 &gt; &gt; $1≤w≤20, 2≤h≤10000$。 设其中一个终点为 $t$，$f_{i, j}$ 表示 $(i, j)$ 走到 $t$ 的概率。 $$ f_{i, j} = uf_{i-1, j}+df_{i+1, j}+lf_{i, j-1}+rf_{i, j+1} $$ $$ f_{i, j} - uf_{i-1, j} - df_{i+1, j} - lf_{i, j-1} - rf_{i, j+1}=0 $$ $$ f_t=1 $$ $$ P\cdot\mathbf{f}=\mathbf{e} $$ $P$ 是 $wh \times wh$ 的方阵，$\mathbf{f},\mathbf{e}$ 是列向量。其中 $e_i=[i=t]$。 $$ \mathbf{f}=P^{-1}\mathbf{f} $$ 设 $1\dots s$ 为起点 ，答案为 $$ ans = \frac1s \sum_{i=1}^sf_i $$ 写成矩阵的形式，设行向量 $\mathbf{v}^T=\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; \cdots &amp; 0 &amp; 0 &amp; \cdots \end{pmatrix}$，前面有 $s$ 个1，其他都是0。 $$ \begin{aligned} ans &amp;= \frac1s \mathbf{v}^T\mathbf{f}\\ &amp;= \frac1s\mathbf{v}^TP^{-1}\mathbf{e}\\ \end{aligned} $$ 相当于求行向量 $\alpha^T = \dfrac1s\mathbf{v}^TP^{-1}$ 第 $t$ 维的值，所以只要求出这个行向量即可。 $$ \alpha^T P = \frac1s\mathbf{v} $$ $$ P^T\alpha=\frac1s\mathbf{v}^T $$ 解这个线性方程组，直接高斯消元显然不行。 如果按照从上到下从左到右的顺序标号，$P^T$ 是一个带状矩阵，每行只需存储 $2w+1$ 个元素。 ~~然后消元即可。~~ **这还有个小问题没解决，留坑！** ```cpp // Author: HolyK // Created: Mon Jul 5 11:36:58 2021 #include #define dbg(a.</description>
    </item>
    
    <item>
      <title>[Codeforces938G]Shortest Path Queries</title>
      <link>https://blog.asukakyle.top/post/cf938g/</link>
      <pubDate>Thu, 15 Apr 2021 17:26:44 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/cf938g/</guid>
      <description>&gt; 给定一个带权无向图，实现三种操作：加边，删边，询问两点间的异或最短路。 &gt; &gt; $n, m, q \leq 2\times 10^5$。 类似最大 xor 和路径，用线性基可以求解异或最短路。 因为线性基删除很麻烦，所以直接离线用线段树分治。 图可能不连通，需要用并查集维护连通性，然后记录每个点到当前根的异或和 $d_x$。 加边时设 $val = d_x\oplus d_y \oplus w$，如果 $x, y$ 已经联通则将 $val$ 加入当前联通块的线性基，如果不在一个并查集，连接两个根，边权为 $val$。 ```cpp #include #define perr(a...) fprintf(stderr, a) #define dbg(a...) perr(&#34;\033[32;1m&#34;), perr(a), perr(&#34;\033[0m&#34;) template inline bool smin(T &amp;x, const U &amp;y) { return y &lt; x ? x = y, 1 : 0; } template inline bool smax(T &amp;x, const U &amp;y) { return x &lt; y ?</description>
    </item>
    
    <item>
      <title>Gym102994</title>
      <link>https://blog.asukakyle.top/post/gym102994/</link>
      <pubDate>Thu, 15 Apr 2021 09:03:20 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/gym102994/</guid>
      <description>## 总览 | 题号 | A | B | C | D | E | F | G | H | I | J | K | L | M | |:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|---|---| | 完成情况 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | ## A. Everyone Loves Playing Games &gt; A 有 $N$ 对数， B 有 $M$ 对数，A 从 $N$ 对数中分别选一个数得到异或和 $X$，然后 B 从 $N$ 对数得到一个异或和 $Y$，$A$ 希望 $X \oplus Y$ 最大，$B$ 希望 $X \oplus Y$ 最小，求最后的结果。 &gt; &gt; $N, M \leq 10000, 0 \leq x \leq 10^{18}$。 设每对数为 $(x_i, y_i)$，先都选上 $x_i$，然后变成选或不选 $x_i \oplus y_i$ 的问题。 A 和 B 分别建出线性基，然后从高位向低位考虑。 只需要考虑某一位 A 和 B 都有影响的情况，这位如果为 1 那么 A B 只会选一个，如果为 0 则要么都选，要么都不选，不管哪种情况两种状态都可以通过异或 $A_i \oplus B_i$ 来相互转换，所以这种情况将 $A_i \oplus B_i$ 插入 $A$ 的线性基来提供“反悔”的机会。 ```cpp #include #include #define perr(a.</description>
    </item>
    
    <item>
      <title>Gym102441</title>
      <link>https://blog.asukakyle.top/post/gym102441/</link>
      <pubDate>Thu, 08 Apr 2021 22:39:55 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/gym102441/</guid>
      <description>## 总览 | 题号 | A | B | C | D | E | F | G | H | I | J | K | |:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 完成情况 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | ## A. Template for Search &gt; 给定由小写字母、字符`*` 和 `?` 组成的字符串 $s$，其中 `*` 可以被替换成任意串（包括空串），`?` 可以被替换成任意字符，求 $s$ 可以表示成的最短回文串。 &gt; &gt; $1 \leq |s| \leq 500$。 设 $dp[l][r]$ 表示 $l \dots r$ 能组成的最短回文串，有三种转移： - $s_l$ 匹配 $s_r$ - $s_l = *$ 匹配右边一段 - $s_r = *$ 匹配左边一段 ## B.</description>
    </item>
    
    <item>
      <title>[Codeforces955D]Scissors</title>
      <link>https://blog.asukakyle.top/post/codeforces955dscissors/</link>
      <pubDate>Fri, 26 Mar 2021 17:56:38 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces955dscissors/</guid>
      <description>&gt; 给定两个串 $s,t$ 整数 $k$ ,你可以在 $s$ 中取出任意的两个不相交的长度为 $k$ 串，将它们按顺序拼在一起形成一个新串。 &gt; &gt; 求一种取串的方案使得 $t$ 是新串的子串。 &gt; &gt; $|s|,|t| \leq 5 \times 10^5$。 kmp 算出正串和反串的能匹配 $t$ 的前/后缀最大长度。 设 $s$ 串的前缀 $[pre_1 \dots pre_i]$ 能匹配 $t$ 的前缀集合为 $P$，后缀 $[suf_{i+1},suf_n]$ 能匹配 $t$ 的后缀集合为 $Q$，只要判断是否存在 $x\in P,y\in Q,x, y\leq k,x+y=|s|$ 即可。 类似 AC 自动机那样建出 fail 树，那么一个点能匹配的前缀长度集合就是在 fail 树上到根的路径，在正串 fail 树上维护集合 $P$，每次添加一个数 $x$ 时，标记 $k-x$ 对应在反串 fail 树上的点，每次查询反串 fail 树上一个点的祖先是否被标记。 具体实现时，标记一个点可以用子树加一，查询的时候单点查询即可。 复杂度 $O(n \log n)$。 ```cpp #include #define dbg(.</description>
    </item>
    
    <item>
      <title>[Codeforces1413F]Roads and Ramen</title>
      <link>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</link>
      <pubDate>Fri, 19 Mar 2021 10:09:39 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</guid>
      <description>&gt; 给定一棵 $n$ 个点的无根树，每条边都有标记0或1。现在有 $m$ 次操作，每次操作将第 $id$ 条边的标记异或1。在每次操作后输出当前树上最长的有偶数个1的路径长度。 &gt; &gt; $n,m \leq 5 \times 10^5$。 ## 动态DP 设 $dp[x][0/1]$ 表示 $x$ 向下有偶数/奇数个1的最长路径，$dp[x][2]$ 表示 $x$ 子树内偶数个1的直径。 容易写出转移（$val_y$ 表示 $y$ 的父边的权值）： $$ \begin{aligned} dp&#39;[x][0] &amp;= \max\{dp[x][0], dp[y][val_y] + 1\}\\ dp&#39;[x][1] &amp;= \max\{dp[x][1], dp[y][val_y \oplus 1] + 1\}\\ dp&#39;[x][2] &amp;= \max\{dp[x][0] + dp[y][val_y] + 1, dp[x][1] + dp[y][val_y \oplus 1] + 1, dp[x][2],dp[y][2]\} \end{aligned} $$ 改写成 $x$ 从重儿子 $y$ 转移的矩阵（这里以 $val_y = 0$ 为例）： $$ \begin{bmatrix} dp&#39;[x][0]\\ dp&#39;[x][1]\\ dp&#39;[x][2]\\ 0 \end{bmatrix} = \begin{bmatrix} 1 &amp; -\infty &amp; -\infty &amp; dp[x][0]\\ -\infty &amp; 1 &amp; -\infty &amp; dp[x][1]\\ dp[x][0] + 1 &amp; dp[x][1] + 1 &amp; 0 &amp; dp[x][2]\\ -\infty &amp; -\infty &amp; -\infty &amp; 0 \end{bmatrix} \begin{bmatrix} dp[y][0]\\ dp[y][1]\\ dp[y][2]\\ 0 \end{bmatrix} $$ 上面的 $dp[x]$ 是指排除掉 $x$ 重儿子的答案，$dp&#39;[x]$ 是指完整的 $x$ 的答案。 $dp[x]$ 考虑直接用 `std::multiset` 存一下每个节点虚儿子的 $dp[y][0], dp[y][1], dp[y][2]$，取每个的最大和次大值即可快速求出。 复杂度是 $O(4^3 m \log n + m \log^2n)$，能跑过 $5 \times 10^5$ 也是奇迹。 **细节**：在 `multiset` 中删除 $-\infty$ 时不能直接查找对应的值，应该直接删除 `multiset` 中最小的那个值（具体见函数 `void erase(std::multiset&amp;, int)`）。 ```cpp #include #ifdef LOCAL #define dbg(args.</description>
    </item>
    
    <item>
      <title>[Codechef CCC]Hit the Coconuts</title>
      <link>https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/</link>
      <pubDate>Thu, 18 Mar 2021 21:51:42 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codechef-ccchit-the-coconuts/</guid>
      <description>&gt; 题意： $N$ 个椰子, 第 $i$ 个需要敲 $a_i$ 下才能打开，问最坏情况下最少要敲多少下才能打开 $k$ 个椰子。 不妨设 $a_i \le a_{i + 1}$。 要敲开一个椰子，现在有两种方法： 1. 随便拿起一个椰子不停地敲，最多要 $a_n$ 次。 2. 有目的性地想要敲开某个椰子 $a_i$，可以发现最优的策略就是每个椰子都敲 $a_i$ 次，最多要敲 $a_i\times(n - i + 1)$ 次，所有情况下取最小值。 第二种情况实际上包含了第一种。 那么要敲开 $k$ 个椰子，也有两种方法： 1. 每次都随便拿一个敲开，最多要 $a_n + a_{n - 1}+ \dots + a_{n - k + 1}$ 次。 2. 选 $k$ 个椰子 $a_{b_1}, a_{b_2}, \dots, a_{b_k}(b_i &lt; b_{i + 1})$，有目的性地敲开它们。发现最优策略下最多要敲 $\sum_{i = 1}^k (a_{b_i} - a_{b_i - 1}) \times (n - b_i + 1)$ 次，其中 $a_{b_0} = 0$，所有情况下取最小值。 第二种情况也包含了第一种。 因此考虑第二种情况的求解，设 $dp[i][k]$ 表示前 $i$ 个椰子敲开 $k$ 个（包括第 $i$ 个椰子）的最少次数。 $$ dp[i][k] = \min\{dp[j][k - 1] + (a_i - a_j) \times (n - i + 1)\} $$ 这显然是一个斜率优化的形式，化一下式子（第二维省略）： $$ dp[i] = \min\{a_j \times (i - n - 1) + dp[j]\} + a_i \times (n - i + 1) $$ 设直线 $L_j(x) = a_j \cdot x + dp[j]$，求 $\min L_j(i - n - 1)$，斜率和横坐标都是递增的，可以用栈维护一个上凸壳，复杂度 $O(nk + n\log n)$。 ```cpp #include #ifdef LOCAL #define dbg(args.</description>
    </item>
    
    <item>
      <title>[PKUWC2018]猎人杀</title>
      <link>https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/</link>
      <pubDate>Thu, 18 Mar 2021 21:47:16 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/pkuwc2018%E7%8C%8E%E4%BA%BA%E6%9D%80/</guid>
      <description>&gt; $n$ 个人，每个人有个权值 $a_i$。进行 $n$ 轮操作，每轮开枪杀死一个人，$i$ 被杀死的概率 $p_i=\dfrac{a_i}{\sum_{x\ is\ alive}a_x}$ ，求最后死的那个人是 $1$ 的概率。答案对 $998244353$ 取模。 &gt; &gt; $a_i &gt; 0, 1 \le \sum a_i \le 10^5$。 设 $s = \sum_{i=1}^na_i,w=\sum_{x\ is\ alive}a_x$，那么有 $$ \begin{aligned} p_i &amp;= \frac{a_i}{w}\\ \frac wsp_i &amp;= \frac {a_i}{s}\\ p_i &amp;= \frac {a_i}{s} + \frac{s - w}s p_i \end{aligned} $$ 最后的这个式子可以理解为，每次开枪的目标是所有活人和死人，如果打到活人就会杀死他，如果打到死人不算，重打。 这样变成进行无限轮，每轮的目标都是所有人，打到某个人的概率更容易表示。 然后考虑容斥，设 $A = \{ a_2, a_3, \dots, a_n \}$， $1$ 在第 $r$ 轮被打死，且至少有 $k$ 个人在 $1$ 之后被打死。 $$ \begin{aligned} ans &amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \sum_{r = 1}^{\infty} \left(\frac{s - a_1 - \sum_{i \in S} a_i}{s}\right)^{r - 1} \cdot \frac{a_1}{s}\\ &amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{s} \cdot \sum_{r = 0}^{\infty} \left(\frac{s - a_1 - \sum_{i \in S} a_i}{s}\right)^{r}\\ &amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{s} \cdot \frac{1}{1 - \dfrac{s - a_1 - \sum_{i \in S} a_i}{s}}\\ &amp;= \sum_{k = 0}^{n - 1} (-1)^k \sum_{S \subseteq A, |S| = k} \frac{a_1}{a_1 + \sum_{i \in S} a_i}\\ &amp;= \sum_{k = 0}^{s - a_1} \frac{a_1}{a_1 + k} \times \sum_{S \subseteq A, \sum_{i \in S} a_i = k} (-1)^{|S|}\\ &amp;= \sum_{k = 0}^{s - a_1} \frac{a_1}{a_1 + k} \times [x^k] \prod_{i=2}^n(1 - x^{a_i}) \end{aligned} $$ 分治求 $\prod_{i=2}^n(1 - x^{a_i})$ 即可，复杂度 $O(n \log n \log s)$ 。 ```cpp #include #ifdef LOCAL #define dbg(args.</description>
    </item>
    
    <item>
      <title>[Codeforces1148H] Holy Diver</title>
      <link>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</link>
      <pubDate>Sat, 13 Mar 2021 00:43:08 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</guid>
      <description>&gt; 给定一个最初为空的数组，然后进行 $n$ 次操作，每次操作给定 $x,l,r,k$，在数组末尾插入 $x$ ，然后查询满足 $mex(\{a_i, a_{i + 1}, \dots, a_j\}) = k$ 的数对 $(i,j)$ 的个数，**强制在线**。 &gt; &gt; $mex(S)$ 表示集合 $S$ 中最小的未出现的 **自然数**。 &gt; &gt; $n \leq 2 \times 10^5$。 为表示方便，下面记 $mex(i, j) = mex(\{a_i, a_{i + 1}, \dots, a_j\})$。 容易发现，如果向集合 $S$ 中添加数，$mex(S)$ 不会减小。 所以如果固定右端点 $j$，$mex(i, j)$ 是**非严格单调减**的；固定左端点 $i$，$mex(i, j)$ 是**非严格单调增**的。 维护一个 $n \times n$ 矩阵，$A[i][j] = mex(j, i)$，则矩阵 $A$ 的每一行从左到右都是非严格单调减的，每一列从上到下都是非严格单调增的。 第 $i$ 次操作增加一个数 $x$，考虑从第 $i - 1$ 行拓展到第 $i$ 行时矩阵 $A$ 的变化。 首先 $A[i][i]=[x=0]$。 下面只考虑 $j &lt; i$ 的情况。 如果 $A[i-1][j]=x$，则 $A[i][j]&gt;x$，否则 $A[i][j] = A[i - 1][j]$。 所以每次变化的只有等于 $x$ 的那些位置，根据单调性，这是一段区间，记为 $[p,q]$。 设 $j \in [p, q]$，要求 $mex(j, i)$，只需要知道最后一次出现的位置小于 $j$ 的最小的数。所以用线段树维护序列 $seq_{lastpos[x]} = x$ ，每次求区间最小值，找到对应位置 $index$，这个位置右边的所有 $A[i][j]$ 都等于这个最小值，然后令 $q = index$，反复迭代，直到待求区间为空。 分析一下这个操作的复杂度，每次相当于删除一个区间 $[p,q]$，添加若干个小区间。 开始只有一个区间，最后的区间数不超过 $n$，中间只会删除最多 $n$ 次区间。 所以添加区间的总次数不会超过 $2n$ ，复杂度为 $O(n \log n)$。 然后考虑回答询问。 ## 矩形交的面积 我们用四元组 $(top,bottom,left,right)$ 描述一个矩形 $\{(i,j):top \leq i \leq bottom,left \leq j \leq right\}$。 每次询问可以看作是询问矩形 $(l, r, l, r)$ 内 $A[i][j]=k$ 的个数。 那么由上面 $mex$ 的单调性可以发现，$A[i][j] = k$ 的点可以组成一个个连通块，每个连通块由若干个矩形构成**阶梯状**（矩形的 $left$ 相同，$right$ 递增）。 且前一个连通块的 $right$ 小于后一个连通块的 $left$。 问题转化为求这些矩形与询问矩形交的面积之和。 用 `std::vector` 存下每个 $k$ 的所有矩形，维护前缀面积和，二分出相交与非相交的临界点，对于完全包含的用前缀和搞定，对于相交却不包含的，由于是阶梯状，所以也可以 $O(1)$ 计算，细节有点多。 由上面的复杂度分析可知，所有矩形的数量不会超过 $2n$ 个，所以总复杂度 $O(n \log n)$。 ```cpp #include #ifdef LOCAL #define dbg(args.</description>
    </item>
    
    <item>
      <title>[Codeforces566C] Logistical Questions</title>
      <link>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</link>
      <pubDate>Mon, 07 Dec 2020 21:36:10 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</guid>
      <description>&gt; 一棵 $n$ 个节点的树，点有点权，边有边权。求这棵树的一个点 $r$ 使下面的式子最小： &gt; $$ &gt; \sum_{i \in Tree} val_i \times dist(i, r)^{\frac32} &gt; $$ &gt; $n \le 2 \times 10^5, val_i, dist(u, v) \ge 0$。 带权重心问题，有点妙。 设 $$ f(x) = \sum_{i \in Tree} val_i \times dist(i, x)^{\frac32} $$ 这里函数 $f$ 的定义域是整棵树（不仅包括原来的点，还包括边上的点 ）。 下面研究这个函数的性质。 树上的函数显然不太方便研究，所以考虑换一个 $\mathbf R$ 上的函数研究。 随便选择一条树上路径 $u \rightarrow v$ 作为 $x$ 轴，把 $u$ 当作原点，这样 $x$ 就是路径上的点到 $u$ 的距离。 ![](1.png) 这里以 $0 \rightarrow 5$ 为例，节点 $6 \dots 11$ 分别代表其父亲的一些子树。 记 $d_i = dist(i, 0)$，路径上的点分别考虑贡献： $$ f_i(x) = \begin{cases} \sum_{c \in subtree(i)} val_i\left (dist(i, c) + d_i - x\right)^\frac32 &amp; x \le d_i\\ \sum_{c \in subtree(i)} val_i\left(dist(i, c) + x - d_i\right)^\frac32 &amp; x &gt; d_i \end{cases}\\ f(x) = f_0(x) + f_1(x) + f_2(x) + f_3(x) + f_4(x) + f_5(x) $$ 发现 $f_i(x)$ 可以写成下面这种形式（其中 $c_1-x \ge 0, c_2 + x \ge 0$） $$ f_i(x) = \begin{cases} \sum v(c_1 - x)^\frac32 &amp; x \le d_i\\ \sum v(c_2 + x)^\frac32 &amp; x &gt; d_i \end{cases} $$ 求导（这里分段函数的分界点处显然可导） $$ f_i&#39;(x) = \begin{cases} -\frac32\sum v(c_1 - x)^\frac12 &amp; x \le d_i\\ \frac32\sum v(c_2 + x)^\frac12 &amp; x &gt; d_i \end{cases} \\ f_i&#39;&#39;(x) = \begin{cases} \frac34\sum v(c_1 - x)^{-\frac12} &amp; x \le d_i\\ \frac34\sum v(c_2 + x)^{-\frac12} &amp; x &gt; d_i \end{cases} $$ 发现 $f&#39;&#39;_i(x) \ge 0$，所以 $f&#39;&#39;(x) = \sum_if&#39;&#39;_i(x) \ge 0$，所以 $f(x)$ 是个凸函数，至多一个最小值。 注意到对于树上任意路径这个结论都成立，所以固定起点 $u$，对于所有终点 $v$ 求一次最小值就可以得到答案。 下图中 $2, 3, 4$ 都代表子树，假设当前在 $1$ ，需要考虑 $1 \rightarrow 2, 3, 4 \rightarrow \dots$ 几种路径。 !</description>
    </item>
    
  </channel>
</rss>
