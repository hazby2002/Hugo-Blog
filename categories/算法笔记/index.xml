<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法笔记 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 算法笔记 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>MIT</copyright>
    <lastBuildDate>Fri, 09 Jul 2021 11:21:34 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>位运算卷积(FWT) &amp; 集合幂级数</title>
      <link>https://blog.asukakyle.top/post/fwt/</link>
      <pubDate>Fri, 09 Jul 2021 11:21:34 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/fwt/</guid>
      <description>0x01.FWT 概论  位运算卷积 众所周知，多项式乘法是加法卷积, 因为第 \({i}\) 项和第 \({j}\) 项的乘积贡献到第 \({i+j}\) 项。
类似地定义位运算卷积 : \({}\) 第 \({i}\) 项和第 \({j}\) 项的乘积贡献到第 \({i \oplus j}\) 项。其中 \({\oplus}\) 是某种位运算。
即 \({S[k]=\sum_{i \oplus j=k} A[i] B[j]}\), 记作卷积式 \({A * B=S}\) 。
 构造的尝试 众所周知, \({\mathrm{FFT}}\) 把多项式转换成点值之后, 从卷积变为了直接点积。
我们自然也期望把位运算卷积转化成点积。
设 \({F W T(A)}\) 是幕级数 \({A}\) 经过 \({\mathrm{FWT}}\) 变换之后得到的幕级数。
我们需要令其满足 : \({ A * B=C \Longleftrightarrow F W T(A) \cdot F W T(B)=F W T(C)}\) (点积)。</description>
    </item>
    
    <item>
      <title>数论知识总结</title>
      <link>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 19 Mar 2021 10:28:29 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>1 欧几里得算法  欧几里得算法可以求两个数的最大公约数 \(\gcd(a, b)\)。
 不妨设 \(a \geq b, a = kb + r(k \geq 1, 0 \leq r &amp;lt; b)\)。
一方面，设 \(d_1\) 为 \(a, b\) 的一个公约数，则 \[ \begin{aligned} a &amp;amp;= k_ad_1\\ b &amp;amp;= k_bd_1\\ r &amp;amp;= a - kb\\ &amp;amp;= (k_a - kk_b)d_1 \end{aligned} \] 即 \(d_1\) 也是 \(r\) 的约数，\(b, r\) 的公约数。
另一方面，设 \(d_2\) 为 \(b, r\) 的一个公约数，则 \[ \begin{aligned} b &amp;amp;= k&amp;#39;_bd_2\\ r &amp;amp;= k_r&amp;#39;d_2\\ a &amp;amp;= kb + r\\ &amp;amp;= (kk&amp;#39;_b + k_r&amp;#39;)d_2 \end{aligned} \] 即 \(d_2\) 也是 \(a\) 的约数，\(a, b\) 的公约数。</description>
    </item>
    
    <item>
      <title>一类DP优化</title>
      <link>https://blog.asukakyle.top/post/%E4%B8%80%E7%B1%BBdp%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 18 Mar 2021 21:30:30 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E4%B8%80%E7%B1%BBdp%E4%BC%98%E5%8C%96/</guid>
      <description>对于一切形如 \(dp[i]=\max\{f_1(j)\times g_1(i)+f_2(j)\}+g_2(i)\) 的状态转移方程，
设 \(L_j(x)=f_1(j)x+f_2(j)\) 那么就有 \(dp[i]=max\{L_j(g_1(i))\}+g_2(i)\)。
从几何角度来看，只需要求出一些直线和 \(x=g_1(i)\) 交点的纵坐标的最大值。
李超线段树 利用李超线段树可以很好地维护上述信息。
李超线段树就是支持 \(O(\log N)\) 插入直线和查询 \(\max{L_i(x)}\) 的数据结构。
线段树的每个节点保存 \(L(mid)\) 最大的那条直线。
插入一条直线时，比较 \(L_{old}(mid)\) 和 \(L_{new}(mid)\)，较大者保留，较小者继续递归。
#define ls o&amp;lt;&amp;lt;1 #define rs o&amp;lt;&amp;lt;1|1 struct Line {  int k, b;  inline int func(int x) {  return k * x + b;  } } t[N &amp;lt;&amp;lt; 2]; void ins(int o, int l, int r, Line x) {  int mid = l + r &amp;gt;&amp;gt; 1;  bool lf = t[o].</description>
    </item>
    
    <item>
      <title>循环卷积优化</title>
      <link>https://blog.asukakyle.top/post/%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF%E4%BC%98%E5%8C%96/</link>
      <pubDate>Thu, 18 Mar 2021 21:11:58 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF%E4%BC%98%E5%8C%96/</guid>
      <description>前置知识  Fast Fourier Transform - HolyK 多项式系列操作  循环卷积优化  简介：目前网上关于多项式操作的文章和模板大多仍然是朴素的实现，常数巨大，这个技巧利用循环卷积优化多项式操作的常数。
（这个trick在N年前就有了，「循环卷积优化」这个名字是我瞎起的，如果有人知道这个trick的名字请联系我。）
 多项式求逆  求 \(B(x)\) 满足 \(A(x)B(x) \equiv 1 \pmod n\)。
 牛顿迭代得 \[ B_{t+1}(x) \equiv B_t(x)\left(2-A(x)B_t(x)\right)\pmod{x^{2^{t+1}}} \] 朴素的实现需要做3次长度为 \(2^{t+2}\) 的FFT，把多余的部分舍去，常数较大。
发现 \(B_{t+1}(x)\) 的前 \(2^t\) 项和 \(B_t(x)\) 一样，所以只需要求后 \(2^t\) 项，即求 \(A(x)B_t^2(x)\) 的 \(x^{2^t}\dots x^{2^{t+1}-1}\) 项系数。
设 \[ A(x)B_t(x) \equiv 1 + b_0x^{2^t}+b_1x^{2^t+1}+\dots+b_{2^t-1}x^{2^{t+1}-1} \pmod{x^{2^{t+1}}} \] 这个结果的前 \(2^t\) 项确定是1了，所以只有后半部分是有用的。
由于 \(\deg B_t = 2^t\)，如果做长度为 \(2^{t+1}\) 的卷积，多余的部分会循环到前半部分，不会影响后半部分的结果。
同样的， \(A(x)B_t^2(x) = A(x)B_t(x) \times B_t(x)\) ，卷积多余的部分会循环到前 \(2^t\) 项，后半部分不会受到影响。</description>
    </item>
    
    <item>
      <title>Fast Fourier Transform</title>
      <link>https://blog.asukakyle.top/post/fft/</link>
      <pubDate>Thu, 18 Mar 2021 15:28:59 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/fft/</guid>
      <description>Introduction  快速傅里叶变换(Fast Fourier Transform，FFT)是一种可在 \(O(n \log n)\) 时间内完成的离散傅里叶变换 (Discrete Fourier Transform，DFT) 的算法，用来实现将信号从原始域（通常是时间或空间）到频域的互相转化。
 FFT 在算法竞赛中主要用来加速多项式乘法（循环卷积）。
多项式 形如 \[ A(x) = a_0 + a_1x + a_2x^2 + \dots + a_{n-1}x^{n - 1} \] 的式子称为 \(x\) 的 \(n - 1\) 次多项式，其中 \(a_0, a_1, \dots, a_{n - 1}\) 称为多项式系数，\(n-1\) 称为多项式的次数，记为 \(\deg A(x)\) 或 \(\deg A\)。
点值 \(n - 1\) 次多项式 \(A(x)\) 在 \(x = m\) 处的点值 \[ A(m) = \sum_{k=0}^{n-1} a_km^k \]</description>
    </item>
    
  </channel>
</rss>
