<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态DP on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/%E5%8A%A8%E6%80%81dp/</link>
    <description>Recent content in 动态DP on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Fri, 19 Mar 2021 10:09:39 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/%E5%8A%A8%E6%80%81dp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Codeforces1413F]Roads and Ramen</title>
      <link>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</link>
      <pubDate>Fri, 19 Mar 2021 10:09:39 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</guid>
      <description>&gt; 给定一棵 $n$ 个点的无根树，每条边都有标记0或1。现在有 $m$ 次操作，每次操作将第 $id$ 条边的标记异或1。在每次操作后输出当前树上最长的有偶数个1的路径长度。 &gt; &gt; $n,m \leq 5 \times 10^5$。 ## 动态DP 设 $dp[x][0/1]$ 表示 $x$ 向下有偶数/奇数个1的最长路径，$dp[x][2]$ 表示 $x$ 子树内偶数个1的直径。 容易写出转移（$val_y$ 表示 $y$ 的父边的权值）： $$ \begin{aligned} dp&#39;[x][0] &amp;= \max\{dp[x][0], dp[y][val_y] + 1\}\\ dp&#39;[x][1] &amp;= \max\{dp[x][1], dp[y][val_y \oplus 1] + 1\}\\ dp&#39;[x][2] &amp;= \max\{dp[x][0] + dp[y][val_y] + 1, dp[x][1] + dp[y][val_y \oplus 1] + 1, dp[x][2],dp[y][2]\} \end{aligned} $$ 改写成 $x$ 从重儿子 $y$ 转移的矩阵（这里以 $val_y = 0$ 为例）： $$ \begin{bmatrix} dp&#39;[x][0]\\ dp&#39;[x][1]\\ dp&#39;[x][2]\\ 0 \end{bmatrix} = \begin{bmatrix} 1 &amp; -\infty &amp; -\infty &amp; dp[x][0]\\ -\infty &amp; 1 &amp; -\infty &amp; dp[x][1]\\ dp[x][0] + 1 &amp; dp[x][1] + 1 &amp; 0 &amp; dp[x][2]\\ -\infty &amp; -\infty &amp; -\infty &amp; 0 \end{bmatrix} \begin{bmatrix} dp[y][0]\\ dp[y][1]\\ dp[y][2]\\ 0 \end{bmatrix} $$ 上面的 $dp[x]$ 是指排除掉 $x$ 重儿子的答案，$dp&#39;[x]$ 是指完整的 $x$ 的答案。 $dp[x]$ 考虑直接用 `std::multiset` 存一下每个节点虚儿子的 $dp[y][0], dp[y][1], dp[y][2]$，取每个的最大和次大值即可快速求出。 复杂度是 $O(4^3 m \log n + m \log^2n)$，能跑过 $5 \times 10^5$ 也是奇迹。 **细节**：在 `multiset` 中删除 $-\infty$ 时不能直接查找对应的值，应该直接删除 `multiset` 中最小的那个值（具体见函数 `void erase(std::multiset&amp;, int)`）。 ```cpp #include #ifdef LOCAL #define dbg(args.</description>
    </item>
    
  </channel>
</rss>
