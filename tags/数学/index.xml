<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数学 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/%E6%95%B0%E5%AD%A6/</link>
    <description>Recent content in 数学 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>MIT</copyright>
    <lastBuildDate>Mon, 12 Jul 2021 08:12:01 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/%E6%95%B0%E5%AD%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[ICPC2014 WF]Pachinko</title>
      <link>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</link>
      <pubDate>Mon, 12 Jul 2021 08:12:01 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/icpc2014-wfpachinko/</guid>
      <description>有一个 \(h×w\) 的方格表，有些格子是墙，有些格子是终点，剩下的格子是空地。
你现在要在这里进行随机游走，其中，每一轮向上、下、左、右的概率分别为 \(u\%,d\%,l\%,r\%\)，如果移动后超过方格表或到达墙，则这次移动失效，保持原地不动。
当你到达终点时，游戏就结束了。现在，在方格表第一行的所有空地中均匀随机一个作为起点，求你就进入每个终点的概率。
\(1≤w≤20, 2≤h≤10000\)。
 设其中一个终点为 \(t\)，\(f_{i, j}\) 表示 \((i, j)\) 走到 \(t\) 的概率。 \[ f_{i, j} = uf_{i-1, j}+df_{i+1, j}+lf_{i, j-1}+rf_{i, j+1} \]
\[ f_{i, j} - uf_{i-1, j} - df_{i+1, j} - lf_{i, j-1} - rf_{i, j+1}=0 \]
\[ f_t=1 \]
\[ P\cdot\mathbf{f}=\mathbf{e} \]
\(P\) 是 \(wh \times wh\) 的方阵，\(\mathbf{f},\mathbf{e}\) 是列向量。其中 \(e_i=[i=t]\)。 \[ \mathbf{f}=P^{-1}\mathbf{f} \] 设 \(1\dots s\) 为起点 ，答案为 \[ ans = \frac1s \sum_{i=1}^sf_i \] 写成矩阵的形式，设行向量 \(\mathbf{v}^T=\begin{pmatrix} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0 &amp;amp; 0 &amp;amp; \cdots \end{pmatrix}\)，前面有 \(s\) 个1，其他都是0。 \[ \begin{aligned} ans &amp;amp;= \frac1s \mathbf{v}^T\mathbf{f}\\ &amp;amp;= \frac1s\mathbf{v}^TP^{-1}\mathbf{e}\\ \end{aligned} \] 相当于求行向量 \(\alpha^T = \dfrac1s\mathbf{v}^TP^{-1}\) 第 \(t\) 维的值，所以只要求出这个行向量即可。 \[ \alpha^T P = \frac1s\mathbf{v} \]</description>
    </item>
    
    <item>
      <title>Gym102994</title>
      <link>https://blog.asukakyle.top/post/gym102994/</link>
      <pubDate>Thu, 15 Apr 2021 09:03:20 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/gym102994/</guid>
      <description>总览   题号 A B C D E F G H I J K L M    完成情况 1 1 0 1 1 1 1 0 0 1 1 1 0    A. Everyone Loves Playing Games  A 有 \(N\) 对数， B 有 \(M\) 对数，A 从 \(N\) 对数中分别选一个数得到异或和 \(X\)，然后 B 从 \(N\) 对数得到一个异或和 \(Y\)，\(A\) 希望 \(X \oplus Y\) 最大，\(B\) 希望 \(X \oplus Y\) 最小，求最后的结果。</description>
    </item>
    
    <item>
      <title>Gym102441</title>
      <link>https://blog.asukakyle.top/post/gym102441/</link>
      <pubDate>Thu, 08 Apr 2021 22:39:55 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/gym102441/</guid>
      <description>总览   题号 A B C D E F G H I J K    完成情况 1 0 1 1 1 1 1 1 1 1 0    A. Template for Search  给定由小写字母、字符* 和 ? 组成的字符串 \(s\)，其中 * 可以被替换成任意串（包括空串），? 可以被替换成任意字符，求 \(s\) 可以表示成的最短回文串。
\(1 \leq |s| \leq 500\)。
 设 \(dp[l][r]\) 表示 \(l \dots r\) 能组成的最短回文串，有三种转移：
 \(s_l\) 匹配 \(s_r\) \(s_l = *\) 匹配右边一段 \(s_r = *\) 匹配左边一段  B.</description>
    </item>
    
    <item>
      <title>数论知识总结</title>
      <link>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 19 Mar 2021 10:28:29 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>1 欧几里得算法  欧几里得算法可以求两个数的最大公约数 \(\gcd(a, b)\)。
 不妨设 \(a \geq b, a = kb + r(k \geq 1, 0 \leq r &amp;lt; b)\)。
一方面，设 \(d_1\) 为 \(a, b\) 的一个公约数，则 \[ \begin{aligned} a &amp;amp;= k_ad_1\\ b &amp;amp;= k_bd_1\\ r &amp;amp;= a - kb\\ &amp;amp;= (k_a - kk_b)d_1 \end{aligned} \] 即 \(d_1\) 也是 \(r\) 的约数，\(b, r\) 的公约数。
另一方面，设 \(d_2\) 为 \(b, r\) 的一个公约数，则 \[ \begin{aligned} b &amp;amp;= k&amp;#39;_bd_2\\ r &amp;amp;= k_r&amp;#39;d_2\\ a &amp;amp;= kb + r\\ &amp;amp;= (kk&amp;#39;_b + k_r&amp;#39;)d_2 \end{aligned} \] 即 \(d_2\) 也是 \(a\) 的约数，\(a, b\) 的公约数。</description>
    </item>
    
    <item>
      <title>[Codeforces566C] Logistical Questions</title>
      <link>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</link>
      <pubDate>Mon, 07 Dec 2020 21:36:10 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces566c-logistical-questions/</guid>
      <description>一棵 \(n\) 个节点的树，点有点权，边有边权。求这棵树的一个点 \(r\) 使下面的式子最小： \[ \sum_{i \in Tree} val_i \times dist(i, r)^{\frac32} \] \(n \le 2 \times 10^5, val_i, dist(u, v) \ge 0\)。
 带权重心问题，有点妙。
设 \[ f(x) = \sum_{i \in Tree} val_i \times dist(i, x)^{\frac32} \] 这里函数 \(f\) 的定义域是整棵树（不仅包括原来的点，还包括边上的点 ）。
下面研究这个函数的性质。
树上的函数显然不太方便研究，所以考虑换一个 \(\R\) 上的函数研究。
随便选择一条树上路径 \(u \rightarrow v\) 作为 \(x\) 轴，把 \(u\) 当作原点，这样 \(x\) 就是路径上的点到 \(u\) 的距离。
 image-20201207203647011  这里以 \(0 \rightarrow 5\) 为例，节点 \(6 \dots 11\) 分别代表其父亲的一些子树。</description>
    </item>
    
  </channel>
</rss>
