<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据结构 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
    <description>Recent content in 数据结构 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>MIT</copyright>
    <lastBuildDate>Fri, 26 Mar 2021 17:56:38 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Codeforces955D]Scissors</title>
      <link>https://blog.asukakyle.top/post/codeforces955dscissors/</link>
      <pubDate>Fri, 26 Mar 2021 17:56:38 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces955dscissors/</guid>
      <description>给定两个串 \(s,t\) 整数 \(k\) ,你可以在 \(s\) 中取出任意的两个不相交的长度为 \(k\) 串，将它们按顺序拼在一起形成一个新串。
求一种取串的方案使得 \(t\) 是新串的子串。
\(|s|,|t| \leq 5 \times 10^5\)。
 kmp 算出正串和反串的能匹配 \(t\) 的前/后缀最大长度。
设 \(s\) 串的前缀 \([pre_1 \dots pre_i]\) 能匹配 \(t\) 的前缀集合为 \(P\)，后缀 \([suf_{i+1},suf_n]\) 能匹配 \(t\) 的后缀集合为 \(Q\)，只要判断是否存在 \(x\in P,y\in Q,x, y\leq k,x+y=|s|\) 即可。
类似 AC 自动机那样建出 fail 树，那么一个点能匹配的前缀长度集合就是在 fail 树上到根的路径，在正串 fail 树上维护集合 \(P\)，每次添加一个数 \(x\) 时，标记 \(k-x\) 对应在反串 fail 树上的点，每次查询反串 fail 树上一个点的祖先是否被标记。
具体实现时，标记一个点可以用子树加一，查询的时候单点查询即可。
复杂度 \(O(n \log n)\)。
#include &amp;lt;bits/stdc++.h&amp;gt; #define dbg(.</description>
    </item>
    
    <item>
      <title>[Codeforces1413F]Roads and Ramen</title>
      <link>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</link>
      <pubDate>Fri, 19 Mar 2021 10:09:39 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1413froads-and-ramen/</guid>
      <description>给定一棵 \(n\) 个点的无根树，每条边都有标记0或1。现在有 \(m\) 次操作，每次操作将第 \(id\) 条边的标记异或1。在每次操作后输出当前树上最长的有偶数个1的路径长度。
\(n,m \leq 5 \times 10^5\)。
 动态DP 设 \(dp[x][0/1]\) 表示 \(x\) 向下有偶数/奇数个1的最长路径，\(dp[x][2]\) 表示 \(x\) 子树内偶数个1的直径。
容易写出转移（\(val_y\) 表示 \(y\) 的父边的权值）： \[ \begin{aligned} dp&amp;#39;[x][0] &amp;amp;= \max\{dp[x][0], dp[y][val_y] + 1\}\\ dp&amp;#39;[x][1] &amp;amp;= \max\{dp[x][1], dp[y][val_y \oplus 1] + 1\}\\ dp&amp;#39;[x][2] &amp;amp;= \max\{dp[x][0] + dp[y][val_y] + 1, dp[x][1] + dp[y][val_y \oplus 1] + 1, dp[x][2],dp[y][2]\} \end{aligned} \] 改写成 \(x\) 从重儿子 \(y\) 转移的矩阵（这里以 \(val_y = 0\) 为例）： \[ \begin{bmatrix} dp&amp;#39;[x][0]\\ dp&amp;#39;[x][1]\\ dp&amp;#39;[x][2]\\ 0 \end{bmatrix} = \begin{bmatrix} 1 &amp;amp; -\infty &amp;amp; -\infty &amp;amp; dp[x][0]\\ -\infty &amp;amp; 1 &amp;amp; -\infty &amp;amp; dp[x][1]\\ dp[x][0] + 1 &amp;amp; dp[x][1] + 1 &amp;amp; 0 &amp;amp; dp[x][2]\\ -\infty &amp;amp; -\infty &amp;amp; -\infty &amp;amp; 0 \end{bmatrix} \begin{bmatrix} dp[y][0]\\ dp[y][1]\\ dp[y][2]\\ 0 \end{bmatrix} \] 上面的 \(dp[x]\) 是指排除掉 \(x\) 重儿子的答案，\(dp&amp;#39;[x]\) 是指完整的 \(x\) 的答案。</description>
    </item>
    
    <item>
      <title>[Codeforces1148H] Holy Diver</title>
      <link>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</link>
      <pubDate>Sat, 13 Mar 2021 00:43:08 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/codeforces1148h-holy-diver/</guid>
      <description>给定一个最初为空的数组，然后进行 \(n\) 次操作，每次操作给定 \(x,l,r,k\)，在数组末尾插入 \(x\) ，然后查询满足 \(mex(\{a_i, a_{i + 1}, \dots, a_j\}) = k\) 的数对 \((i,j)\) 的个数，强制在线。
\(mex(S)\) 表示集合 \(S\) 中最小的未出现的 自然数。
\(n \leq 2 \times 10^5\)。
 为表示方便，下面记 \(mex(i, j) = mex(\{a_i, a_{i + 1}, \dots, a_j\})\)。
容易发现，如果向集合 \(S\) 中添加数，\(mex(S)\) 不会减小。
所以如果固定右端点 \(j\)，\(mex(i, j)\) 是非严格单调减的；固定左端点 \(i\)，\(mex(i, j)\) 是非严格单调增的。
维护一个 \(n \times n\) 矩阵，\(A[i][j] = mex(j, i)\)，则矩阵 \(A\) 的每一行从左到右都是非严格单调减的，每一列从上到下都是非严格单调增的。
第 \(i\) 次操作增加一个数 \(x\)，考虑从第 \(i - 1\) 行拓展到第 \(i\) 行时矩阵 \(A\) 的变化。</description>
    </item>
    
  </channel>
</rss>
