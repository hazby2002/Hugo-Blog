<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>类 Euclidean 算法 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/%E7%B1%BB-euclidean-%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 类 Euclidean 算法 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Sun, 15 Aug 2021 21:24:32 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/%E7%B1%BB-euclidean-%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「万能」Euclidean 算法小记</title>
      <link>https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Sun, 15 Aug 2021 21:24:32 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E4%B8%87%E8%83%BD-euclidean-%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/</guid>
      <description>## 「万能」Euclidean 算法 $$ F(P, R, Q, N, X, Y) = \prod_{i = 0}^N \left(Y^{f(i) - f(i-1)}X\right) $$ 其中 $f(i) = \lfloor \dfrac{Pi+R}{Q}\rfloor, f(-1) = 0$​。$X, Y$ ~~为操作序列，有乘法结合律，类比矩阵~~ $\in$ **半群** $(S, \times)$。 若 $R \geq Q$​，则 $f(i)= \lfloor \dfrac{Pi+(R \bmod Q)}{Q}\rfloor + \lfloor\dfrac{R}{Q}\rfloor$​，所以 $$ F(P, R, Q, N, X, Y) = Y^{\lfloor\dfrac{R}{Q}\rfloor}F(P, R \bmod Q, Q, N, X, Y) $$ 若 $P \geq Q$​，则 $f(i)= \lfloor \dfrac{(P \bmod Q)i+R}{Q}\rfloor + \lfloor\dfrac{P}{Q}\rfloor i$​，记 $f&#39;(i)= \lfloor \dfrac{(P \bmod Q)i+R}{Q}\rfloor$​ $$ \begin{aligned} F(P, R, Q, N, X, Y) &amp;= X\prod_{i = 1}^N Y^{f&#39;(i) - f&#39;(i-1)}Y^{\lfloor\dfrac{P}{Q}\rfloor}X\\ &amp;= X\prod_{i = 0}^{N - 1} Y^{f&#39;(i+1) - f&#39;(i)}Y^{\lfloor\dfrac{P}{Q}\rfloor}X\\ &amp;= XF(P \bmod Q, (P \bmod Q) + R, Q, N - 1, Y^{\lfloor\dfrac{P}{Q}\rfloor}X, Y) \end{aligned} $$ 若 $P &lt; Q$，考虑交换 $X, Y$。 第 $i$ 个 $X$ 前有 $f(i)$ 个 $Y$，设第 $i$ 个 $Y$ 前有 $g(i)$ 个 $X$， $$ \begin{aligned} g(i) &amp;= \sum_{j \geq 0} [f(j) &lt; i+1]\\ &amp;= \sum_{j \geq 0} \left[\lfloor \frac{Pj+R}{Q}\rfloor &lt; i+1\right]\\ &amp;= \sum_{j \geq 0} \left[ Pj+R\ &lt; Qi+Q\right]\\ &amp;= \sum_{j \geq 0} \left[j &lt; \lfloor \frac{Qi + Q-R + P - 1}{P} \rfloor\right]\\ &amp;= \lfloor \frac{Qi + Q-R + P - 1}{P} \rfloor \end{aligned} $$ 但是末尾还有一些 $X$​ 后面没有 $Y$​，需要单独拿出来 $X^{N+1 - \max g(i)}$。​​ 于是 $$ F(P, R, Q, N, X, Y) = F(Q, Q - R + P - 1, P, \lfloor \frac{PN + R}{Q} \rfloor-1, Y, X)X^{N+1 - \max g(i)} $$ 复杂度为 $O(T(S) \log N\log \min\{p, q\})$，$T(S)$ 为 $S$ 上的乘法复杂度。 ## 模板 `S` 即半群 $(S, \times)$ 的结构体，这里假定它是幺半群（否则可以加一个幺元进去），则 `S()` 代表幺元。 ```cpp LL div(LL p, LL i, LL r, LL q) { return (p * i + r) / q; } S cal(LL p, LL r, LL q, LL n, const S &amp;x, const S &amp;y) { if (n &lt; 0) return S(); if (r &gt;= q) { return fpow(y, r / q) * cal(p, r % q, q, n, x, y); } if (p &gt;= q) { return x * cal(p % q, p % q + r, q, n - 1, fpow(y, p / q) * x, y); } if (p == 0) { return fpow(x, n + 1); } LL m = div(p, n, r, q); return cal(q, q - r + p - 1, p, m - 1, y, x) * fpow(x, n + 1 - (!</description>
    </item>
    
  </channel>
</rss>
