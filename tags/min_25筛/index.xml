<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>min_25筛 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/min_25%E7%AD%9B/</link>
    <description>Recent content in min_25筛 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Sat, 07 Aug 2021 10:38:55 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/min_25%E7%AD%9B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Min_25筛小记</title>
      <link>https://blog.asukakyle.top/post/min_25/</link>
      <pubDate>Sat, 07 Aug 2021 10:38:55 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/min_25/</guid>
      <description>## min_25 筛 约定 - $\mathbf{P}$ 表示全体质数集合 - $p_i$ 表示第 $i$ 个质数，特别地，$p_0 =1$。 - $\mathrm{lpf}_i$ 表示 $i$​ 的最小质因子。 &gt; 计算数论函数 $f(n)$​​​​ 的前缀和，要求 $f(p_i)$​​​​ 是低阶多项式，且对于合数 $n$​​​​，$f(n)$​ 可以写成形如 $f(n) = A(\mathrm{lpf}_n^e)B\left(\dfrac{n}{\mathrm{lpf_n^e}}\right)$​​​​的式子，其中 $A(p^e)$​​​​ 可以快速求值或预处理。 &gt; &gt; 当 $f(n)$​ 是积性函数时，$A(p^e) = f(p^e), B(n) = f(n)$​。 ### Part. 1 令 $$ g_k(n, i) = \sum_{j=1}^nj^k[j \in \mathbf{P} \ \mathrm{or}\ \mathrm{lpf}_j &gt; p_i] $$ 直观地，$g_k(n, i)$ 表示埃式筛第 $i$ 轮后剩余 $n$ 以内的数的 $k$ 次方之和。 $$ g_k(n, i) = \begin{cases} g_k(n, i - 1), &amp; p_i^2 &gt; n\\ g_k(n, i - 1) - p_i^k\left(g_k\left(\lfloor \dfrac{n}{p_i}\rfloor, i-1\right) - \sum_{j=1}^{i-1}p_j^k\right), &amp; p_i^2 \leq n \end{cases} $$ 直观地，考虑埃式筛第 $i$ 轮： - 如果 $p_i^2&gt;n$，那么这一轮不会筛去任何数，于是 $g_k(n, i) = g_k(n, i - 1)$ 。 - 如果 $p_i^2\leq n$，那么这一轮会筛去最小质因子等于 $p_i$ 的数，所以要减去计算这些数的 $k$ 次方之和，提出公因子 $p_i^k$ 后可得上式。 递推求出 $g_k(x, \infty)$​​​​ 在所有 $x = \lfloor \dfrac{n}{i}\rfloor$​​​​​​ 处的取值，复杂度是 $O\left(\dfrac{n^{\frac34}}{\log n}\right)$​​。 ```cpp // Calculate g(x, 0) on [n / i] int m = 0; for (LL i = 1, j; i &lt;= n; i = j + 1) { val[++m] = n / i; j = n / val[m]; g0[m] = (val[m] - 1) % P; // x - 1 g1[m] = (val[m] + 2) % P * g0[m] % P * (P + 1 &gt;&gt; 1) % P; // 2 + 3 + .</description>
    </item>
    
  </channel>
</rss>
