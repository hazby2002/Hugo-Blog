<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数论 on HolyK&#39;s Blog</title>
    <link>https://blog.asukakyle.top/tags/%E6%95%B0%E8%AE%BA/</link>
    <description>Recent content in 数论 on HolyK&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC BY-NC-SA 4.0</copyright>
    <lastBuildDate>Sat, 07 Aug 2021 10:38:55 +0800</lastBuildDate><atom:link href="https://blog.asukakyle.top/tags/%E6%95%B0%E8%AE%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Min_25筛小记</title>
      <link>https://blog.asukakyle.top/post/min_25/</link>
      <pubDate>Sat, 07 Aug 2021 10:38:55 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/min_25/</guid>
      <description>## min_25 筛 约定 - $\mathbf{P}$ 表示全体质数集合 - $p_i$ 表示第 $i$ 个质数，特别地，$p_0 =1$。 - $\mathrm{lpf}_i$ 表示 $i$​ 的最小质因子。 &gt; 计算数论函数 $f(n)$​​​​ 的前缀和，要求 $f(p_i)$​​​​ 是低阶多项式，且对于合数 $n$​​​​，$f(n)$​ 可以写成形如 $f(n) = A(\mathrm{lpf}_n^e)B\left(\dfrac{n}{\mathrm{lpf_n^e}}\right)$​​​​的式子，其中 $A(p^e)$​​​​ 可以快速求值或预处理。 &gt; &gt; 当 $f(n)$​ 是积性函数时，$A(p^e) = f(p^e), B(n) = f(n)$​。 ### Part. 1 令 $$ g_k(n, i) = \sum_{j=1}^nj^k[j \in \mathbf{P} \ \mathrm{or}\ \mathrm{lpf}_j &gt; p_i] $$ 直观地，$g_k(n, i)$ 表示埃式筛第 $i$ 轮后剩余 $n$ 以内的数的 $k$ 次方之和。 $$ g_k(n, i) = \begin{cases} g_k(n, i - 1), &amp; p_i^2 &gt; n\\ g_k(n, i - 1) - p_i^k\left(g_k\left(\lfloor \dfrac{n}{p_i}\rfloor, i-1\right) - \sum_{j=1}^{i-1}p_j^k\right), &amp; p_i^2 \leq n \end{cases} $$ 直观地，考虑埃式筛第 $i$ 轮： - 如果 $p_i^2&gt;n$，那么这一轮不会筛去任何数，于是 $g_k(n, i) = g_k(n, i - 1)$ 。 - 如果 $p_i^2\leq n$，那么这一轮会筛去最小质因子等于 $p_i$ 的数，所以要减去计算这些数的 $k$ 次方之和，提出公因子 $p_i^k$ 后可得上式。 递推求出 $g_k(x, \infty)$​​​​ 在所有 $x = \lfloor \dfrac{n}{i}\rfloor$​​​​​​ 处的取值，复杂度是 $O\left(\dfrac{n^{\frac34}}{\log n}\right)$​​。 ```cpp // Calculate g(x, 0) on [n / i] int m = 0; for (LL i = 1, j; i &lt;= n; i = j + 1) { val[++m] = n / i; j = n / val[m]; g0[m] = (val[m] - 1) % P; // x - 1 g1[m] = (val[m] + 2) % P * g0[m] % P * (P + 1 &gt;&gt; 1) % P; // 2 + 3 + .</description>
    </item>
    
    <item>
      <title>Gym102441</title>
      <link>https://blog.asukakyle.top/post/gym102441/</link>
      <pubDate>Thu, 08 Apr 2021 22:39:55 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/gym102441/</guid>
      <description>## 总览 | 题号 | A | B | C | D | E | F | G | H | I | J | K | |:--------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| | 完成情况 | 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | ## A. Template for Search &gt; 给定由小写字母、字符`*` 和 `?` 组成的字符串 $s$，其中 `*` 可以被替换成任意串（包括空串），`?` 可以被替换成任意字符，求 $s$ 可以表示成的最短回文串。 &gt; &gt; $1 \leq |s| \leq 500$。 设 $dp[l][r]$ 表示 $l \dots r$ 能组成的最短回文串，有三种转移： - $s_l$ 匹配 $s_r$ - $s_l = *$ 匹配右边一段 - $s_r = *$ 匹配左边一段 ## B.</description>
    </item>
    
    <item>
      <title>数论知识总结</title>
      <link>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 19 Mar 2021 10:28:29 +0800</pubDate>
      
      <guid>https://blog.asukakyle.top/post/%E6%95%B0%E8%AE%BA%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
      <description>## 1 欧几里得算法 &gt; 欧几里得算法可以求两个数的最大公约数 $\gcd(a, b)$。 不妨设 $a \geq b, a = kb + r(k \geq 1, 0 \leq r &lt; b)$。 一方面，设 $d_1$ 为 $a, b$ 的一个公约数，则 $$ \begin{aligned} a &amp;= k_ad_1\\ b &amp;= k_bd_1\\ r &amp;= a - kb\\ &amp;= (k_a - kk_b)d_1 \end{aligned} $$ 即 $d_1$ 也是 $r$ 的约数，$b, r$ 的公约数。 另一方面，设 $d_2$ 为 $b, r$ 的一个公约数，则 $$ \begin{aligned} b &amp;= k&#39;_bd_2\\ r &amp;= k_r&#39;d_2\\ a &amp;= kb + r\\ &amp;= (kk&#39;_b + k_r&#39;)d_2 \end{aligned} $$ 即 $d_2$ 也是 $a$ 的约数，$a, b$ 的公约数。 所以 $a, b$ 的公约数集合和 $b, r$ 的公约数集合相同，于是 $\gcd(a, b) = \gcd(b, r) = \gcd(b, a \bmod b)$ 递归求解，终止状态为 $b = 0$，此时原 $a, b$ 的公约数集合为 $a$ 的约数集合。 因为 $a = kb + r &gt; (k + 1)r$ 所以 $r &lt; \frac{a}{k + 1} \leq \frac{a}{2}$，所以每次 $a$ 最少折半，算法复杂度为 $O(\log a + \log b)$。 ```cpp int gcd(int a, int b) { return b ?</description>
    </item>
    
  </channel>
</rss>
